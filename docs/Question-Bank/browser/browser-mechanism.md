---
title: 浏览器工作原理
tags: [多进程, 多线程, 渲染进程, cookie, session, Storage]
categories: browser
---

# 浏览器工作原理

## CPU、进程、线程 的关系
- CPU（工厂）：计算机的核心是CPU，承担所有计算任务。
- 进程（车间）：进程是CPU资源分配和独立运行的最小单位。进程之间相互独立，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。
    - CPU使用时间片轮转进度算法来实现同时运行多进程。
    - 不同进程之间也可以通信，不过代价较大。
- 线程（工人）：线程是CPU调度的最小单位。一个进程中可以有多个线程，多个线程共享进程资源。
    - 单线程与多线程，都是指在一个进程内的单和多。

## 浏览器是多进程的

- 计算机中的每个应用程序都是一个进程，应用程序可分为多个子模块，这些子模块就对应多个子进程。
- 浏览器应用程序就是一个大进程，而每个tab页都是一个子进程，所以浏览器是多进程的。

### 浏览器多进程分类
- 主进程：浏览器的主进程（负责协调、主控），只有一个；
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建；
- GPU进程：用于3D绘制，最多一个；
- `渲染进程（浏览器内核）`：
    - 每个tab页面是一个渲染进程，互不影响。
    - 这个渲染进程也是多线程的，包含5大类线程。

## 渲染进程是多线程的

每一个tab页面可以看作是「渲染进程」进程，然后这个进程是多线程的，它有几大类线程：
- `GUI渲染线程`
    - 负责渲染页面，布局和绘制
    - 页面需要重绘和回流时，该线程就会执行
    - 与js引擎线程互斥，防止渲染结果不可预期
- `JS引擎线程`
    - 负责处理解析和执行javascript脚本程序
    - 只有一个JS引擎线程（单线程）
    - 与GUI渲染线程互斥，防止渲染结果不可预期
- `事件触发线程`
    - 用来控制事件循环（鼠标点击、setTimeout、ajax等）
    - 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
- `定时器线程`
    - setInterval与setTimeout所在的线程
    - 定时任务并不是由JS引擎计时的，是由定时器线程来计时的
    - 计时完毕后，通知事件触发线程
- `异步http请求线程`
    - 浏览器有一个单独的线程用于处理AJAX请求
    - 当请求完成时，若有回调函数，通知事件触发线程

### 两个问题

#### 为什么 javascript 是单线程的
- 创建 js 语言时，多线程架构的硬件支持并不好。
- 因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。
- 作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。
- 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

#### 为什么 GUI渲染线程 与 JS引擎线程 互斥
由于 js 可以操作 DOM，如果同时修改元素属性并同时渲染界面(即 JS线程和GUI线程同时运行)，会导致渲染线程前后获得的元素可能不一致。因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和JS引擎线程为互斥关系，当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。

这部分建议与[任务队列 与 Event Loop](/Question-Bank/execution/event-loop.md)一同食用。

## 浏览器存储

### Cookie 和 Session
- Cookie 和 Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是`为了解决HTTP无状态`的问题的。
- Cookie是保存在客户端浏览器的一小段的文本信息，`每个domain最多只能有20条Cookie`，每个Cookie`长度不能超过4KB`，否则会被截掉。考虑到安全应当使用Session而不是cookie。
- Session保存在服务器上。Session的运行依赖Session Id，而Session Id是存在Cookie中的，也就是说，如果浏览器禁用了Cookie，同时Session也会失效（但是可以通过其它方式实现，比如在url中传递session_id）。如果Cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道Cookie的意义，他只要原样转发Cookie就可以达到目的了。考虑到减轻服务器性能方面，应当使用cookie而不是session。
- 注：
    - cookie的键/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie前要用encodeURIComponent()编码，读取时再用decodeURIComponent()解码；
    - cookie默认的有效期是浏览器会话期间，作用域是整个浏览器而不仅仅局限于窗口或标签页；
    - cookie默认是不能跨域访问的，但对于主域相同子域不同的两个页面，document.domain设置为相同的父域名，即可实现不同子域名之间的跨域通信。

### Cookie 与 Web Storage
H5的Web Storage提供了两个拥有一致API的对象：
- window.localStorage：用来在本地存储永久数据的；
- window.sessionStorage：用来存储会话数据的（也就是tab不关闭时的数据）；
- 这两个对象存储的都是 name/value 。而且与Cookie不同，Web存储的大小比Cookie的大多了（`最少5MB`），而且通过这个策略存储的数据是`永远不会传输至server`的。
- 纵使Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外Cookie不可以跨域调用。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。
- 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像Cookie需要前端开发者自己封装setCookie，getCookie。


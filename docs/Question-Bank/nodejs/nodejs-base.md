# nodejs基础

[nodejs饭店故事 - Node.js : 我只需要一个店小二](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513044&idx=1&sn=9b8526e9d641b970ee5ddac02dae3c57&scene=21#wechat_redirect)

从计算机视角看「nodejs饭店故事」：
- 店小二：线程
- 顾客：http请求
- 第一类工作(迎客，找座，下单)：在服务器端的代码，能够快速执行
- 后厨做菜，客人吃饭：耗时的I/O 操作
- 后厨大喊一声：上菜，这是一个长时间I/O 操作完成的后所发出的事件
- 客人说：结账，另外一个长时间I/O 操作完成的后所发出的事件
- 第二类工作(上菜，结账)：同样是能快速执行的代码，但是他们需要等待那些耗时的I/O 操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在Node.js中实际上是在回调函数中来执行的

 

1. 下面是Node.js服务模式的伪代码：
```js
迎客();  
找座();  
下单();  
后厨处理("做菜完成事件"， function(){  
    上菜处理();
    客人吃饭("吃饭完成事件"，function(){  
        结账处理();  
        送客();  
    });  
});  
```
Node.js 使用的JavaScript作为服务器端的编程语言，这种回调的方式对于javascript程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。

另外Node.js使用Chrome的V8引擎来执行javascript，效率非常高。

2. 需要引起注意的是，不能写成如下这样：
```js
迎客();  
找座();  
下单();  
后厨处理("做菜完成事件"，function(){  
    上菜处理()；      
});  

客人吃饭("吃饭完成事件"，function(){  
    结账处理();  
});  

送客();   
```
因为Node.js执行"后厨处理()"函数时，只是安插了一个匿名的回调函数在那里，并不会等待（非阻塞I/O），反而马上 会执行“客人吃饭()"函数，所以上述的写法会引起逻辑上的错误：**还没上菜就开始吃饭了**！

所以写惯了”顺序阻塞I/O“的我们需要改变一下思维方式，进入到`事件驱动的世界`中来。

3. 如果某个操作例如“上菜处理” 是个**CPU密集型的计算任务**，Node.js那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成node.js所擅长的事件驱动的方式。





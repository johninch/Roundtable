---
{
    title: javascript数值
}
---
# 数值
## 整数和浮点数

- JavaScript的数字都是64位双精度浮点数

## 精度问题

```js
0.1 + 0.2 === 0.3 // false
```

*根据国际标准 IEEE 754*，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的:

- 第1位：符号位，0表示正数，1表示负数
- 第2位到第12位（共11位）：指数部分
- 第13位到第64位（共52位）：小数部分（即有效数字）
符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数11个二进制位，因此大小范围是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。

```
(-1)^符号位 * 1.xx...xx * 2^指数部分
```

上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。

精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2^53到2^53，都可以精确表示。

```js
Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996

// 超过有效数字部分将无法保存，直接转换成0
9007199254740996111 // 输入
9007199254740996000 // 输出
```

## 数值范围

> 根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2^1024到2^1023（开区间），超出这个范围的数无法表示。

如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。

```js
Math.pow(2, 1024) // Infinity
```

如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。

```js
Math.pow(2, -1075) // 0

// JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324
```

## 科学计数法

以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。
1. 小数点前的数字多于21位。

```js
1234567890123456789012
// 1.2345678901234568e+21

123456789012345678901
// 123456789012345680000
```
2. 小数点后的零多于5个。

```js
// 小数点后紧跟5个以上的零，
// 就自动转为科学计数法
0.0000003 // 3e-7

// 否则，就保持原来的字面形式
0.000003 // 0.000003
```

## 与数值相关的全局方法
### parseInt()

parseInt方法用于将字符串转为整数。
- 如果字符串头部有空格，空格会被自动去除。
- 如果parseInt的参数不是字符串，则会先转为字符串再转换。

```js
parseInt(1.23) // 1
// 等同于
parseInt('1.23') // 1
```

- 字符串转为整数的时候，是**一个个字符依次转换**，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。

```js
parseInt('12abc') // 12
```

- 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。
- 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。

```js
parseInt('0xff') // 255
```

- 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。

```js
// 这里整数部分有22位，超过了21位
parseInt(1000000000000000000000.1) // 1
// 相当于
parseInt('1e+21') // 1

// 控制台
1000000000000000000000.1 // 输入
1e+21 // 输出
```

### parseInt()用于进制转换
- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数

```ts
function parseInt(str: string, decimal: number = 10): number;

// 1000的二进制转化成十进制是 8
parseInt('1000', 2) // 8
parseInt('1000', 6) // 216
parseInt('1000', 8) // 512
// 超过36
parseInt('10', 37) // NaN
parseInt('10', 1) // NaN
parseInt('10', 0) // 10
parseInt('10', null) // 10
parseInt('10', undefined) // 10
```

- 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。

```js
// 二进制没有5 4 6，因此只取了已经转换的值
parseInt('1546', 2) // 1
parseInt('546', 2) // NaN
```

- 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。

```js
parseInt(0x11, 36) // 43
parseInt(0x11, 2) // 1

// 等同于
parseInt(String(0x11), 36)
parseInt(String(0x11), 2)

// 等同于
// 十六进制的0x11会被先转为十进制的17，再转为字符串
parseInt('17', 36)
parseInt('17', 2)
```

- 对于八进制

```js
parseInt(011, 2) // NaN

// 等同于
parseInt(String(011), 2)

// 等同于
parseInt(String(9), 2)
```

> **注意**：JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。

- 总结

parseInt的第一个参数无论如何都会先转换为十进制表示法，再转换为字符串，最后将该字符串转换为十进制。

## parseFloat()

## isNaN()

## isFinite()
isFinite方法返回一个布尔值，表示某个值**是否为正常的数值**。

```js
isFinite(Infinity) // false
isFinite(-Infinity) // false
isFinite(NaN) // false
isFinite(undefined) // false
isFinite(null) // true
isFinite(-1) // true
```

除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。

## 参考文章

[JavaScript 标准参考教程(基本语法之数值) —— 阮一峰](https://wangdoc.com/javascript/types/number.html)

# 2、密码安全-数据库密码强化

## 哈希摘要加密算法
服务器并不是一定安全的，有可能被窃取数据，如果服务器中存储密码时直接采用明文存储，则一旦泄露用户信息就会被窃取者直接使用。

因此，需要将密码使用哈希算法来加密得到密文存储。那用户登录输入明文密码时如何到数据库中去与密文比对呢？因为使用同一套哈希算法加密，通过保留的密钥再次对用户输入的明文密码加密，得到密文结果后去与数据库中的存储密文比对，也可以完成校验。并且，数据库中的密文是无法反推明文的。这样就既解决了安全性问题，也能够正常校验。

::: tip 什么是哈希算法
哈希算法（一类加密摘要算法）：常见的有`md5`、`sha1`、`sha256`等。哈希算法必须满足如下4个特点：
- 明文与密文一一对应
- 雪崩效应：明文小幅变化时，密文会剧烈变化
    - 比如 张老师 => zls，徐老师 => xls，这就不满足雪崩效应，因为明文变化了一点，密文也只变化了一点。
- 根据密文是无法反推明文的
- 不管明文有多长，密文是固定长度的
:::


### 加盐salt
但是，因为明文与密文是一一对应的，因此，世面上有很多反查网站，可以将相对简单的密码的明文和密文保存在一张大表中，这样，虽然从数学角度上无法反推，但可以通过这样暴力保存键值对来查询到。
```js
crypto = require('crypto')
hash = (type, str) => crypto.createHash(type).update(str).digest('hex')
const md5 = str => hash('md5', str)
const sha1 = str => hash('sha1', str)


const simplePsw = '111111'
const complexPsw = 'sfdf23rwfsof@s.efx/l-'
```
这就要求用户能够尽可能使用数字字母符号混合的方式来增强密码强度。

但作为服务提供方，我们不能要求用户做什么，因为用户是懒惰的，我们只能要求自己来解决，这里就要使用后端”加盐salt“：
- 当用户注册时，即在数据库中存储用户名密码时，给用户存储一个自己的`盐salt`字符串（随机生成的复杂字符串），并将salt与password连起来，一起进行哈希加密得到密码密文存储在数据库中。
    - 这相当于我们帮助用户提升了其密码强度，这样就不容易被反查出来了
- 当该用户登录校验时，将该用户名所对应的salt与password连起来，再次进行哈希加密，得到的密码密文就可以与数据库中保存的比对完成校验了。
```js
const encryptPassword = (salt, password) => md5(salt + simplePsw)
```





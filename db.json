[{"title":"进阶算法-动态规划","url":"/Roundtables/Algorithm/Dynamic-Programming/index.html","content":"---\n{\n  \"title\": \"动态规划\",\n}\n---\n\n# 进阶算法-动态规划\n\n动态规划算法 实现基本步骤4步（以不同路径题目为例）：\n- **确定状态表示**：令 `dp[i][j]` 是到达 `i`, `j` 最多路径；\n- **划分最优子结构**：路径总和 `dp[i][j]` 可以拆分为 `dp[i-1][j]` 与 `dp[i][j-1]` 子路径；\n- **得出状态转移方程**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`；\n- **确定边界（base case，最简单情况）**：对于第一行 `dp[0][j]`，或者第一列 `dp[i][0]`，由于都是在边界，所以只能为 1。\n\n## 1、不同路径\n\n- [不同路径](./uniquePaths.md)\n- [不同路径 II](./uniquePaths2.md)\n\n## 2、最短路径\n\n- [K 站中转内最便宜的航班](/Algorithm/Dynamic-Programming/findCheapestPrice/)\n"},{"title":"K 站中转内最便宜的航班","url":"/Roundtables/Algorithm/Dynamic-Programming/findCheapestPrice.html","content":"# K 站中转内最便宜的航班\n\n[leetcode - 787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)\n\n有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。\n\n现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。\n\n示例 1：\n```\n输入: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\n输出: 200\n```\n\n## 代码\n\n### Johninch\n递归，超时（动态规划不要用递归来做）\n```js\n// F(src, dst, k) = Min(F(src, dst-1, k-1) + F(dst-1, dst, 1))\nlet findCheapestPrice = function(n, flights, src, dst, k) {\n    let cheap = (flights, src, dst, k) => {\n        let prev = flights.filter(item => item[1] === dst)\n        let min = Math.min.apply(null, prev.map(item => {\n            if (k > -1 && item[0] === src) {\n                // 边界1：从dst往回找到了src，且中转次数不为-1，返回当前价格\n                return item[2]\n            } else if (k == 0 && item[0] !== src) {\n                // 边界2：中转次数已经为0，但从dst往回找没有找到src，设一个无限大的价格\n                return Number.MAX_SAFE_INTEGER\n            } else {\n                // 状态转移方程\n                return item[2] + cheap(flights, src, item[0], k-1)\n            }\n        }))\n\n        return min\n    }\n\n    // 增加返回值是不是Number.MAX_SAFE_INTEGER，如果是返回-1\n    let min = cheap(flights, src, dst, k)\n    return min >= Number.MAX_SAFE_INTEGER ? -1 : min\n};\n```\n"},{"title":"不同路径","url":"/Roundtables/Algorithm/Dynamic-Programming/uniquePaths.html","content":"# 不同路径\n\n[leetcode - 62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n示例 1:\n```\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n```\n\n## 题解\n\n### Johninch\n令`dp[i][j]`为到坐标`i，j`的路径数，`dp[m-1][n-1]`则为到右下角终点的路径数：\n```js\nvar uniquePaths = function(m, n) {\n    // 构建 DP table，m行，n列，坐标为从 0 ~ m-1， 0 ~ n-1\n    let dp = Array.from(new Array(m), () => new Array(n).fill(0))\n\n    // 确定左边界\n    for (let i = 0; i < m; i++) {\n        dp[i][0] = 1\n    }\n    // 确定上边界\n    for (let j = 0; j < n; j++) {\n        dp[0][j] = 1\n    }\n    // 动态规划推导\n    for(let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        }\n    }\n\n    return dp[m-1][n-1]\n};\n```\n将上面写法合在一个循环体中：\n```js\nvar uniquePaths = function(m, n) {\n    let dp = Array.from(new Array(m), () => new Array(n).fill(0))\n\n    for(let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i == 0) {\n                // 确定上边界\n                dp[0][j] = 1\n            } else if (j == 0) {\n                // 确定左边界\n                dp[i][0] = 1\n            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n\n    return dp[m-1][n-1]\n};\n```\n"},{"title":"不同路径 II","url":"/Roundtables/Algorithm/Dynamic-Programming/uniquePaths2.html","content":"# 不同路径 II\n\n[leetcode - 63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n说明：m 和 n 的值均不超过 100。\n\n示例 1:\n```\n输入:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出: 2\n```\n解释:\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n通过次数5\n\n## 题解\n\n### Johninch\n使用 DP-table。与62. 不同路径-解法一一样，区别就是此题设置了障碍物而已。\n    - 既然是障碍物，说明此路不通，即经过此节点的路径数为0，所以当遇到障碍物时，设置dp[i][j] = 0即可\n    - 那么第一行第一列数据初始化的时候就不能都是1了，因为有的地方有障碍物存在\n    - 初始化dp二维数组的时候各个节点都不可达，都为0\n        - 这样dp递推的时候，只需要在62题的基础上加上arr[i][j]当前节点不为障碍物的条件即可\n        - 而有障碍物的地方为0，加0也就等于没走\n\n```js\nvar uniquePathsWithObstacles = function(arr) {\n    let m = arr.length, n = arr[0].length\n\n    // 初始化为不可达\n    let dp = Array.from(new Array(m), () => new Array(n).fill(0))\n\n    // 检查起始或者目标元素是不是1（被占用了），如果起始或者最后那个格就是1，说明怎么都怎么不到那，直接返回0\n    if (arr[0][0] == 1 || arr[m-1][n-1] == 1) return 0\n\n    // 确定初始边界\n    dp[0][0] = 1\n\n    // 由初始边界确定 左边界（第一列）\n    for (let i = 1; i < m; i++) {\n        if (arr[i][0] != 1) {\n            dp[i][0] = dp[i-1][0];\n        }\n    }\n\n    // 由初始边界确定 上边界（第一行）\n    for (let j = 1; j < n; j++) {\n        if (arr[0][j] != 1) {\n            dp[0][j] = dp[0][j-1];\n        }\n    }\n\n    // 动态规划推导\n    for (let i = 1; i < m ; i++) {\n        for (let j = 1; j < n; j++) {\n            if (arr[i][j] != 1) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n    }\n\n    return dp[m-1][n-1]\n};\n```\n\n递归，超时：(都动态规划了，就不要考虑结合递归去做了)\n```js\nvar uniquePathsWithObstacles = function(arr) {\n    let m = arr.length; n = arr[0].length;\n    let dp = (m, n) => {\n        // 检查起始或者目标元素是不是1（被占用了），如果起始或者最后那个格就是1，说明怎么都怎么不到那，直接返回0\n        if (arr[0][0] === 1 || arr[m-1][n-1] === 1) return 0\n\n        if (m === n === 2) {\n            return (arr[0, 1] === 1 || arr[1, 0] === 1) ? 0 : 1\n        } else if (m < 2) {\n            return (arr[m - 1].includes(1)) ? 0 : 1\n        } else if (n < 2) {\n            for (let i = 0; i < m - 1; i++) {\n                if (arr[i][n - 1] === 1) {\n                    return 0\n                }\n            }\n            return 1\n        } else {\n            return dp(m - 1, n) + dp(m, n - 1)\n        }\n    }\n\n    return dp(m, n)\n};\n```"},{"title":"进阶算法-贪心算法","url":"/Roundtables/Algorithm/Greedy/index.html","content":"---\n{\n  \"title\": \"贪心算法\",\n}\n---\n\n# 进阶算法-贪心算法\n\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。\n\n贪心算法不是对所有问题都能得到整体最优解，**`关键是贪心策略的选择`**，选择的贪心策略**`必须具备无后效性`**，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。\n\n注意：`贪心算法需要针对不同的case选择不同的策略，不一定你选择的策略就是最贪的，即使不是最贪策略，也不能说当前的贪心策略不对，贪心策略需要大量的数据去验证和迭代，逼近最优解。所以贪心，关键是一种算法思想。`\n\n## 1、最大利润\n\n1. 策略1：从最低点买入，在最高点卖出（追求单次利益）；\n2. 策略2：从低点买入，只要可以赚钱就卖出；不断买卖（追求多次利益，单次利益不够）；\n3. 策略3：从低点买入，到价格高点卖出，不断买卖（在保证单次利益的基础上，实现多次交易）；\n\n前两种策略都不够贪，3最贪。\n\n- [买卖股票的最佳时机](./maxProfit.md)\n- [买卖股票的最佳时机 II](./maxProfit2.md)\n\n股票买卖问题也可以参考动态规划公式来求解：\n[动态规划 DP-table 公式](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/)\n\n## 2、找零钱\n\n1. 策略1：给钱找零，不区分金额直到找到足够的金钱（追求单次找零）；\n2. 策略2：给钱找零，优先给金额大的零钱，尽量把零钱放在手里（追求多次找零）；\n\n策略2更贪，因为可以保留更多零钱在手里。\n\n- [柠檬水找零](./lemonadeChange.md)\n\n"},{"title":"柠檬水找零","url":"/Roundtables/Algorithm/Greedy/lemonadeChange.html","content":"# 柠檬水找零\n\n[leetcode - 860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)\n\n在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\n\n顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n\n注意，一开始你手头没有任何零钱。\n\n如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n\n示例 1：\n```\n输入：[5,5,5,10,20]\n输出：true\n解释：\n前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n```\n\n## 代码\n\n### Johninch\n应该区分具体面值处理，优先找零10元，再找零5元：\n```js\nvar lemonadeChange = function(bills) {\n    let five = 0, ten = 0;\n    for (let i = 0; i < bills.length; i++) {\n        let money = bills[i], gap;\n        if (money === 5) {\n            five++\n        } else if (money === 10) {\n            ten++\n            if (five > 0) {\n                five--\n            } else {\n                return false\n            }\n        } else {\n            if (ten > 0 && five > 0) {\n                ten--\n                five--\n            } else if (!ten && five >= 3) {\n                five = five - 3;\n            } else {\n                return false\n            }\n        }\n    }\n\n    return true\n};\n```\n\n时间复杂度高，不区分具体面值：\n```js\nvar lemonadeChange = function(bills) {\n    let hand = [];\n    for (let i = 0; i < bills.length; i++) {\n        let money = bills[i], gap;\n\n        hand.push(money);\n        hand.length && hand.sort((a, b) => b - a);\n\n        if (money > 5) {\n            gap = money - 5;\n            for (var j = 0; j < hand.length; j++) {\n                if (hand[j] <= gap) {\n                    gap = gap - hand[j]\n                    hand.splice(j ,1)\n                    j--;\n                }\n            }\n\n            if (gap > 0) return false\n        }\n    }\n\n    return true\n};\n```\n\n\n\n"},{"title":"买卖股票的最佳时机","url":"/Roundtables/Algorithm/Greedy/maxProfit.html","content":"# 买卖股票的最佳时机\n\n[leetcode - 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n示例 1:\n```\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n## 题解\n\n### Johninch\n只能交易一次（买入并卖出），买卖策略：\n- 遍历\n    - 如果是下跌日，则更新最低价；\n    - 如果是上涨日，则更新交易利润；\n\n```js\nvar maxProfit = (prices) => {\n    let profit = 0, minPrice = Number.MAX_SAFE_INTEGER;\n\n    for (var i = 0; i < prices.length; i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else {\n            profit = Math.max(profit, prices[i] - minPrice);\n        }\n    }\n\n    return profit\n}\n```\n"},{"title":"买卖股票的最佳时机 II","url":"/Roundtables/Algorithm/Greedy/maxProfit2.html","content":"# 买卖股票的最佳时机 II\n\n[leetcode - 122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n```\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n## 题解\n\n### Johninch\n股票买卖策略：\n- 单独交易日： 设今天价格 P1、明天价格 P2，则今天买入、明天卖出可赚取金额 P2 - P1（负值代表亏损）。\n- 连续上涨交易日： 设此上涨交易日股票价格分别为P1,P2,...,Pn。则第一天买最后一天卖收益最大，即 Pn - P1。`等价于每天都买卖`，即 Pn - P1 = (P2 - P1) + (P3 - P2) + ... + (Pn - Pn-1)。\n- 连续下跌交易日：不买卖收益最大，即不会亏钱。\n```js\nvar maxProfit = (prices) => {\n    let profit = 0, gap;\n    for (var i = 1; i < prices.length; i++) {\n        gap = prices[i] - prices[i-1]\n        if (gap > 0) {\n            profit += gap;\n        }\n    }\n\n    return profit\n}\n```\n\n"},{"title":"数据结构-链表概述","url":"/Roundtables/Algorithm/Linked-List/index.html","content":"---\n{\n  \"title\": \"链表概述\",\n}\n---\n\n# 数据结构-链表概述\n\n用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。\n\n- 需要遍历才能查询到元素，查询慢。\n- 插入元素只需断开连接重新赋值，插入快。\n\n![链表](./images/linked-list.png)\n\n链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。\n\n## 1、基本应用\n> 主要是对链表基本概念和特性的应用，如果基础概念掌握牢靠，此类问题即可迎刃而解\n\n - [✔️从尾到头打印链表](./print-from-tail-to-head)\n - [✔️删除链表中重复的节点](./delete-repeat-node)\n - [✔️反转链表](./reverse-linked-list)\n - [✔️合并两个有序链表](./merge-two-sorted-link)\n - [✔️复杂链表的复制](./copy-complicated-linked-list)\n\n## 2、环类题目\n> 环类题目即从判断一个单链表是否存在循环而扩展衍生的问题\n\n - [✔️链表中环的入口结点](./entry-node-of-loop)\n - [环形链表](./deep-clone)\n - [约瑟夫环](./deep-clone)\n\n## 3、双指针\n> 双指针的思想在链表和数组中的题目都经常会用到，主要是利用两个或多个不同位置的指针，通过速度和方向的变换解决问题。\n\n- 两个指针从不同位置出发：一个从始端开始，另一个从末端开始；\n- 两个指针以不同速度移动：一个指针快一些，另一个指针慢一些。\n\n> 对于单链表，因为我们只能在一个方向上遍历链表，所以第一种情景可能无法工作。然而，第二种情景，也被称为慢指针和快指针技巧，是非常有用的。\n\n - [✔️两个链表的第一个公共节点](./find-first-common-node)\n - [✔️链表倒数第k个节点](./find-Kth-to-tail)\n - [相交链表](./deep-clone)\n\n## 4、双向链表\n> 双链还有一个引用字段，称为prev字段。有了这个额外的字段，您就能够知道当前结点的前一个结点。\n\n - [扁平化多级双向链表](./deep-clone)\n\n## 5、未归类\n\n - [合并两个排序的链表](./deep-clone)\n"},{"title":"复杂链表的复制","url":"/Roundtables/Algorithm/Linked-List/copy-complicated-linked-list.html","content":"---\n{\n  \"title\": \"[基本]复杂链表的复制\",\n}\n---\n\n# 复杂链表的复制\n\n## 1、题目描述\n输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。\n\n## 2、思路\n本题有以下三种解法：\n- 第一种：先按照next复制，然后依次添加random指针，添加时需要定位random的位置，定位一次需要一次遍历，需要O（n^2）的复杂度。\n\n- 第二种：先按照next复制，然后用一个hashmap保存原节点和复制后节点的对应关系，则用O（n）的空间复杂度使时间复杂度降到了O（n）。\n\n- 第三种（最优方法）：同样先按next复制，但是把复制后的节点放到原节点后面，则可以很容易的添加random，最后按照奇偶位置拆成两个链表，时间复杂度O（n），不需要额外空间。\n\n![](./images/copy-complicated-linked-list-01.png)\n![](./images/copy-complicated-linked-list-02.png)\n![](./images/copy-complicated-linked-list-03.png)\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction Clone(pHead) {\n  if (pHead === null) {\n    return null\n  }\n  cloneNodes(pHead);\n  cloneRandom(pHead);\n  return reconnectNodes(pHead);\n}\n\nfunction cloneNodes(pHead) {\n  var current = pHead;\n  while (current) {\n    var cloneNodes = {\n      var: current.val,\n      next: current.next\n    };\n    current.next = cloneNodes;\n    current = cloneNodes.next;\n  }\n}\n\nfunction cloneRandom(pHead) {\n  var current = pHead;\n  while (current) {\n    var cloneNodes = current.next;\n    if (current.random) {\n      cloneNode.random = current.random\n    } else {\n      cloneNode.random = null;\n    }\n\n    current = cloneNode.next;\n  }\n\nfunction reconnectNodes(pHead) {\n  var current = pHead;\n  var cloneHead = pHead.next;\n  var cloneNode = pHead.next;\n\n  while(current) {\n    current.next = cloneNode.next;\n    current = cloneNode.next\n    if (current) {\n      cloneNode.next = current.next;\n      cloneNode = current.next\n    } else {\n      cloneNode.next = null;\n    }\n  }\n  return cloneHead;\n}\n}\n\n```\n\n"},{"title":"删除链表中重复的结点","url":"/Roundtables/Algorithm/Linked-List/delete-repeat-node.html","content":"---\n{\n  \"title\": \"[基本]删除链表中重复的结点\",\n}\n---\n\n# 删除链表中重复的结点\n\n## 1、题目描述\n在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5。\n\n## 2、思路\n关于链表的大多数题目还是比较简单的，本题也并不太难。\n\n删除重复结点，也就是如果当前结点和下一个结点的值相同，那么就是重复的结点，都可以被删除，为了保证删除之后的链表的连通性，在删除之后，要把当前结点前面的结点和下一个没有重复的结点链接起来，为此，程序需要记录当前的最后一个不重复结点，即程序中的pre。重点在于：一定要确保当前链接到链表中的一定是不会再重复的结点，具体见代码实现。\n\n  关于第一个结点如果重复怎么办的问题，我们不用单独考虑，可以使用链表中一贯的做法，加一个头结点即可。\n\n  具体思路看代码比较直观，参考如下的代码实现。\n\n## 3、代码实现\n\n## Caleb\n``` js\n\nfunction deleteDuplication(pHead) {\n      const map = {};\n      if (pHead && pHead.next) {\n        let current = pHead;\n        // 计数\n        while (current) {\n          const val = map[current.val];\n          map[current.val] = val ? val + 1 : 1;\n          current = current.next;\n        }\n        current = pHead;\n        while (current) {\n          const val = map[current.val];\n          if (val > 1) {\n            // 删除节点\n            console.log(val);\n            if (current.next) {\n              current.val = current.next.val;\n              current.next = current.next.next;\n            } else if (current === pHead) {\n              current = null;\n              pHead = null;\n            } else {\n              current = pHead;\n              while (current.next.next) {\n                current = current.next;\n              }\n              current.next = null;\n              current = null;\n            }\n\n          } else {\n            current = current.next;\n          }\n        }\n      }\n      return pHead;\n    }\n\n```\n"},{"title":"链表中环的入口结点","url":"/Roundtables/Algorithm/Linked-List/entry-node-of-loop.html","content":"---\n{\n  \"title\": \"[环类]链表中环的入口结点\",\n}\n---\n\n# 链表中环的入口结点\n\n## 1、题目描述\n给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\n\n## 2、思路\n  本题是一个比较典型的链表题目，难度适中。首先，对于大多人来说，看到这道题是比较开心的，因为判断一个链表是否存在环的方法，基本上大家都知道，就是快慢指针法，但是再仔细一看，本题除了判断是否有环之外，还要找到这个环的入口点，这就略有些复杂了。\n\n  具体思路如下：\n\n- 第一步：确定一个链表是否有环。这一步就是快慢指针法，定义两个指针，同时从链表的头结点出发，快指针一次走两步，慢指针一次走一步。如若有环，两个指针必定相遇，也就是如果快指针反追上了慢指针，说明存在环（这里要注意，两指针相遇的地方一定在环中，但不一定是环的入口），如果快指针走到了链表的末尾（指向了NULL），则说明不存在环。\n\n- 第二步：找到环的入口点。这还是可以利用双指针来解决，两个指针初始都指向头结点，如果我们可以知道环中的结点个数，假设为n，那么第一个指针先向前走n步，然后两个指针（另一个从头结点开始）同时向前，当两个指针再次相遇时，他们的相遇点正好就是环的入口点。\n\n  这其实并不难理解，假设链表中共有m个结点，环中有n个结点，那么除环以外的结点数就是m-n，第一个指针先走了n步，然后两个指针一起向前，当他们一起向前n-m步时，第一个链表正好走完一遍链表，返回到环的入口，而另一个指针走了n-m步，也正好是到了环的入口。\n\n  现在，我们还有一个关键的问题：如何知道链表中的环包含了几个结点呢？也就是，怎么求这个n。\n\n  实际上这也不难，在第一步中，我们提到：快慢指针相遇的地方一定在环中，并且通过第一步我们已经找到了这个位置，接下来，只要从这个相遇的结点出发，一边移动一边计数，当它绕着环走一圈，再次回到这个结点时，就可以得到环中的结点数目n了。\n\n![](./images/entry-node-of-loop.png)\n\n## 3、代码实现\n\n"},{"title":"链表中倒数第k个结点","url":"/Roundtables/Algorithm/Linked-List/find-Kth-to-tail.html","content":"---\n{\n  \"title\": \"[双指针]链表中倒数第k个结点\",\n}\n---\n\n# 链表中倒数第k个结点\n\n## 1、题目描述\n输入一个链表，输出该链表中倒数第k个结点。为了符合习惯，从1开始计数，即链表的尾结点是倒数第1个节点。例如，一个链表有6个结点，从头结点开始，它们的值依次是1,2,3,4,5,6。则这个链表倒数第三个结点是值为4的结点。\n\n## 2、思路\n  对于单链表来说，没有从后向前的指针，因此一个直观的解法是先进行一次遍历，统计出链表中结点的个数n，第二次再进行一次遍历，找到第n-k+1个结点就是我们要找的结点，但是这需要对链表进行两次遍历。\n\n  为了实现一次遍历，我们这里采用双指针解法。我们可以定义两个指针，第一个指针从链表的头指针开始先向前走k步，第二个指针保持不动，从第k+1步开始，第二个指针也从头开始前进，两个指针都每次前进一步。这样，两个指针的距离都一直保持在k，当快指针（走在前面的）到达null时，慢指针（走在后面的）正好到达第k个结点。注意：要时刻留意空指针的判断。\n\n![](./images/find-Kth-to-tail.png)\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction findKthNode(head, k) {\n  var fastPointer = head;\n  var slowPointer = head;\n  var curStep = 0;\n  var current = head;\n  while(current) {\n    if (curStep >= k) {\n      slowPointer = current;\n    }\n    curStep++;\n    current = current.next;\n  }\n\n  return slowPointer\n}\n```\n\n"},{"title":"两个链表的第一个公共结点","url":"/Roundtables/Algorithm/Linked-List/find-first-common-node.html","content":"---\n{\n  \"title\": \"[双指针]两个链表的第一个公共结点\",\n}\n---\n\n# 两个链表的第一个公共结点\n\n## 1、题目描述\n输入两个链表，找出它们的第一个公共结点。\n\n## 2、思路\n  本题首先可以很直观的想到蛮力法，即对链表1(假设长度为m)的每一个结点，遍历链表2(假设长度为n)，找有没有与其相同的结点，这显然复杂度为O(mn)。\n\n  进一步考虑，我们可以得到以下三种改进的解法：\n\n  方法一：借助辅助栈。我们可以把两个链表的结点依次压入到两个辅助栈中，这样两个链表的尾结点就位于两个栈的栈顶，接下来比较两个栈顶的结点是否相同。如果相同，则把栈顶弹出继续比较下一个，直到找到最后一个相同的结点。此方法也很直观，时间复杂度为O(m+n)，但使用了O(m+n)的空间，相当于用空间换区了时间效率的提升。\n\n  方法二：将两个链表设置成一样长。具体做法是先求出两个链表各自的长度，然后将长的链表的头砍掉，也就是长的链表先走几步，使得剩余的长度与短链表一样长，这样同时向前遍历便可以得到公共结点。时间复杂度为O(m+n)，不需要额外空间。\n\n  方法三：将两个链表拼接起来。 将两个链表进行拼接，一个链表1在前链表2在后，另一个链表2在前链表1在后，则合成的两个链表一样长，然后同时遍历两个链表，就可以找到公共结点，时间复杂度同样为O(m+n)。\n\n![](./images/find-first-common-node.png)\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction getFirstCommonNode(head1, head2) {\n  if (head1 === null || head2 === null) {\n    return null\n  }\n  var current = head1;\n  var stack1 = putNodeIntoStack[head1];\n  var stack2 = putNodeIntoStack[head2];\n  for(var i=0, len = stack1.length; i<len; i++) {\n    var node = current.next;\n    if (stack1[i] === stack2[i]) {\n      current.next = node;\n      current = current.next;\n    } else {\n      if (i === 0){\n        current = null\n      }\n      break;\n    }\n  }\n\n}\n\nfunction putNodeIntoStack(head) {\n  var stack = [];\n  while(head) {\n    stack.unshift(head.val);\n    head = head.next\n  }\n\n  return stack;\n}\n```\n\n"},{"title":"合并两个有序链表","url":"/Roundtables/Algorithm/Linked-List/merge-two-sorted-link.html","content":"---\n{\n  \"title\": \"[基本]合并有序链表\",\n}\n---\n\n# 合并两个有序链表\n\n## 1、题目描述\n输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。\n\n## 2、思路\n\n首先需要判断几个特殊情况，即判断输入的两个指针是否为空。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。\n\n两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针，剩余的结点仍然是排序的，所以合并的步骤和之前是一样的，所以这是典型的递归过程，用递归可以轻松实现。\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction mergeList(head1, head2) {\n\n  if(head1 === null || head2 === null){\n    return head1 || head2\n  }\n  const head = null;\n  if(head1.val <= head2.val){\n    head = head1;\n    head.next = mergeList(head1.next, head2)\n  }else{\n    head = head2;\n    head.next = mergeList(head1, head2.next)\n  }\n}\n```\n\n"},{"title":"从尾到头打印链表","url":"/Roundtables/Algorithm/Linked-List/print-from-tail-to-head.html","content":"---\n{\n  \"title\": \"[基本]从尾到头打印链表\",\n}\n---\n\n# 从尾到头打印链表\n\n## 1、题目描述\n输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\n\n## 2、思路\n(三种方法：借助栈、递归、列表的首位插入)\n\n  从头到尾打印链表比较简单，从尾到头很自然的可以想到先将链表进行反转，然后再打印。但是，通常我们不希望改变原链表的结构，这是一个只读操作。\n\n  因此，我们进一步分析，可以发现排在后面的先输出，这是一个典型的“后入先出”的思想，因此很自然的可以想到用栈来实现，每遍历一个结点，可以将其压入栈中，遍历结束后再逐个弹栈，将结点值存入ArrayList，这样就实现了从尾到头的打印。\n\n  更进一步，既然想到了用栈，那一定可以通过递归来实现。每访问到一个结点，先递归输出其后的结点，在输出该结点自身即可。\n\n  另外，当我们使用Java或者python语言时，有一种比较巧妙的方法就是使用列表的插入方法，每次插入数据，都总是插入到首位，这样得到的List就是从尾到头的链表序列。\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction getArrayList (head) {\n\tvar arr = [];\n\twhile (head) {\n\t\tarr.unshift(head.val);\n\t\thead = head.next\n\t}\n\n\treturn arr\n}\n\n```\n\n\n"},{"title":"反转链表","url":"/Roundtables/Algorithm/Linked-List/reverse-linked-list.html","content":"---\n{\n  \"title\": \"[基本]反转链表\",\n}\n---\n\n# 反转链表\n\n## 1、题目描述\n输入一个链表，反转链表后，输出新链表的表头。\n\n## 2、思路\n本题比较简单，有两种方法可以实现：（1）三指针。使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。将指针反转后，三个结点依次前移即可。（2）递归方法。同样可以采用递归来实现反转。将头结点之后的链表反转后，再将头结点接到尾部即可。\n\n## 3、代码实现\n\n## Caleb\n``` js\nfunction reverseList(head){\n\tlet currentNode = null;\n\tlet headNode = head;\n\twhile(head && head.next){\n\t\tcurrentNode = head.next;\n\t\thead.next = currentNode.next;\n\t\tcurrentNode.next = headNode;\n\t\theadNode = currentNode;\n\t}\n\treturn headNode\n}\n```"},{"title":"时间复杂度和空间复杂度","url":"/Roundtables/Algorithm/index.html","content":"---\n{\n  \"title\": \"前端算法学习\",\n}\n---\n\n## 时间复杂度和空间复杂度\n\n首先要搞懂时间复杂度和空间复杂度的概念，它们的高低共同决定着一段代码质量的好坏：\n\n#### 1. 时间复杂度\n\n一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。\n\n> 没有循环语句，记作O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O(n)，也叫线性阶。\n\n常见的时间复杂度有：\n- O(1): Constant Complexity: Constant 常数复杂度\n- O(log n): Logarithmic Complexity: 对数复杂度\n- O(n): Linear Complexity: 线性时间复杂度\n- O(n^2): N square Complexity 平⽅方\n- O(n^3): N square Complexity ⽴立⽅方\n- O(2^n): Exponential Growth 指数\n- O(n!): Factorial 阶乘\n\n![Time-Complexity](./images/Time-Complexity.png)\n\n#### 2. 空间复杂度\n\n一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。\n\n一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。\n\n\n\n## 数据结构\n\n> 数据结构即数据元素相互之间存在的一种和多种特定的关系集合。\n\n\n一般你可以从两个维度来理解它，逻辑结构和存储结构。\n\n#### 1. 逻辑结构\n\n![数据结构的逻辑结构](./images/structure-two-type.png)\n\n简单的来说逻辑结构就是数据之间的关系，逻辑结构大概统一的可以分成两种：线性结构、非线性结构。\n\n- 线性结构：是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。常用的线性结构有: 栈，队列，链表，线性表。\n- 非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。常见的非线性结构有 二维数组，树等。\n\n#### 2. 存储结构\n\n存储结构是逻辑结构用计算机语言的实现。常见的存储结构有顺序存储、链式存储、索引存储以及散列存储。\n\n例如：\n- 数组在内存中的位置是连续的，它就属于顺序存储；\n- 链表是主动建立数据间的关联关系的，在内存中却不一定是连续的，它属于链式存储；\n- 还有顺序和逻辑上都不存在顺序关系，但是你可以通过一定的方式去放问它的哈希表，数据散列存储。\n\n\n## 目录\n\n#### 链表\n\n - [:100:从尾到头打印链表](/Algorithm/Linked-List/print-from-tail-to-head)\n - [:100:删除链表中重复的节点](/Algorithm/Linked-List/delete-repeat-node)\n - [:100:反转链表](/Algorithm/Linked-List/reverse-linked-list)\n - [:100:复杂链表的复制](/Algorithm/Linked-List/copy-complicated-linked-list)\n - [:100:链表中环的入口结点](/Algorithm/Linked-List/entry-node-of-loop)\n - [环形链表](/Algorithm/Linked-List/deep-clone)\n - [约瑟夫环](/Algorithm/Linked-List/deep-clone)\n - [:100:两个链表的第一个公共节点](/Algorithm/Linked-List/find-first-common-node)\n - [:100:链表倒数第k个节点](/Algorithm/Linked-List/find-Kth-to-tail)\n - [相交链表](/Algorithm/Linked-List/deep-clone)\n - [扁平化多级双向链表](/Algorithm/Linked-List/deep-clone)\n - [合并两个排序的链表](/Algorithm/Linked-List/deep-clone)\n\n#### 数组\n  - [xxx](/Algorithm/Array/deep-clone)\n\n#### 栈和队列\n  - [xxx](/Algorithm/Stack-and-Queue/deep-clone)\n\n#### 树和二叉树\n  - [xxx](/Algorithm/Tree-and-Binary-Tree/deep-clone)\n\n#### 字符串\n  - [xxx](/Algorithm/String/deep-clone)\n\n#### 递归\n  - [:100:汉诺塔问题](/Algorithm/Recursion/hanota.md)\n\n#### 查找\n  - [xxx](/Algorithm/Search/deep-clone)\n\n#### 位运算\n  - [xxx](/Algorithm/Bitwise/deep-clone)\n\n#### 回溯法\n  - [xxx](/Algorithm/Backtracking/deep-clone)\n\n#### 数学\n  - [xxx](/Algorithm/Math/deep-clone)\n\n#### 哈希表\n  - [xxx](/Algorithm/Hashtable/deep-clone)\n\n#### 堆\n  - [xxx](/Algorithm/Heap/deep-clone)\n\n#### 贪心算法\n  - [:100:买卖股票的最佳时机](./Greedy/maxProfit.md)\n  - [:100:买卖股票的最佳时机 II](./Greedy/maxProfit2.md)\n  - [:100:柠檬水找零](./Greedy/lemonadeChange.md)\n\n#### 动态规划与\n  - [:100:不同路径](/Algorithm/Dynamic-Programming/uniquePaths.md)\n  - [:100:不同路径 II](/Algorithm/Dynamic-Programming/uniquePaths2.md)\n  - [:100:K 站中转内最便宜的航班](/Algorithm/Dynamic-Programming/within-k-stops/)\n"},{"title":"递归","url":"/Roundtables/Algorithm/Recursion/index.html","content":"# 递归\n\n- [汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)\n\n\n\n\n"},{"title":"汉诺塔问题","url":"/Roundtables/Algorithm/Recursion/hanota.html","content":"# 汉诺塔问题\n\n[leetcode - 面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)\n\n在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:\n(1) 每次只能移动一个盘子;\n(2) 盘子只能从柱子顶端滑出移到下一根柱子;\n(3) 盘子只能叠在比它大的盘子上。\n\n请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。\n\n你需要原地修改栈。\n\n示例1:\n```\n 输入：A = [2, 1, 0], B = [], C = []\n 输出：C = [2, 1, 0]\n```\n示例2:\n```\n 输入：A = [1, 0], B = [], C = []\n 输出：C = [1, 0]\n```\n\n提示: A中盘子的数目不大于14个。\n\n\n## 题解\n\n解题思路：`递归与分治`\n\n这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。\n\n假设 n = 1,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；\n\n如果 n = 2 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 4 步。\n\n如果 n > 2 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。\n\n就**将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题**，依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是`分治`的思想。\n\n而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：\n\n- n = 1 时，直接把盘子从 A 移到 C；\n- n > 1 时，\n    - 先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；\n    - 再将最大的盘子从 A 移到 C；\n    - 再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。\n\n```js\nlet hanota = function(A, B, C) {\n    let move = (A, B, C, n) => {\n        if (n === 0) return\n        move(A, C, B, n-1)  // n-1从A到B\n        C.push(A.pop())     // n从A到C\n        move(B, A, C, n-1)  // n-1从B到C\n\n        return C\n    }\n\n    return move(A, B, C, A.length)\n};\n```\n\n\n"},{"title":"排序算法","url":"/Roundtables/Algorithm/Sort/index.html","content":"---\n{\n  \"title\": \"排序算法\",\n}\n---\n\n# 排序算法\n\n![排序算法复杂度](./images/sort.png)\n\n> 选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。\n- [快速排序](./fast-sort.md)\n\n\n> 循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。\n- 冒泡排序\n\n\n> 每次排序取一个最大或最小的数字放到前面的有序序列中。\n- [选择排序](./selection-sort.md)\n\n\n> 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n- [希尔排序](./shell-sort.md)\n\n\n> 将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。\n- 归并排序\n\n\n> 将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。\n- 插入排序\n\n\n\n"},{"title":"快速排序","url":"/Roundtables/Algorithm/Sort/fast-sort.html","content":"# 快速排序\n\n快速排序使用分治和递归来实现的：\n-（1）在数据集之中，选择一个元素作为\"基准\"（pivot）。\n-（2）所有小于\"基准\"的元素，都移到\"基准\"的左边；所有大于\"基准\"的元素，都移到\"基准\"的右边。\n-（3）对\"基准\"左边和右边的两个子集，不断递归重复第一步和第二步，直到所有子集只剩下一个元素为止。\n复杂度平均情况：O(nlogn)\n\n\n## Johninch\n\n#### 三路快排（快排优化）\n- 如果需要排序的数组有大量重复元素，可以用基于三向切分的快速排序大幅度提高效率。\n- 基础的快排，每一次递归，将数组拆分为两个，递归出口是数组长度为 <=1。如果递归过程中某个数组出现大量重复元素，基于原始快排还需要继续递归下去，但实际上已经不需要。因此可以用三向切分，将数组切分为三部分，大于基准元素，等于基准元素，小于基准元素。\n- 可以设置一个 mid 数组用来保存等于基准元素的元素集合，基准元素其实可是是任意一个元素，这里选了最后一个，比较方便。\n```js\n// 三路快排\nquick3waySort = function (arr) {\n  var len = arr.length;\n  if (len <= 1) return arr;\n\n  var pivot = arr.pop(),\n      left = [],\n      right = [],\n      mid = pivot;\n\n  arr.forEach(item => {\n    if (item < pivot) {\n      left.push(item);\n    } else if (item > pivot) {\n      right.push(item);\n    } else {\n      mid.push(item);\n    }\n  });\n\n  var _left = quick3waySort(left),\n      _right = quick3waySort(right);\n\n  return _left.concat(mid, _right);\n};\n```\n\n#### 一行代码实现快排\n```js\nfunction quickSort(a) {\n  return a.length <= 1 ? a : quickSort(a.slice(1).filter(item => item <= a[0])).concat(a[0], quickSort(a.slice(1).filter(item => item > a[0])));\n}\n```\n"},{"title":"选择排序","url":"/Roundtables/Algorithm/Sort/selection-sort.html","content":"# 选择排序\n\n选择排序是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n复杂度平均情况：O(n2)\n\n\n## Johninch\n```js\nfunction selection_sort = function () {\n  var i, j, min;\n  var temp;\n  for (i = 0; i < this.length - 1; i++) {\n    min = i;\n    for (j = i + 1; j < this.length; j++) {\n      if (this[min] > this[j]) {\n        min = j;\n      }\n    }\n    temp = this[min];\n    this[min] = this[i];\n    this[i] = temp;\n  }\n  return this;\n};\n```\n"},{"title":"希尔排序","url":"/Roundtables/Algorithm/Sort/shell-sort.html","content":"# 希尔排序\n\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。\n\n\n## Johninch\n```js\n// 希尔排序\nfunction shellSort(arr) {\n  var len = arr.length,\n    temp,\n    gap = 1;\n  while (gap < len / 3) {//动态定义间隔序列\n    gap = gap * 3 + 1;\n  }\n  for (gap; gap > 0; gap = Math.floor(gap / 3)) {\n    for (var i = gap; i < len; i++) {\n      temp = arr[i];\n      for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {\n        arr[j + gap] = arr[j];\n      }\n      arr[j + gap] = temp;\n    }\n  }\n  return arr;\n}\n```\n"},{"title":"数据结构-树和二叉树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/index.html","content":"---\n{\n  \"title\": \"树和二叉树概述\",\n}\n---\n\n# 数据结构-树和二叉树\n\n树是用来模拟具有树状结构性质的数据集合。而二叉树是树最简单、应用最广泛的种类。二叉树是每个节点最多有两个子树的树结构，通常将当前节点称作“根节点”，子树被称作“左子树”和“右子树”。\n\n# 完全二叉树的一些公式\n\n完全二叉树：除了最后一层，所有层的节点数达到最大，与此同时，最后一层的所有节点都在最左侧。（堆使用完全二叉树）\n\n1. 第n层的节点数最多为2<sup>n</sup>个节点；\n2. n层二叉树最多有2<sup>0</sup>+...+2<sup>n</sup>=2<sup>n+1</sup>-1个节点；\n3. 第一个非叶子节点：length/2；\n4. 一个节点的孩子节点：2n、2n+1。\n\n满二叉树：所有层的节点数达到最大。\n\n## 二叉树的构造\n二叉树有两种表示形式：链表形式 与 数组形式。\n### 链表形式表示\n一般情况下，二叉树都通过链表形式存储：\n```js\n// 二叉树节点\nclass Node {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n}\n```\n\n### 数组形式表示\n对于完全二叉树可以使用「**层序遍历数组**」表示，因为对完全二叉树而言，可以很容易通过数组下标确认相互关系，比如堆排序中使用的最大堆最小堆，就是直接利用数组模拟完全二叉树，进而构造最大（最小）堆，实现排序。\n\n对于一般二叉树也可以使用数组表示，为表述清晰，会增加必要的null值，比如下图：\n```\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n\n   1\n    \\\n     2\n    /\n   3\n```\n用数组表示为：[5,1,4,null,null,3,6] 、 [1,null,2,3]\n\n注：*在leetcode上做题时，一般都是给出数组表示，leetcode的测试用例会自动将其转成链表形式，但如果我们本地需要验证测试用例时，还需要自己手动转换。*\n\n### 基本结构与功能\n```js\n// 二叉树节点\nclass Node {\n    constructor(val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n    // show() {\n    //     console.log(this.data);\n    // }\n}\n\nclass Tree {\n    constructor(data = null) {\n        this.root = data;\n    }\n\n    // 基础方法：插入、遍历、深度\n    insert(data) {\n        var node = new Node(data, null, null);\n        if (!this.root) {\n            this.root = node;\n            return;\n        }\n        var current = this.root;\n        var parent = null;\n        while (current) {\n            parent = current;\n            if (data < parent.data) {\n                current = current.left;\n                if (!current) {\n                    parent.left = node;\n                    return;\n                }\n            } else {\n                current = current.right;\n                if (!current) {\n                    parent.right = node;\n                    return;\n                }\n            }\n\n        }\n    },\n    preOrder(node) {\n        if (node) {\n            node.show();\n            this.preOrder(node.left);\n            this.preOrder(node.right);\n        }\n    },\n    middleOrder(node) {\n        if (node) {\n            this.middleOrder(node.left);\n            node.show();\n            this.middleOrder(node.right);\n        }\n    },\n    laterOrder(node) {\n        if (node) {\n            this.laterOrder(node.left);\n            this.laterOrder(node.right);\n            node.show();\n        }\n    },\n    getMin() {\n        var current = this.root;\n        while (current) {\n            if (!current.left) {\n                return current;\n            }\n            current = current.left;\n        }\n    },\n    getMax() {\n        var current = this.root;\n        while (current) {\n            if (!current.right) {\n                return current;\n            }\n            current = current.right;\n        }\n    },\n    getDeep(node, deep) {\n        deep = deep || 0;\n        if (node == null) {\n            return deep;\n        }\n        deep++;\n        var dleft = this.getDeep(node.left, deep);\n        var dright = this.getDeep(node.right, deep);\n        return Math.max(dleft, dright);\n    }\n\n    // 将 层序遍历数组 转换成 链表形式\n    static toLinklistMode(data) {\n        let toNode = item => {\n            if (!item) {\n                return null;\n            } else {\n                return new Node(item);\n            }\n        };\n\n        let queue = [];\n        const root = toNode(data.shift());\n        queue.push(root); // 入队列第一个元素\n\n        while (data.length > 0) {\n            //当数组里还有项的时候就拿数组的项去填充队列\n            let current = queue.shift();\n\n            current.left = toNode(data.shift());\n            if (current.left) {\n                queue.push(current.left);\n            }\n\n            current.right = toNode(data.shift());\n            if (current.right) {\n                queue.push(current.right);\n            }\n        }\n\n        return root;\n    }\n\n    // 将 链表形式 转换成 层序遍历数组\n    static toArrayMode(root) {\n        let queue = [];\n        let list = [];\n\n        queue.push(root);\n\n        while (queue.length > 0) {\n            let current = queue.shift();\n\n            if (current.left) {\n                queue.push(current.left);\n                list.push(current.left.val);\n            } else {\n                list.push(null);\n            }\n\n            if (current.right) {\n                queue.push(current.right);\n                list.push(current.right.val);\n            } else {\n                list.push(null);\n            }\n        }\n\n        // 我们在深度优先遍历的时候将节点保存下来，如果是null也保存，完全二叉树的性质要求我们不能有null混在值中\n        // 拿到这个list之后\n        // 第一步是将最后连续的null删掉\n        let point = list.length - 1; // 从表最后开始看\n        while (list[point] === null) {\n            list.pop();\n            point--;\n        }\n\n        // 之后再检查list中是否还有null，如果没有就是完全二叉树，有就不是\n        //  return list.every((item)=>{return item!==null})\n        return [root.val].concat(list); // 换成输出这行代码就能输出二叉树的数组表示形式，与前面的constructor方法正好相反\n    }\n}\n```\n\n### 树查找\n::: details 树查找\n```js\ngetNode(data, node) {\n    if (node) {\n        if (data === node.data) {\n            return node;\n        } else if (data < node.data) {\n            return this.getNode(data,node.left);\n        } else {\n            return this.getNode(data,node.right);\n        }\n    } else {\n        return null;\n    }\n}\n```\n:::\n\n### 二分查找\n\n二分查找的条件是必须是有序的线性表。\n\n和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。\n::: details 二分查找\n```js\nfunction binarySearch(data, arr, start, end) {\n    if (start > end) {\n        return -1;\n    }\n    var mid = Math.floor((end + start) / 2);\n    if (data == arr[mid]) {\n        return mid;\n    } else if (data < arr[mid]) {\n        return binarySearch(data, arr, start, mid - 1);\n    } else {\n        return binarySearch(data, arr, mid + 1, end);\n    }\n}\nvar arr = [0, 1, 1, 1, 1, 1, 4, 6, 7, 8]\nconsole.log(binarySearch(1, arr, 0, arr.length-1));\n```\n:::\n\n## 经典题目\n\n### 1、二叉树遍历\n如何遍历一棵树\n有两种通用的遍历树的策略：\n\n1. 深度优先搜索（DFS）\n    - 在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。\n    - 深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为`先序遍历`，`中序遍历`和`后序遍历`。\n2. 宽度优先搜索（BFS）\n    - `层序遍历`，按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n\n下图中的顶点按照访问的顺序编号，按照 `1-2-3-4-5` 的顺序来比较不同的策略。\n![DFS与BFS](./images/DFS-and-BFS.png)\n\n> 重点中的重点，最好同时掌握递归和非递归版本，递归版本很容易书写，但是真正考察基本功的是非递归版本。\n\n - [:100:二叉树的中序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/inorder-traversal)\n - [:100:二叉树的前序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/preorder-traversal)\n - [:100:二叉树的后序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/postorder-traversal)\n - [:100:二叉树的层序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/levelOrder-traversal)\n - [:100:重建二叉树](/Roundtable/Algorithm/Tree-and-Binary-Tree/reconstruct-binary-tree)\n - [:100:求二叉树的后序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/get-HRD)\n\n### 2、二叉树的对称性\n\n - [:100:对称的二叉树](/Roundtable/Algorithm/Tree-and-Binary-Tree/is-symmetrical)\n - [:100:二叉树的镜像](/Roundtable/Algorithm/Tree-and-Binary-Tree/mirror)\n\n### 3、二叉搜索树\n> 二叉搜索树是特殊的二叉树，考察二叉搜索树的题目一般都是考察二叉搜索树的特性，所以掌握好它的特性很重要。\n\n1. 节点的左子树只包含小于当前节点的数。\n2. 节点的右子树只包含大于当前节点的数。\n3. 所有左子树和右子树自身必须也是二叉搜索树。\n\n - [生成二叉搜索树](/Roundtable/Algorithm/Tree-and-Binary-Tree/gennerate-BST)\n - [:100:验证二叉搜索树](/Roundtable/Algorithm/Tree-and-Binary-Tree/isValidBST)\n - [:100:二叉搜索树的第k个节点](/Roundtable/Algorithm/Tree-and-Binary-Tree/kth-node)\n - [:100:二叉搜索树的后序遍历](/Roundtable/Algorithm/Tree-and-Binary-Tree/verify-squence-of-BST)\n\n### 4、二叉树的深度\n> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n> 平衡二叉树：左右子树深度之差大于1。\n\n - [:100:二叉树的最大深度](/Roundtable/Algorithm/Tree-and-Binary-Tree/max-depth)\n - [:100:二叉树的最小深度](/Roundtable/Algorithm/Tree-and-Binary-Tree/min-depth)\n - [:100:平衡二叉树](/Roundtable/Algorithm/Tree-and-Binary-Tree/is-balanced)\n\n"},{"title":"构造二叉搜索树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/generate-BST.html","content":"# 构造二叉搜索树\n\n## 题目\n输入一串数字的数组，数组中的数字唯一且没有空值，构造一颗二叉搜索树。\n\n## 代码\n\n### Johninch\n将一串数字，构造成二叉搜索树：\n```js\nconst generateBST = (data) => {\n    let root = new Node(data.shift())\n\n    let insert = (node, data) => {\n        if (node.val > data) {\n            if (!node.left) {\n                node.left = new Node(data)\n            } else {\n                this.insert(node.left, data)\n            }\n        } else {\n            if (!node.right) {\n                node.right = new Node(data)\n            } else {\n                this.insert(node.right, data)\n            }\n        }\n    }\n\n    // 遍历所有的数据，逐渐插入到当前这颗搜索树中\n    data.forEach(item => insert(root, item))\n\n    return root\n}\n```\n"},{"title":"求二叉树的后序遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/get-HRD.html","content":"# 求二叉树的后序遍历\n\n## 题目\n给定一棵二叉树的前序遍历和中序遍历，求其后序遍历\n\n输入描述:\n\n两个字符串，其长度n均小于等于26。 第一行为前序遍历，第二行为中序遍历。 二叉树中的结点名称以大写字母表示：A，B，C....最多26个结点。\n\n输出描述:\n\n输入样例可能有多组，对于每组测试样例， 输出一行，为后序遍历的字符串。\n\n#### 示例\n```\n输入\nABC\nBAC\nFDXEAG\nXDEFAG\n\n输出\nBCA\nXEDGAF\n```\n\n## 代码\n\n### johninch\n```js\nvar getHRD = () => {\n    let preorder, inorder;\n    let rebulidPostTree = (preorder, inorder) => {\n        if (!preorder.length) {\n            return null;\n        }\n\n        if (preorder.length === 1) {\n            return preorder[0];\n        }\n\n        const root = preorder[0];\n        const index = inorder.findIndex(root);\n\n        const inLeft = inorder.slice(0, index);\n        const inRight = inorder.slice(index + 1);\n        const preLeft = preorder.slice(1, index + 1);\n        const preRight = preorder.slice(index + 1);\n\n        return rebulidPostTree(preLeft, inLeft) + rebulidPostTree(preRight, inRight) + root;\n    }\n\n    while(preorder = readline()) {\n        inorder = readline();\n        console.log(rebulidPostTree(preorder, inorder))\n    }\n}\n```\n\n\n"},{"title":"二叉树的中序遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/inorder-traversal.html","content":"# 二叉树的中序遍历\n\n## 题目\n给定一个二叉树，返回它的 `中序` 遍历。\n\n#### 示例\n```js\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n输出: [1,3,2]\n```\n请分别以 `递归`、`非递归` 方法实现？\n\n## 代码\n\n### Johninch\n\n本部分是三序遍历的实现，主要分为两类：递归和迭代\n三序遍历的递归方式非常简单，而对应的迭代法，本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。\n其实三序遍历都有一种莫里斯遍历解法，但这种方法会破坏原树结构，且不易理解，感兴趣的话去leetcode研究下。\n\n#### 中序遍历 - 递归\n```js\nconst inorder = (root, arr = []) => {\n    if (root) {\n        inorder(root.left, arr)\n        arr.push(root.val)\n        inorder(root.right, arr)\n    }\n\n    return arr\n}\n```\n#### 中序遍历 - 迭代 - 栈遍历 (中序出栈再输出)\n```js\nconst inorderTraversal = (root) => {\n    const res = [];\n    const stack = [];\n    let current = root;\n\n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack.pop();\n        res.push(current.val); // 前序入栈就输出，中序出栈再输出，后续是对前序的修改\n\n        current = current.right;\n    }\n\n    return res;\n};\n```\n\n### niannings\n\n```ts\n/**\n * 中序遍历算法：\n * 1. 初始化一个指针node指向根节点，初始化一个栈stack，并将node压入；\n * 2. 如果node存在便将node压入stack并将其左子节点赋给node，如果不存在则从stack弹出一个赋给node，**并访问node**，然后将node的右子节点赋给node；\n * 3. 重复步骤2，直到stack清空\n * @param handler 处理函数\n */\nexport function middleEach<N extends IBinaryTreeNodeBase = IBinaryTreeNodeBase>(\n    root: N,\n    handler: (node: N) => void\n) {\n    if (root === null) return;\n    let node = root;\n    const stack = [];\n    while (stack.length || node) {\n        if (node) {\n            stack.push(node);\n            node = node.left as N;\n        } else {\n            node = stack.pop();\n            // 提供退出遍历能力\n            if (isFalse(handler(node as N))) {\n                break;\n            }\n            node = node.right as N;\n        }\n    }\n}\n```\n\n"},{"title":"平衡二叉树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/is-balanced.html","content":"# 平衡二叉树\n\n[leetcode - 110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n## 题目\n输入一棵二叉树，判断该二叉树是否是平衡二叉树。\n\n平衡二叉树：*一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。*\n\n## 思路\n判断当前节点的左右子树深度插值的绝对值是否是小于等于1的，且此节点的左右子树是否都是平衡的。\n\n## 代码\n\n### Johninch\n```js\nconst isBalanced = function(root) {\n    const Depth = (root) => {\n        return !root ? 0 : Math.max(Depth(root.left), Depth(root.right)) + 1\n    }\n\n    if (!root) {\n        return true\n    }\n\n    return (Math.abs(Depth(root.left) - Depth(root.right)) <= 1) && isBalanced(root.left) && isBalanced(root.right)\n};\n```\n\n### niannings\n```ts\nfunction isBalanced(tree: IBinaryTreeBase) {\n    return maxDepth(tree) - minDepth(tree) <= 1;\n}\n```\n"},{"title":"对称的二叉树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/is-symmetrical.html","content":"# 对称的二叉树\n\n[leetcode - 101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n[leetcode - 100. 相同的树](https://leetcode-cn.com/problems/same-tree/)\n\n## 题目\n请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。\n\n## 思路\n二叉树的右子树是二叉树左子树的镜像二叉树。\n\n镜像二叉树：两颗二叉树根结点相同，但他们的左右两个子节点交换了位置。\n\n![](./images/is-symmetrical.png)\n如图，1为对称二叉树，2、3都不是。\n\n两个根结点相等\n左子树的右节点和右子树的左节点相同。\n右子树的左节点和左子树的右节点相同。\n递归所有节点满足以上条件即对称二叉树。\n\n## 代码\n\n### Johninch\n```js\nconst isSymmetric = (root) => {\n    if (!root) {\n        return true;\n    }\n    let walk = (left, right) => {\n        if (!left && !right) {\n            return true;\n        }\n\n        if (!left || !right) {\n            return false;\n        }\n\n        if (left.val !== right.val) {\n            return false;\n        }\n\n        return walk(left.left, right.right) && walk(left.right, right.left); // 注意，这里是镜像比较的递归，与isSameTree不同\n    }\n\n    return walk(root.left, root.right)\n}\n```\n顺便提下，上面的walk，其实就是「判断两颗树是否是相同的树」的变体：\n```js\nconst isSameTree = (left, right) => {\n    if (!left && !right) {\n        return true;\n    }\n\n    if (!left || !right) {\n        return false;\n    }\n\n    if (left.val !== right.val) {\n        return false;\n    }\n\n    return isSameTree(left.left, right.left) && isSameTree(left.right, right.right); // 注意这里的递归就是对应位置的比较\n}\n```\n\n### niannings\n```ts\nfunction isSymmetric(tree: IBinaryTree) {\n    if (tree.isEmpty()) return true; // 空树\n    const L = [tree.root.left];\n    const R = [tree.root.right];\n    while (L.length) {\n        const l = L.shift();\n        const r = R.shift();\n        if (l === null && r === null) break; // 只有根节点\n        if (l === null || r === null || l.value !== r.value) return false; // 一方不平或值不等\n        L.push(l.left, r.left);\n        R.push(r.right, l.right);\n    }\n    return true;\n}\n```\n"},{"title":"验证二叉搜索树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/isValidBST.html","content":"# 验证二叉搜索树\n\n[leetcode - 98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n## 题目\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n    - 节点的左子树只包含小于当前节点的数。\n    - 节点的右子树只包含大于当前节点的数。\n    - 所有左子树和右子树自身必须也是二叉搜索树。\n\n## 代码\n\n### Johninch\n需要在遍历树的同时，保留节点的上界与下界，在比较时不仅比较子节点的值，也要与上下界比较。\n```js\n// 递归法实现\nconst isValidBST = (node) => {\n    let walk = (node, lower, upper) => {\n        if (!node) return true\n\n        let val = node.val\n        if (lower !== null && val <= lower) return false\n        if (upper !== null && val >= upper) return false\n\n        if (!walk(node.right, val, upper)) return false\n        if (!walk(node.left, lower, val)) return false\n\n        return true\n    }\n\n    return walk(node, null, null)\n}\n```\n\n\n"},{"title":"二叉搜索树的第k个节点","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/kth-node.html","content":"\n# 二叉搜索树的第k个节点\n\n[leetcode - 230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n## 题目\n给定一棵二叉搜索树，请找出其中的第k小的结点。 例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。\n\n## 思路\n本题考查BST的特性：`BST 的中序遍历是升序序列`。所以本题实际考察二叉树的遍历。\n\n## 代码\n\n### Johninch\n```js\n// 利用BST的中序遍历是升序\nconst kthSmallest = (root, k) => {\n    const res = []\n    const stack = []\n    let current = root\n\n    while(current || stack.length > 0) {\n        while(current) {\n            stack.push(current)\n            current = current.left\n        }\n        current = stack.pop()\n        res.push(current.val)\n\n        current = current.right\n    }\n\n    return res[k - 1]\n}\n```\n\n### niannings\n```ts\n// 中序遍历的第k个\nexport function findKmin<N extends IBinarySearchTreeNode = IBinarySearchTreeNode>(\n    tree: IBinarySearchTree,\n    k: number\n) {\n    if (tree.isEmpty()) return null; // 空树\n    if (k <= 0) return null;\n    let i = 1;\n    let target = null;\n    middleEach<IBinarySearchTreeNode>(tree.root, (node) => {\n        if (i++ === k) {\n            target = node;\n            return false;\n        }\n    });\n    return target as N;\n}\n```\n"},{"title":"二叉树的层序遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/levelOrder-traversal.html","content":"# 二叉树的层序遍历\n\n[leetcode - 102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)\n\n## 题目\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n\n#### 示例：\n二叉树：[3,9,20,null,null,15,7],\n```\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n```\n返回其层次遍历结果：\n```\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n请分别以 `递归`、`非递归` 方法实现？\n\n## 代码\n\n### Johninch\nBFS：\n\n1. 递归（增加层级参数）：\n```js\nvar levelOrder = function(root) {\n    if (!root) return []\n\n    let res = []\n    let walk = (res, root, level) => {\n        if (!root) return\n\n        res[level] ? res[level].push(root.val) : res[level] = [root.val]\n        walk(res, root.left, level + 1)\n        walk(res, root.right, level + 1)\n    }\n\n    walk(res, root, 0)\n\n    return res\n};\n```\n2. 迭代（增加层级参数）：\n```js\nconst levelOrder = function(root) {\n    if (!root) return []\n\n    let res = []\n        queue = [[root, 0]]\n    while (queue.length) {\n        let [cur, level] = queue.shift()\n        res[level] ? res[level].push(cur.val) : res[level] = [cur.val]\n\n        if (cur.left) queue.push([cur.left, level + 1])\n        if (cur.right) queue.push([cur.right, level + 1])\n    }\n\n    return res\n}\n```\n\n3. 非递归（迭代）：\n    - 使用队列存放每一层的节点\n    - 外循环负责遍历层级结构, 内循环负责遍历每一层的子节点\n    - 在内循环中记录当前值, 并且把子节点添加到temp中\n    - 当本层遍历完时，退到外循环，并把temp下一层的节点, 再赋给queue, 直到queue为空则表示全部遍历完毕\n```js\nconst levelOrder = root => {\n    if (!root) return []\n\n    let res = [],\n        queue = [root]\n    while (queue.length) { // 外循环遍历层级\n        let arr = [],\n            temp = []\n        while (queue.length) { // 内循环遍历每一层的子节点\n            let cur = queue.shift()\n            arr.push(cur.val)\n\n            if (cur.left) temp.push(cur.left)\n            if (cur.right) temp.push(cur.right)\n        }\n        queue = temp\n        res.push(arr)\n    }\n    return res\n}\n```\n"},{"title":"二叉树的最大深度","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/max-depth.html","content":"# 二叉树的最大深度\n\n[leetcode - 104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n## 题目\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n#### 示例\n```\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n```\n\n## 思路\n深度优先遍历 + 分治：一棵二叉树的最大深度等于左子树深度和右子树最大深度的最大值` + 1`\n\n## 代码\n\n### Johninch\n二叉树的深度就是指其最大深度。\n```js\nconst maxDepth = (root) => {\n    if (!root) {\n        return 0\n    }\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1 // 要加1\n}\n```\n\n顺便提下求二叉树节点个数：\n```js\nconst sizeOfTree = (root) => {\n    if (!root) {\n        return 0\n    }\n\n    return 1 + sizeOfTree(root.left) + sizeOfTree(root.right);\n}\n```\n\n### niannings\n```ts\nfunction maxDepth(tree: IBinaryTreeBase) {\n    if (tree.isEmpty()) return 0; // 空树\n    const Q: [IBinaryTreeNodeBase, number][] = [[tree.root, 1]];\n    let h = 0;\n    while (Q.length) {\n        const p = Q.pop();\n        const n = p[1];\n        const l = p[0].left;\n        const r = p[0].right;\n        h = Math.max(p[1], h);\n        if (l !== null) Q.push([l, n + 1]);\n        if (r !== null) Q.push([r, n + 1]);\n    }\n    return h;\n}\n```\n"},{"title":"二叉树的最小深度","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/min-depth.html","content":"# 二叉树的最小深度\n\n[leetcode - 111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)\n\n## 题目\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明: 叶子节点是指没有子节点的节点。\n\n#### 示例\n```\n给定二叉树 [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最小深度 2\n```\n\n## 思路\n深度优先 + 分治\n- 左树为空：右子树最小深度的最小值 + 1\n- 右树为空：左子树最小深度 + 1\n- 左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1\n\n## 代码\n\n### Johninch\n```js\nconst minDepth = (root) => {\n    if (!root) {\n        return 0;\n    }\n    if (!root.left) {\n        return 1 + minDepth(root.right);\n    }\n    if (!root.right) {\n        return 1 + minDepth(root.left);\n    }\n    return Math.min(minDepth(root.left), minDepth(root.right)) + 1\n};\n```\n\n### niannings\n```ts\nfunction minDepth(tree: IBinaryTreeBase) {\n    if (tree.isEmpty()) return 0; // 空树\n    const Q: [IBinaryTreeNodeBase, number][] = [[tree.root, 1]];\n    let h = 0;\n    while (Q.length) {\n        const p = Q.shift();\n        const n = p[1];\n        const l = p[0].left;\n        const r = p[0].right;\n        h = Math.max(p[1], h);\n        if (l === null || r === null) break;\n        Q.push([l, n + 1]);\n        Q.push([r, n + 1]);\n    }\n    return h;\n}\n```\n"},{"title":"二叉树的镜像（翻转二叉树）","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/mirror.html","content":"# 二叉树的镜像（翻转二叉树）\n\n[leetcode - 226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)\n\n## 题目\n操作给定的二叉树，将其变换为源二叉树的镜像。\n```\n       源二叉树 \n    \t    8\n    \t   /  \\\n    \t  6   10\n    \t / \\  / \\\n    \t5  7 9 11\n    \t镜像二叉树\n    \t    8\n    \t   /  \\\n    \t  10   6\n    \t / \\  / \\\n    \t11 9 7  5\n```\n## 思路\n递归交换二叉树所有节点左右节点的位置。\n\n## 代码\n\n### Johninch\n```js\nvar invertTree = function(root) {\n    if (!root) {\n        return null\n\t}\n\t\n\t[root.left, root.right] = [invertTree(root.right), invertTree(root.left)]\n\n\treturn root\n};\n```\n\n### niannings\n```ts\nfunction toImage(tree: IBinaryTreeBase) {\n    if (tree.isEmpty()) return tree; // 空树\n    const Q = [tree.root];\n    while (Q.length) {\n        const p = Q.shift();\n        const l = p.left;\n        const r = p.right;\n        if (l === null && r === null) break; // 只有根节点\n        p.left = r;\n        p.right = l;\n        if (l !== null) Q.push(l);\n        if (r !== null) Q.push(r);\n    }\n    return tree;\n}\n```\n"},{"title":"二叉树的后序遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/postorder-traversal.html","content":"# 二叉树的后序遍历\n\n## 题目\n给定一个二叉树，返回它的 `后序` 遍历。\n\n#### 示例\n```js\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n输出: [3,2,1]\n```\n请分别以 `递归`、`非递归` 方法实现？\n\n## 代码\n\n### Johninch\n\n本部分是三序遍历的实现，主要分为两类：递归和迭代。\n\n三序遍历的递归方式非常简单，而对应的迭代法，本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。\n\n*其实三序遍历都有一种莫里斯遍历解法，但这种方法会破坏原树结构，且不易理解，感兴趣的话去leetcode研究下。*\n\n#### 后序遍历 - 递归\n```js\nconst postorder = (root, arr = []) => {\n    if (root) {\n        postorder(root.left, arr)\n        postorder(root.right, arr)\n        arr.push(root.val)\n    }\n\n    return arr\n}\n```\n#### 后序遍历 - 迭代 - 栈遍历 (后续是对前序的修改)\n后序迭代的方法都是以前序迭代修改而来的：\n\n- 第一种写法就是采用 根右左 的遍历方法，最后再将结果翻转\n```js\nconst postorderTraversal = (root) => {\n    const res = [];\n    const stack = [];\n    let current = root;\n\n    while (current || stack.length > 0) {\n        while (current) {\n            res.push(current.val);\n            stack.push(current);\n            current = current.right; // 相比前序遍历，修改，先遍历右子树\n        }\n\n        current = stack.pop();\n\n        current = current.left; // 相比前序遍历，修改，后遍历左子树\n    }\n    return res.reverse(); // 因为是 根右左，所以需要翻转成 左右根\n}\n```\n\n- 第二种写法是建立一个指向前一节点的指针，标记右孩子是否被访问\n```js\nconst postorderTraversal = (root) => {\n    const res = [];\n    const stack = [];\n    let current = root;\n\n    let last = null; // 修改1，指针，标记上一个访问的节点\n\n    while (current || stack.length > 0) {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack[stack.length - 1];\n        if (!current.right || current.right == last) { // 修改二，增加判断是否该输出结点\n            current = stack.pop();\n            res.push(current.val); // 前序入栈就输出，中序出栈再输出，后续是对前序的修改\n            last = current;\n            current = null; // 继续弹栈\n        } else {\n            current = current.right;\n        }\n    }\n    return res;\n}\n```\n\n## niannings\n```ts\n/**\n * 后续遍历算法：\n * 1. 初始化两个栈s1，s2\n * 2. 将root放入s1\n * 3. s1弹出一个node，把node压入s2，把node的左右子节点压入s1\n * 4. 重复步骤2、3直到s1被清空\n * 5. 这样s2中的序列就是按照后续遍历的顺序排列的了，直接pop直到s2清空\n * @param handler 处理节点\n */\nexport function backEach<N extends IBinaryTreeNodeBase = IBinaryTreeNodeBase>(\n    root: N,\n    handler: (node: N) => void\n) {\n    if (root === null) return;\n    const [s1, s2] = [[root], []];\n    while (s1.length) {\n        const node = s1.pop();\n        s2.push(node);\n        if (node.left) {\n            s1.push(node.left as N);\n        }\n        if (node.right) {\n            s1.push(node.right as N);\n        }\n    }\n    while (s2.length) {\n        handler(s2.pop());\n    }\n}\n```\n\n"},{"title":"二叉树的前序遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/preorder-traversal.html","content":"# 二叉树的前序遍历\n\n## 题目\n给定一个二叉树，返回它的 `前序` 遍历。\n\n#### 示例\n```js\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n输出: [1,2,3]\n```\n请分别以 `递归`、`非递归` 方法实现？\n\n## 代码\n\n### Johninch\n\n本部分是三序遍历的实现，主要分为两类：递归和迭代。\n\n三序遍历的递归方式非常简单，而对应的迭代法，本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。\n\n*其实三序遍历都有一种莫里斯遍历解法，但这种方法会破坏原树结构，且不易理解，感兴趣的话去leetcode研究下。*\n\n#### 前序遍历 - 递归\n```js\nconst preorder = (root, arr = []) => {\n    if (root) {\n        arr.push(root.val)\n        preorder(root.left, arr)\n        preorder(root.right, arr)\n    }\n\n    return arr\n}\n```\n#### 前序遍历 - 迭代 - 栈遍历 (前序入栈就输出)\n1. 每拿到一个 节点 就把它 [压栈](保存在栈中)；\n2. 继续对这个节点的 左子树 重复 过程1，直到左子树为 空；\n3. 因为保存在 栈 中的节点都遍历了 左子树 但是没有遍历 右子树，所以对栈中节点 [出栈] 并对它的 右子树 重复 过程1\n4. 直到遍历完所有节点\n```js\nconst preorderTraversal = (root) => {\n    const res = [];\n    const stack = [];\n    let current = root;\n\n    while (current || stack.length > 0) {\n        while (current) {\n            res.push(current.val); // 前序入栈就输出，中序出栈再输出，后续是对前序的修改\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack.pop();\n\n        current = current.right;\n    }\n    return res;\n};\n```\n\n### niannings\n```ts\n/**\n * 前序遍历算法：\n * 1. 初始化一个栈stack，并将根节点压入；\n * 2. 从stack中弹出一个node，**访问**它，并将node的右、左子节点依次压入stack（如果有的话）；\n * 3. 重复步骤2，直到stack清空；\n * @param handler 处理函数\n */\nexport function frontEach<N extends IBinaryTreeNodeBase = IBinaryTreeNodeBase>(\n    root: N,\n    handler: (node: N) => void\n) {\n    if (root === null) return;\n    const stack = [root];\n    while (stack.length) {\n        const node = stack.pop();\n        handler(node);\n        if (node.right) {\n            stack.push(node.right as N);\n        }\n        if (node.left) {\n            stack.push(node.left as N);\n        }\n    }\n}\n```\n"},{"title":"重建二叉树","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/reconstruct-binary-tree.html","content":"# 重建二叉树\n\n[leetcode - 105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n## 题目\n输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n## 思路\n- 前序遍历：根-左-右\n- 中序遍历：左-根-右\n\n因此\n- 对于preorder，每个首元素即为一个子树的根元素\n- 对于inorder，查找preorder中的根元素\n    - 左边为preorder当前根元素的左子树\n    - 右边为preorder当前根元素的右子树\n\n据此 递归 构造出一颗二叉树即可：\n    - 终止条件: 前序和中序数组为空\n    - 通过前序数组第一个元素找到根节点root，找到root在中序遍历的位置，再将前序数组和中序数组分成两半，递归的处理前序数组左边和中序数组左边，递归的处理前序数组右边和中序数组右边。\n\n## 代码\n\n### Johninch\n```js\nfunction Node(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n\nfunction reConstruct(preorder, inorder) {\n    if(preorder.length === 0){\n        return null;\n    }\n    if(preorder.length === 1){\n        return new Node(preorder[0]);\n    }\n    const value = preorder[0];\n    const root = new Node(value);\n    const index = inorder.indexOf(value);\n\n    // slice 包含从 start 到 end（不包括该元素）\n    const inLeft = inorder.slice(0, index);\n    const inRight = inorder.slice(index + 1); // 去掉根\n    const preLeft = preorder.slice(1, index + 1); // 去掉根\n    const preRight = preorder.slice(index + 1);\n\n    root.left = reConstruct(preLeft, inLeft);\n    root.right = reConstruct(preRight, inRight);\n\n    return root;\n}\n```\n\n### niannings\n```ts\nexport function rebuildTree(frontEachList: any[], middleEachList: any[]) {\n    const tree = new BinaryTree();\n    if (frontEachList.length === 0) return tree;\n    tree.root = rebuild(frontEachList, middleEachList);\n\n    function rebuild(f: any[], m: any[]) {\n        const v = f[0];\n        const newNode = new BinaryTreeNode(v);\n        const sliceIndex = m.indexOf(v);\n        const l = f.slice(1, sliceIndex + 1);\n        const r = f.slice(sliceIndex + 1);\n        if (l.length) {\n            newNode.left = rebuild(l, m.slice(0, sliceIndex));\n        }\n        if (r.length) {\n            newNode.right = rebuild(r, m.slice(sliceIndex + 1));\n        }\n        return newNode;\n    }\n    return tree;\n}\n```\n"},{"title":"二叉树的后续遍历","url":"/Roundtables/Algorithm/Tree-and-Binary-Tree/verify-squence-of-BST.html","content":"# 二叉树的后续遍历\n\n[leetcode - 面试题33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)\n\n## 题目\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。\n\n## 思路\n1. 后序遍历：分成三部分，最后一个节点为根节点。BST的特性是左子树的值比根节点都小，右子树的值比根节点都大。\n2. 先划分左右子树，左侧比根节点小的值都判定为左子树。\n3. 除最后一个节点外和左子树外的其他值为右子树，`判断右子树中是否有一个比根节点小，如果有则返回false`。\n4. 若不存在，则递归检测左、右子树是否复合规范。\n\n## 代码\n\n### Johninch\n```js\nconst verifyPostorder = (postorder) => {\n    const len = postorder.length\n    if (len < 2) {\n        return true\n    }\n\n    const root = postorder[len -1];\n    const index = postorder.findIndex(item => item > root)\n\n    const leftTree = postorder.slice(0, index)\n    const rightTree = postorder.slice(index, len - 1)\n\n    const res = rightTree.some(item => item < root)\n\n    return res ? false : verifyPostorder(leftTree) && verifyPostorder(rightTree)\n}\n```\n\n"},{"title":"heading-11)","url":"/Roundtables/Lets-Read/index.html","content":"\n\n- [️react-router彻底弄懂前端路由](./one/read-1-1)\n- [️CSS 变量教程](./one/read-2-1)\n- [前端高性能渲染十万条数据](./one/read-3-1)\n- [diff 算法](./one/read-3-2)\n- [️函数组合](./one/read-4-1)\n- [async/await 原理及执行顺序分析](https://juejin.im/post/5dc28ea66fb9a04a881d1ac0)\n- [从多线程到Event Loop全面梳理](https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-11)\n"},{"title":"什么是前端路由","url":"/Roundtables/Lets-Read/one/read-1-1.html","content":"---\n{\n    \"title\": \"react-router彻底弄懂前端路由\",\n}\n---\n### 什么是前端路由\n\n简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。\n\n为实现这一目标，我们需要做到以下二点：\n\n1. 改变 url 且不让浏览器像服务器发送请求；\n\n2. 可以监听到 url 的变化\n\n目前有两种模式，分别是 **hash 模式和 history 模式**\n\n\n### hash模式\n\n这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 \"www.baidu.com/#hashhash\" ，其中 \"#hashhash\" 就是我们期望的 hash 值。\n\n由于 hash 值的变化 `不会导致浏览器像服务器发送请求`, 而且 hash 的改变会触发 `hashchange `事件，浏览器的前进后退也能对其进行控制，所以在 H5 的 history 模式出现之前，基本都是使用 hash 模式来实现前端路由。\n\n- ***手动实现hash路由***\n\n```js\nclass HashRouter {\n    constructor(){\n        // 初始化路由\n        this.routers = {};\n        // 绑定hash监听事件\n        window.addEventListener('hashchange', () => {\n            this.load()\n        })\n    }\n    // 注册路由\n    register = (hash, cb) => {\n        this.routers[hash] = cb;\n    }\n    // 注册首页路由\n    registerIndex = (cb) => {\n        this.routers['index'] = cb;\n    }\n    load = () => {\n        let hash = location.hash.slice(1);\n        let handle;\n        if (!hash) {  // 说明是主页\n            handle = this.routers.index;\n        } else {\n            handle = this.routers[hash];\n        }\n        handle();\n    }\n  \n}\n```\n```html\n<body>\n    <div id=\"nav\">\n        <a href=\"#/page1\">page1</a>\n        <a href=\"#/page2\">page2</a>\n        <a href=\"#/page3\">page3</a>\n        <a href=\"#/page4\">page4</a>\n        <a href=\"#/page5\">page5</a>\n    </div>\n    <div id=\"container\"></div>\n</body>\n```\n**使用**\n```js\nlet router = new HashRouter();\nlet container = document.getElementById('container');\n\n//注册首页回调函数\nrouter.registerIndex(()=> container.innerHTML = '我是首页');\n\n//注册其他视图回到函数\nrouter.register('/page1',()=> container.innerHTML = '我是page1');\nrouter.register('/page2',()=> container.innerHTML = '我是page2');\nrouter.register('/page3',()=> container.innerHTML = '我是page3');\n\n// 加载页面\nrouter.load();\n```\n\n### hash模式\n\n在 HTML5 的规范中，history 新增了以下几个 API：\n\n```js\nhistory.pushState();         // 添加新的状态到历史状态栈\nhistory.replaceState();      // 用新的状态代替当前状态\nhistory.state                // 返回当前状态对象\n```\n由于 history.pushState() 和 history.replaceState() 可以改变 url 同时，不会刷新页面，所以在 HTML5 中的 histroy 具备了实现前端路由的能力\n\n- hash 路由通过监听haschange事件进行跳转路由的。\n- history的改变并不会触发任何事件，所以我们无法直接监听 history 的改变而做出相应的改变.。\n\n所以我们换个思路，将这些方式进行拦截，变相的监听history的变化。\n\n>1. 点击浏览器的前进或后退按钮\n>2. 点击a标签\n>3. 在 JS 代码中触发 history.pushState 函数\n>4. 在 JS 代码中触发 history.replaceState 函数\n\n\n- ***手动实现history路由***\n```js\nclass HistoryRouter {\n    constructor(){\n        this.routers = {};\n        this.listenPopState();\n        this.listenLink();\n    }\n    \n    // 全局监听a标签\n    listenLink = () => {\n        window.addEventListener('click', (e) => {\n            let target = e.target;\n            if (target.tagName.toUpperCase() === 'A' && target.getAttribute('href')) {\n                e.preventDefault();  // 组织默认行为\n                this.assign(target.getAttribute('href'));\n            }\n        })\n    }\n    \n    //用于首次进入页面时调用\n    load(){\n        let path = location.pathname;\n        this.dealPathHandler(path)\n    }\n    \n    //用于注册每个视图\n    register(path,callback = function(){}){\n        this.routers[path] = callback;\n    }\n    //用于注册首页\n    registerIndex(callback = function(){}){\n        this.routers['/'] = callback;\n    }\n    //用于处理视图未找到的情况\n    registerNotFound(callback = function(){}){\n        this.routers['404'] = callback;\n    }\n    \n    // 跳转到path\n    assign = (path) => {\n        history.pushState({path}, null, path);\n        this.dealPathHandler(path);\n    }\n    \n     //替换为path\n    replace(path){\n        history.replaceState({path},null,path);\n        this.dealPathHandler(path)\n    }\n    \n    //监听popstate\n    listenPopState = () => {\n        window.addEventListener('popstate', (e) => {\n            let state = e.state || {};\n            let path = state.path || '';\n            this.dealPathHandler(path);\n        })\n    }\n    \n    // 处理path跳转页面\n    dealPathHandler = (path) => {\n        let handle;\n        if (!this.routers[path]) {  // 没有对应path\n            handle = this.routers['404'] || function() {};\n        } else {\n            // 对应path\n            handle = this.routers[path]\n        }\n        handle.call(this);\n    }\n}\n```\n\n**使用**\n```html\n<body>\n    <div id=\"nav\">\n        <a href=\"/page1\">page1</a>\n        <a href=\"/page2\">page2</a>\n        <a href=\"/page3\">page3</a>\n        <a href=\"/page4\">page4</a>\n        <a href=\"/page5\">page5</a>\n        <button id=\"btn\">page2</button>\n    </div>\n    <div id=\"container\">\n    </div>\n</body>\n```\n```js\nlet router = new HistoryRouter();\nlet container = document.getElementById('container');\n\n//注册首页回调函数\nrouter.registerIndex(() => container.innerHTML = '我是首页');\n\n//注册其他视图回到函数\nrouter.register('/page1', () => container.innerHTML = '我是page1');\nrouter.register('/page2', () => container.innerHTML = '我是page2');\nrouter.register('/page3', () => container.innerHTML = '我是page3');\nrouter.register('/page4', () => {\n    throw new Error('抛出一个异常')\n});\n\ndocument.getElementById('btn').onclick = () => router.assign('/page2')\n\n\n//注册未找到对应path值时的回调\nrouter.registerNotFound(() => container.innerHTML = '页面未找到');\n//注册出现异常时的回调\nrouter.registerError((e) => container.innerHTML = '页面异常，错误消息：<br>' + e.message);\n//加载页面\nrouter.load();\n```\n\n### hash、history如何抉择\nhash 模式相比于 history 模式的优点：\n- 兼容性更好，可以兼容到IE8\n- 无需服务端配合处理非单页的url地址\n\nhash 模式相比于 history 模式的缺点：\n- 看起来更丑\n- 会导致锚点功能失效\n- 相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以\n\n\n参考链接：[彻底弄懂前端路由](https://juejin.im/post/5d2d19ccf265da1b7f29b05f)\n"},{"title":"变量的声明","url":"/Roundtables/Lets-Read/one/read-2-1.html","content":"---\n{\n    \"title\": \"CSS 变量教程\",\n}\n---\n### 变量的声明\n\n```css\n:root {\n  --w: 100px; /* 全局变量 */\n}\n```\n\n#### 变量作用域\n> 同一个 CSS 变量，可以在多个选择器内声明。读取的时候，**优先级**最高的声明生效。这与 CSS 的**\"层叠\"**（cascade）规则是一致的。\n\n上面提到了全局变量。\n```css\n.container {\n  --h: 10px;\n  /* 局部变量\n      只作用于拥有 .container类名的节点，\n      以及该节点下的所有后辈节点。\n  */\n}\n```\n\n### var() 函数\n\n- 它用于读取变量\n- 可接受两个参数，第一个参数是作用域内的变量，第二个参数（可选）是第一个参数的默认值。\n- 变量值只能作为属性值。\n\n### 变量值的类型\n- 类型\n  - 字符串（'hello world'）不能是带单位带数字。\n  - 数字。\n  - 带单位的数字（1px, 30deg, ...）。\n- 运算规则\n  - 字符串可以拼接。\n  - 数字运算只能用```calc```。\n\n### 响应式布局\n变量可用于@media媒体查询。\n\n### 与sass、less区别\n变量是动态的，sass、less是静态的，他们没法做到更新变量就刷新布局达到响应式的效果\n\n### JavaScript 操作\n- 可以通过改变css变量实现动画、主题等；例如[ani-css首页的robot](https://esop-fed.github.io/ani-css)\n### 其他优秀文章\n[小tips:了解CSS/CSS3原生变量var](https://www.zhangxinxu.com/wordpress/2016/11/css-css3-variables-var/)\n\n参考链接：[css变量教程](https://www.ruanyifeng.com/blog/2017/05/css-variables.html)"},{"title":"暴力渲染","url":"/Roundtables/Lets-Read/one/read-3-1.html","content":"---\n{\n    \"title\": \"前端高性能渲染十万条数据\",\n}\n---\n> 本文探讨：当遇到大量数据时，如何才能在不卡主页面的情况下渲染数据，以及其背后的原理。以下比较了4种不同的方式：\n1. 暴力渲染\n2. setTimeout\n3. requestAnimationFrame\n4. DocumentFragment \n\n### 暴力渲染\n```\n// 记录任务开始时间\nlet now = Date.now();\n// 插入十万条数据\nconst total = 100000;\n// 获取容器\nlet ul = document.getElementById('container');\n// 将数据插入容器中\nfor (let i = 0; i < total; i++) {\n    let li = document.createElement('li');\n    li.innerText = ~~(Math.random() * total)  // ~~\n    ul.appendChild(li);\n}\n\nconsole.log('JS运行时间：',Date.now() - now);\nsetTimeout(()=>{\n  console.log('总运行时间：',Date.now() - now);\n},0)\n// print: JS运行时间： 187ms\n// print: 总运行时间： 2844ms\n```\n\n> 简单说明一下，为何两次console.log的结果时间差异巨大，并且是如何简单来统计JS运行时间和总渲染时间：\n\n> 在 JS 的Event Loop中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染\n - 第一个console.log的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间\n - 第二个console.log是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次Event Loop中执行的\n\n**结果：页面卡顿，是由于同时渲染大量DOM所引起的，所以下面考虑将渲染过程分批进行：**\n\n### setTimeout\n```\n//需要插入的容器\nlet ul = document.getElementById('container');\n// 插入十万条数据\nlet total = 100000;\n// 一次插入 20 条\nlet once = 20;\n//总页数\nlet page = total/once\n//每条记录的索引\nlet index = 0;\n//循环加载数据\nfunction loop(curTotal,curIndex){\n    if(curTotal <= 0){\n        return false;\n    }\n    //每页多少条\n    let pageCount = Math.min(curTotal , once);\n    setTimeout(()=>{\n        for(let i = 0; i < pageCount; i++){\n            let li = document.createElement('li');\n            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)\n            ul.appendChild(li)\n        }\n        loop(curTotal - pageCount,curIndex + pageCount)\n    },0)\n}\nloop(total,index);\n```\n**导致结果：渲染加快但是有白屏或闪屏现象**\n\n##### 闪屏原因\n> - **FPS**：表示的是每秒钟画面更新次数，是描述帧变化速度的物理量。\n- **FPS为60frame/s**：大多显示器会以每秒60次的频率，不断的更新屏幕上的图像。\n- **16.7ms**：根据视觉暂留现象，最平滑动画的最佳循环间隔是1000ms/60，约等于16.7ms。\n\n##### setTimeout与闪屏的关系 -> 刷新步调可能会 不一致\n> - setTimeout的执行时间并不是确定的。实际执行时间可能会比其设定的时间晚一些。\n- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。\n\n以上两种情况都会导致setTimeout的执行步调和屏幕的**刷新步调不一致**。\n在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就**可能导致中间某一帧的操作被跨越过去**，而直接更新下一帧的元素，从而**导致丢帧现象**。\n\n\n### requestAnimationFrame（不会产生丢帧现象）\nrequestAnimationFrame是系统来决定回调函数的执行时机。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象。\n\n```\n//需要插入的容器\nlet ul = document.getElementById('container');\n// 插入十万条数据\nlet total = 100000;\n// 一次插入 20 条\nlet once = 20;\n//总页数\nlet page = total/once\n//每条记录的索引\nlet index = 0;\n//循环加载数据\nfunction loop(curTotal,curIndex){\n    if(curTotal <= 0){\n        return false;\n    }\n    //每页多少条\n    let pageCount = Math.min(curTotal , once);\n    window.requestAnimationFrame(function(){\n        for(let i = 0; i < pageCount; i++){\n            let li = document.createElement('li');\n            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)\n            ul.appendChild(li)\n        }\n        loop(curTotal - pageCount,curIndex + pageCount)\n    })\n}\nloop(total,index);\n\n```\n**结果：很流畅，没有出现闪烁丢帧的现象，但还能再优化**\n\n\n### 使用 DocumentFragment\n> - DocumentFragment，文档片段接口，它被作为一个轻量版的 Document 使用。DocumentFragments是DOM节点，但并不是\tDOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。可以用于避免回流操作。\n- 可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment.\n\n```\n//需要插入的容器\nlet ul = document.getElementById('container');\n// 插入十万条数据\nlet total = 100000;\n// 一次插入 20 条\nlet once = 20;\n//总页数\nlet page = total/once\n//每条记录的索引\nlet index = 0;\n//循环加载数据\nfunction loop(curTotal,curIndex){\n    if(curTotal <= 0){\n        return false;\n    }\n    //每页多少条\n    let pageCount = Math.min(curTotal , once);\n    window.requestAnimationFrame(function(){\n        let fragment = document.createDocumentFragment();\n        for(let i = 0; i < pageCount; i++){\n            let li = document.createElement('li');\n            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)\n            fragment.appendChild(li)\n        }\n        ul.appendChild(fragment)\n        loop(curTotal - pageCount,curIndex + pageCount)\n    })\n}\nloop(total,index);\n```\n\n### 使用 display\n可以先将元素脱离文档流、对其修改、在带回文档流，比如 display:none，添加修改完最后 在display: block\n\n参考链接：[高性能渲染十万条数据](https://juejin.im/post/5d76f469f265da039a28aff7)\n"},{"title":"1.传统的diff算法为何是n","url":"/Roundtables/Lets-Read/one/read-3-2.html","content":"---\n{\n    \"title\": \"diff 算法\",\n}\n---\n### 1.传统的diff算法为何是n^3\n有新旧两个节点beforeNode, afterNode\n+ 取新旧两个节点的最大长度来遍历对比(**for循环n^2**)\n```javascript\nlet result = []; // 记录节点需要进行的操作\nconst diffNodes = function (beforeNode, afterNode) {\n    // 获取较大节点树的长度\n    let count = Math.max(beforeNode.children.length, afterNode.children.length);\n    // 循环遍历进行新旧每个节点的对比(n^2)\n    for (let i = 0; i < count; i++) {\n        const beforeTag = beforeLeaf.children[i];\n        const afterTag = afterLeaf.children[i];\n         ...\n    }\n    return result;\n}\n```\n- 分析情况做出相应操作\n1. 第一种情况\n```javascript\nif (beforeNode === undefined) {\n      result.push({ type: \"add\", el: afterTag }); // 旧的位置没有\n}\n```\n2. 第二种情况\n```javascript\nif (afterNode === undefined) {\n      result.push({ type: \"remove\", el: beforeTag }); // 旧的位置没有\n}\n```\n3. 第三种情况\n```javascript\nif (beforeTag.tagName !== afterTag.tagName) {\n      // 节点名改变时，删除 beforeTag 节点，添加 afterTag 节点\n      result.push({ type: \"remove\", element: beforeTag });\n      result.push({ type: \"add\", element: afterTag });\n}\n```\n4. 第四种情况\n```javascript\nelse if (beforeTag.innerHTML !== afterTag.innerHTML) {\n      if (beforeTag.children.length === 0) {\n          result.push({\n              type: \"changed\",\n              beforeElement: beforeTag,\n              afterElement: afterTag,\n              html: afterTag.innerHTML\n          });\n      } else {\n          // 递归比较\n          diffNodes(beforeTag, afterTag);\n      }\n}\n```\n+ 进行最后的最小操作数计算(**此时操作上升为n^3**)，我们大致简单理解一下，真实算法有兴趣可以自行查询[Trees Edit Distance](http://vldb.org/pvldb/vol5/p334_mateuszpawlik_vldb2012.pdf)\n>[掘金react的diff 从O(n^3)到 O(n) ](https://www.zhihu.com/question/66851503/answer/246766239)\n\n    最小操作就是计算更新为新的dom时所需要的最少步骤\n```\nPrev                               Last\n          div                             div \n         / \\                             / \\ \n       ul   p     ====>            p   p\n      /  \\                             |    \n    li   li                           text \n    |\n   text\n最优方式可以删除Prev的ul节点，再插入一个新的P节点，最后再p节点下插入text。总共三步。\n```  \n---\n\n### 2. 优化的diff算法n\n>[简书传统diff、react优化diff、vue优化diff](https://www.jianshu.com/p/398e63dc1969)  \n>[react的diff](https://blog.csdn.net/sexy_squirrel/article/details/79801940)\n>[vue的diff](https://www.cnblogs.com/wind-lanyan/p/9061684.html)\n\n**React & Vue**\n\n+ 两者都采用的是同级比较，且通过唯一的key值来比对。只需要对比同一key的dom，如果不同就不需要继续考虑子级别dom，所以复杂度为n。\n- React短板在于ABCD=>DABC, 遵从lastIndex比对原则，newIndex < lastIndex则移动，否则不变，ABC会分别移动到D的后面，而不是D移动 \n \n  到最前面，这就是性能浪费。\n\n   > 1> 当前lastIndex为0，newVNode第一个为D，即nextIndex = 0，找到D在oldVNode中索引为3，即prevIndex = 3，prevIndex > lastIndex 不移动, nextIndex++，lastIndex = Math.max(lastIndex, prevIndex) = 3  \n   2> nextIndex = 1, lastIndex为3，第二个为A，prevIndex = 0，prevIndex < lastIndex, 移动，nextIndex++, lastIndex = Math.max(3, 0) = 3  \n   3> ...如此循环，直到循环结束  \n   4> 判断oldVNode中并没有newVNode中没有的节点，不执行remove操作, 到此ABC都进行了dom操作\n\n+ Vue采用了新旧虚拟dom的首尾对比阶段。即先进行新旧两种dom首尾四种比对，如果满足就进行操作。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。\n    \n  1> 遍历生成虚拟dom\n  ```javascript\n    // body下的 <div id=\"v\" class=\"classA\"><div> 对应的 oldVnode 就是\n    {\n      el:  div  //对真实的节点的引用，本例中就是document.querySelector('#id.classA')\n      tagName: 'DIV',   //节点的标签\n      sel: 'div#v.classA'  //节点的选择器\n      data: null,       // 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style\n      children: [], //存储子节点的数组，每个子节点也是vnode结构\n      text: null,    //如果是文本节点，对应文本节点的textContent，否则为null\n    }\n    ```  \n  2> 首先进行patch方法比对新旧Vnode，执行sameVnode方法比较，也就是比较是不是同一类型且属性不变\n  3> sameVnode不通过就执行删除添加操作，通过执行patchVnode方法，oldVnode === vnode引用相同就视为不变，如果不同再比较text，text不同触发setTextContent 修改text，text相同只有oldVnode有子节点就执行remove操作，如果只有newVnode有子节点就执行add操作，都不满足就执行updateChildren方法，对子节点比对，这是核心diff\n  4> oldStart，oldEnd，newStart，newEnd首尾两两比较，当oldStartIdx > oldEndIdx && newStartIdx > newEndIdx时就中断比较。\n    \n    > vue diff ABCD => DBA 从两侧向中间比对\n    > 1.  oldStart = A, oldEnd = D, newStart = D, newEnd = A. oldStart匹配到newEnd，真实dom中A移动最后，\noldEnd匹配到newStart, 真实dom中D移动到最前面\n    > 2.  oldStart = B, oldEnd = C, newStart = B, newEnd = B, oldStart匹配到newStart，真实dom中B不变，\n    > 3.  newStartIdx++ 0->1->2，newEndIdx-- 为3->2->1, oldStartIdx++ 为0->1->2，oldEndIdx-- 为2->1->0，newStartInx > newEndIdx, 新的Vnode遍历结束，终止diff\n\n\n    \n- Vue在比对新旧节点时，如果两个节点是同一类型，但是仅仅只是属性发生变化，比如className，Vue会执行删除当前节点\n添加新的节点的操作，而React只会更新相关的属性\n    ```javascript\n  // vue\n  function sameVnode(oldVnode, vnode){\n    //两节点key值相同，并且sel属性值相同，即认为两节点属同一类型，可进行下一步比较\n    return vnode.key === oldVnode.key && vnode.sel === oldVnode.sel\n  }\n    ```\n\n**Key的重要性**  \n\n key是实现diff优化操作的关键，假如没有key。ABCD=>DCBA 过程中，如果简单判断A和D，B和C，C和B，D和A比对后，就会进行四次dom替换，如果彻底比对就需要n^3复杂度。如果有key，只需要进行同key值判断就可以了。\n\n---\nEnd\n\n参考链接：[传统diff、react优化diff、vue优化diff](https://www.jianshu.com/p/398e63dc1969)\n"},{"title":"函数组合包含在函数式编程范畴中，就是一种将已被分解的简单任务组合成复杂任务的过程","url":"/Roundtables/Lets-Read/one/read-4-1.html","content":"---\n{\n    \"title\": \"函数组合\",\n}\n---\n### 函数组合包含在函数式编程范畴中，就是一种将已被分解的简单任务组合成复杂任务的过程\n\n### ***什么是组合***\n```js\nfunction compose(f, g){\n    return function(x) {\n        return  f(g(x))\n    }\n}\n// compose(f,g)(x) === f(g(x))\n// compose(f,g,m)(x) === f(g(m(x)))\n// compose(f,g,m)(x) === f(g(m(x)))\n// compose(f,g,m,n)(x) === f(g(m(n(x))))\n//···\n\n```\n`compose`函数，接受若干个函数作为参数；每个函数执行后的输出作为下一个函数的输入；直到最后一个函数执行完毕\n\n### ***应用compose函数***\n\n假如一个需求，对一个字符串转换为 四舍五入 的数字。\n\n- **常规实现**：\n\n```js\nlet n = '3.56';\nlet data = parseFloat(n);\nlet result = Math.round(data); // =>4 最终结果\n```\n\n- **compose实现**：\n\n```js\nlet n = '3.56';\nlet number = compose(Math.round,parseFloat);\nlet result = number(n); // =>4 最终结果\n```\n>这个组合的过程就是函数式组合！我们将两个函数组合一起便能构造出新的函数\n\n### ***实现组合***\n\n>概括来说，就是接收若干个函数作为参数，返回一个新函数。新函数执行时，按照 <span style=\"color: red\">由右向左</span> 的顺序依次执行传入compose中的函数，每个函数的执行结果作为为下一个函数的输入，直至最后一个函数的输出作为最终的输出结果\n\n```js\nfunction compose(...fns){\n    return function(x){\n        return fns.reduceRight(function(arg,fn){\n            return fn(arg);\n        },x)\n    }\n}\n接受的参数是不确定的，是一个数组，然后由右向左执行函数\n```\n\n### ***实现管道***\n\n>从左至右处理数据流的过程称之为管道(pipeline)! <br/>\n即管道的执行顺序是<span style=\"color: red\">由左向右</span>\n\n```js\nfunction pipe(...fns){\n    return function(x){\n        return fns.reduce(function(arg,fn){\n            return fn(arg);\n        },x)\n    }\n}\n```\n\n参考链接：[彻底弄懂函数组合](https://juejin.im/post/5d50bfebf265da03cb122b6f)\n"},{"title":"各期主题","url":"/Roundtables/Quest-SC/index.html","content":"\n### 各期主题\n\n- [ react-router 前端路由](./one/sc-1)\n- [ ️数据结构 链表](./one/sc-2)\n- [ lodash之concat源码](./one/sc-3)"},{"title":"react-router前端路由","url":"/Roundtables/Quest-SC/one/sc-1.html","content":"---\n{\n    \"title\": \"react-router前端路由\",\n}\n---\n### react-router前端路由\n\n## 两种模式\n- HASH 模式\n\n\t- 就是简单的链接上拼接类似#page1这种形式\n\n- HISTORY 模式\n\n\t- HTML5出现之前，控制路由的API只有以下几种方式（go, forward, back)\n\t- HTML5出现后，新增以下API （pushState, replaceState, state) 其中pushState, replaceState各接收三个参数state, title, url\n\n## API\n\n- BrowserRouter（目前项目基本都是用这种，HashRouter，Router 不推荐使用）\n\n- Route (页面的展示根据匹配的路由展示，compoent, render, children 三种引入UI的方式，有一个exact属性，这个属性是用来精准匹配路由，如/page,假如页面/page/2就不会匹配）\n\n- Redirect\n\n- Switch (用这个包着用Route注册的页面路由，每次只会渲染一个路由匹配的组件，例如'/', '/user' , 如果当前url是‘/’, 之后渲染‘/’的路由)\n[switch](https://reacttraining.com/react-router/web/api/Switch)\n\n```js\nSwitch.prototype.render = function render() {\n    var route = this.context.router.route;\n    var children = this.props.children;\n\n    var location = this.props.location || route.location;\n\n    var match = void 0,\n        child = void 0;\n    React.Children.forEach(children, function (element) {\n      if (match == null && React.isValidElement(element)) {\n        var _element$props = element.props,\n            pathProp = _element$props.path,\n            exact = _element$props.exact,\n            strict = _element$props.strict,\n            sensitive = _element$props.sensitive,\n            from = _element$props.from;\n\n        var path = pathProp || from;\n\n        child = element;\n        match = matchPath(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);\n      }\n    });\n\n    return match ? React.cloneElement(child, { location: location, computedMatch: match }) : null;\n  };\n\n  return Switch;\n}(React.Component);\n```\n\n- NavLink (做tab切换 可以用这个）\n\n- Link (类似a 标签)"},{"title":"数据结构 链表","url":"/Roundtables/Quest-SC/one/sc-2.html","content":"\n\n### 数据结构 链表\n\n[原文链接](https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/README.zh-CN.md)\n\n![链表](https://camo.githubusercontent.com/37013b59008ed49a6701968da6b182eb6a9d24c8/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36642f53696e676c792d6c696e6b65642d6c6973742e737667)\n```js\n// LinkedListNode.js\nexport default class LinkedListNode {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n\n  toString(callback) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n```\n\n```js\n// LinkedList.js\nimport LinkedListNode from './LinkedListNode';\nimport Comparator from '../../utils/comparator/Comparator';\n\nexport default class LinkedList {\n  /**\n   * @param {Function} [comparatorFunction]\n   */\n  constructor(comparatorFunction) {\n    /** @var LinkedListNode */\n    this.head = null;\n\n    /** @var LinkedListNode */\n    this.tail = null;\n\n    this.compare = new Comparator(comparatorFunction);\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedList}\n   */\n  prepend(value) {\n    // Make new node to be a head.\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    // If there is no tail yet let's make new node a tail.\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedList}\n   */\n  append(value) {\n    const newNode = new LinkedListNode(value);\n\n    // If there is no head yet let's make new node a head.\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // Attach new node to the end of linked list.\n    this.tail.next = newNode;\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedListNode}\n   */\n  delete(value) {\n    if (!this.head) {\n      return null;\n    }\n\n    let deletedNode = null;\n\n    // If the head must be deleted then make next node that is differ\n    // from the head to be a new head.\n    while (this.head && this.compare.equal(this.head.value, value)) {\n      deletedNode = this.head;\n      this.head = this.head.next;\n    }\n\n    let currentNode = this.head;\n\n    if (currentNode !== null) {\n      // If next node must be deleted then make next node to be a next next one.\n      while (currentNode.next) {\n        if (this.compare.equal(currentNode.next.value, value)) {\n          deletedNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    }\n\n    // Check if tail must be deleted.\n    if (this.compare.equal(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deletedNode;\n  }\n\n  /**\n   * @param {Object} findParams\n   * @param {*} findParams.value\n   * @param {function} [findParams.callback]\n   * @return {LinkedListNode}\n   */\n  find({ value = undefined, callback = undefined }) {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      // If callback is specified then try to find node by callback.\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      // If value is specified then try to compare by value..\n      if (value !== undefined && this.compare.equal(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * @return {LinkedListNode}\n   */\n  deleteTail() {\n    const deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // There is only one node in linked list.\n      this.head = null;\n      this.tail = null;\n\n      return deletedTail;\n    }\n\n    // If there are many nodes in linked list...\n\n    // Rewind to the last node and delete \"next\" link for the node before the last one.\n    let currentNode = this.head;\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n\n    return deletedTail;\n  }\n\n  /**\n   * @return {LinkedListNode}\n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * @param {*[]} values - Array of values that need to be converted to linked list.\n   * @return {LinkedList}\n   */\n  fromArray(values) {\n    values.forEach(value => this.append(value));\n\n    return this;\n  }\n\n  /**\n   * @return {LinkedListNode[]}\n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * @param {function} [callback]\n   * @return {string}\n   */\n  toString(callback) {\n    return this.toArray().map(node => node.toString(callback)).toString();\n  }\n\n  /**\n   * Reverse a linked list.\n   * @returns {LinkedList}\n   */\n  reverse() {\n    let currNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n\n    while (currNode) {\n      // Store next node.\n      nextNode = currNode.next;\n\n      // Change next node of the current node so it would link to previous node.\n      currNode.next = prevNode;\n\n      // Move prevNode and currNode nodes one step forward.\n      prevNode = currNode;\n      currNode = nextNode;\n    }\n\n    // Reset head and tail.\n    this.tail = this.head;\n    this.head = prevNode;\n\n    return this;\n  }\n}\n```"},{"title":"lodash之concat源码","url":"/Roundtables/Quest-SC/one/sc-3.html","content":"\n\n### lodash之concat源码\n\n```javascript 1.8\nfunction copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    // 这里判断 array 是否为 undefined，如果是就定义一个与 source 长度相等的数组。\n    array || (array = Array(length));\n\n    while (++index < length) {\n        array[index] = source[index];\n    }\n    return array;\n}\n\n// arrayPush方法是在传入的参数array基础上进行拼接的\nfunction arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n        array[offset + index] = values[index];\n    }\n    return array;\n    /**\n     * 举例分析：\n     * arrayPush([1,2,3], [4, [5]]);\n     * 刚进来 index = -1;  length = 2; offset = 3;\n     * 进入循环\n     * index = 0; offset + index = 3; array[3] = values[0] = 4;\n     * index = 1; offset + index = 4; array[4] = values[1] = [5];\n     * index = 2; 停止循环\n     *\n     * array = [1,2,3,4,[5]]\n     *\n     */\n}\n\n\nvar isArray = Array.isArray;\n\n// 这个方法是在判断 value 是否是可以被打平的 arguments 对象或者数组。如果是，返回 true，若不是，则返回 false\nfunction isFlattenable(value) {\n    return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n *\n * @param array\n * @param depth\n * @param predicate  每次迭代调用的函数\n * @param isStrict   限制\n * @param result\n * @returns {Array}\n */\n// 减少嵌套数组\nfunction baseFlatten(array, depth, predicate, isStrict, result) {   // 2, [3], [4], -1: [1]\n    var index = -1,\n        length = array.length;\n\n    // 判断是否传入 predicate, 若没有，将方法 isFlattenable 赋值给 predicate\n    predicate || (predicate = isFlattenable);\n\n    result || (result = []);\n\n    //[1,[3], [4, [5]]]\n\n    while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n            } else {\n                arrayPush(result, value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\n\n\n// 源码\n// _.concat(array, [values])  创建一个新数组，将array与任何数组 或 值连接在一起\n/**\nvar array = [1];\nvar other = _.concat(array, 2, [3], [[4]]);\n\nconsole.log(other);\n// => [1, 2, 3, [4]]\n\nconsole.log(array);\n*/\nfunction concat() {  // [1], 2, [3], [4]\n    // 获取参数个数\n    var length = arguments.length;\n\n    if (!length) {\n        return [];\n    }\n\n    var args = Array(length - 1),   // 去除0索引以外的参数\n        array = arguments[0],      // 第一个元素\n        index = length;\n\n    // 从后往前添加\n    while (index--) {\n        args[index - 1] = arguments[index];\n        /**\n         * 4 index = 3;  args[2] = arguments[3] = [4];\n         * 3 index = 2;  args[1] = arguments[2] = [3];\n         * 2 index = 1;  args[0] = arguments[1] = 2;\n         * 1 index = 0;  args[-1] = arguments[0] = [1];\n         * args = [2, [3], [4], -1: [1]]\n         */\n    }\n    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n}\n```"},{"title":"ES2020新功能简介","url":"/Roundtables/Question-Bank/ES6+/ES2020.html","content":"# ES2020新功能简介\n\n- 类中的私有变量\n- 可选链\n- 空位合并运算符\n- BigInt\n\n## 类中的私有变量 #x\n\n使用` # `符号表示类的私有变量。这样就不需要使用闭包来隐藏不想暴露给外界的私有变量。\n```js\nclass Counter {\n  #x = 0;\n  getNum(){\n    return this.#x;\n  }\n}\n\nconst c = new Counter();\n\nconsole.log(c.getNum()); // 0\nconsole.log(c.#x); // Uncaught SyntaxError: Private field '#x'\n```\n #x 是一个私有变量，无法在类外部访问，将会得到提示 Uncaught SyntaxError: Private field '#x'。\n\n私有变量是 JavaScript 类非常需要的功能。现在，最新版本的 Chrome 和 Node.js v12 中已提供了此功能。\n\n\n## 可选链运算符 ?.\n\n当前，如果要访问对象的深层嵌套属性，则必须通过很长的布尔表达式去检查每个嵌套级别中的属性。必须检查每个级别中定义的每个属性，直到所需的深度嵌套的属性为止，如下代码所示：\n```js\nconst obj = {\n  prop1: {\n    prop2: {\n      prop3: {\n        prop4: {\n          prop5: 5\n        }\n      }\n    }\n  }\n}\nobj.prop1 &&\n  obj.prop1.prop2 &&\n  obj.prop1.prop2 &&\n  obj.prop1.prop2.prop3 &&\n  obj.prop1.prop2.prop3.prop4 &&\n  console.log(obj.prop1.prop2.prop3.prop4.prop5);\n```\n上面的代码在我们想要访问的每个级别中都定义了每个属性。如果在任何级别的对象中都有 undefined 或 null 的嵌套对象，如果不进行检查，那么的程序将会崩溃。这意味着我们必须检查每个级别，以确保当它遇到 undefined 或 null 对象时不会崩溃。\n\n使用**可选链运算符**，只需要使用 `?.` 来访问嵌套对象。而且如果碰到的是 undefined 或 null 属性，那么它只会返回 undefined。通过可选链，可以把上面的代码改为：\n```js\nconst obj = {\n  prop1: {\n    prop2: {\n      prop3: {\n        prop4: {\n          prop5: 5\n        }\n      }\n    }\n  }\n}\n\nconsole.log(obj?.prop1?.prop2?.prop3?.prop4?.prop5);\n```\n当我们的程序执行到 undefined 或 null 属性时，**不会崩溃，而只是返回 `undefined`**。\n\n## 空位(nullish)合并运算符 ??\n“nullish”空位合并运算符，用 `??` 表示。如果 `??` 左边的值是 null 或者 undefined，那么就返回右边的值。\n```js\nconst x = null;\nconst y = x ?? 500;\nconsole.log(y); // 500\n\nconst n = 0\nconst m = n ?? 9000;\nconsole.log(m) // 0\n```\n\n## BigInt大整数 123n\n\n用 BigInt 对象表示大于 2^53 - 1 的整数，可以由数字和十六进制或二进制字符串构造。可通过如下场景来理解其特性：\n```js\n// 以字面量方式定义时，末尾要加 n\nconst bigInt = 22222222222222222222222222222222n;\nconsole.log(bigInt); // 22222222222222222222222222222222n\n\n// 以工厂函数创建时，传入整数或字符串\nconst bigInt = BigInt(1);\nconsole.log(bigInt); // 1n\n\nconst bigHex = BigInt(\"0x1fffffffffffff111111111\");\nconsole.log(bigHex); // 618970019642690073311383825n\n\n// BigInt 是一个大整数，不能存储小数。\nconst rounded = 9n / 2n;\nconsole.log(rounded) // 4n , 因为小数部分已从 BigInt 中删除。\n\n1n === 1 // false，因为 BigInt 和数字不是同一类型。\n\n1n == 1 // true, 因为仅比较了该值\n```\n\n\n参考链接：[New JavaScript Features Coming in ES2020 That You Can Use Now](https://levelup.gitconnected.com/new-features-of-javascript-that-we-can-use-soon-or-now-6199981bd2f)\n\n"},{"title":"ES6相比于ES5有什么不同","url":"/Roundtables/Question-Bank/ES6+/ES6.html","content":"---\ntitle: ES6相比于ES5有什么不同\ntags: [let, const, 块级作用域, 暂时性死区, 箭头函数, 模板字符串, 解构, 扩展, import, export, promise, class, extends, Set, Map, Proxy, Reflect]\ncategories: ES6\n---\n\n# ES6相比于ES5有什么不同\n\nECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。\n\nECMAScript 6 (ES6)/ECMAScript 2015 (ES2015):  第6个ECMAScript版本，于2015年标准化。。\n\n## let 和 const\n\n1. ES6共有`6`种声明变量的方法：\n    - ES5 只有两种声明变量的方法：var命令和function命令。\n    - ES6 添加了 let和const命令，import命令和class命令。\n\n2. `块级作用域`：\n    - `{}`被ES6用来**确定块级作用域**，只要代码块内存在let、const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。即只在声明的块级作用域内有效。\n    - 块级作用域的出现使得被广泛使用的立即执行匿名函数不再必要了。\n\n    ::: tip 为什么需要块级作用域？\n    ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景：\n    1. 第一种场景，内层变量可能会覆盖外层变量。\n    2. 第二种场景，用来计数的循环变量泄露为全局变量。\n    :::\n\n3. `暂时性死区`（因为`没有变量提升`）：\n    - **原因**：let、const 没有声明提升的作用，这是导致“暂时性死区”的原因（ps：只有var和Function是函数级作用域，具有变量声明提升的作用）。\n    - **定义**：在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n    - 只能在let、const声明之后使用变量或常量，在声明之前调用 变量/常量 就属于该 变量/常量 的“死区”，会报错。\n4. 重复声明和赋值：\n    - let定义变量，不能重复声明，而 var可以重复声明。\n    - const定义常量，在定义时必须赋值，否则报错，且对于原始类型不能再修改，而对于Object类型（引用类型），可以修改堆内存空间中的存储值value，不能修改栈内存中的常量引用key：比如\n    ```js\n    const a = { b: 1}\n    a.b = 2 // 修改值没问题\n    a.c = 3 // 新增属性也没问题\n    a = { d: 1} // 报 error，因为引用地址不能重新赋值\n    ```\n\n## 模板字符串 ``\n- 无需+号拼接字符串，直接使用 ${variable} 就可直接输出；\n- 输出不会紧挨着一行显示，会识别换行符。\n\n## 函数传参\n函数传参时可直接给定默认参数，在ES5中是不可以的。\n\n## for-of操作\n`for...of`语句用来迭代访问一个对象的所有属性。\n\n## 字符串、对象、数组和函数的解构\n```js\nvar [a, b] = [3, 8 ,10] // 数组解构 a为3 b为8\nvar [x, y, z] = \"Vue\"   // 字符串解构 x为V y为u z为e\nvar {m, n} = {n: 10, m: 20} // 对象解构 按照key对应拆分 m为20 n为10\n\nfunction sum([x, y]) {\n    return x + y\n}\nsum([2, 8]) // 函数参数解构\n```\n\n#### 练习题1\n\n请指出该函数的执行结果：\n```js\nfunction foo({ a = 'a', b = 'b', c = 'c', d = 'd' } = { a: 1, b: 2 }) {\n    console.log(a, b, c, d);\n}\n \nfoo(); // 1 2 \"c\" \"d\"\nfoo({ a: 10, b: 11 }); // 10 11 \"c\" \"d\"\nfoo({ c: 10, d: 11 }); // a b 10 11\n```\n\n#### 练习题2\n\n请指出以下代码的执行后，abcd分别是什么值：\n```js\nlet { a: b, c: d } = { a: 1, b: 2, c: 3, d: 4};\n \na // a会报错，a is not defined\nc // c会报错，c is not defined\nb // 1\nd // 2\n```\n\n## 扩展(spread)运算符 ...\n\n- rest参数：当不确定参数个数时，可以使用...rest来表示\n```js\nlet fn = (...m) => {console.log(m)};\n\nfn(2, 3, 4, 7) // [2, 3, 4, 7]\n```\n- 扩展数组或对象：\n```js\nvar arr3 = [...arr1, ...arr2];\nvar obj3 = { ...obj1, ...obj2 };\n```\n\n#### 解构和扩展运算结合\n```js\nvar [x, ...y] = [4, 8, 10, 30] // x为4，y为[8, 10, 30]\nvar [x, y] = [4, 8, 10, 30] // x为4，y为8\n\nvar [a, b, c] = \"ES6\" // a为E b为S c为6\nvar z = [...\"ES6\"] // z为[\"E\", \"S\", \"6\"]\n```\n\n## 箭头函数 =>\n```js\nvar newArr = arr.map(item => item+2) // item 和 item+2 很简单时无需包裹\n```\n1. 函数体内的this对象就是`定义时所在的对象`，而不是使用时所在的对象（避免了ES5中var that = this操作）；\n2. `箭头函数根本没有this`，所以**内部的this就是外层代码块的this**，因此不能用作构造函数。也就是说，`不可以使用new命令`，否则会抛出一个错误；\n3. 不可以使用arguments对象，可以用rest参数代替；\n4. 不可以使用yield命令，因此箭头函数不能用作Generator函数。\n\n#### 为什么箭头函数没有this指向问题\n箭头函数中，事件处理程序已经自动绑定到了组件实例上，这是由于在箭头函数的情况下，`this 是有词法约束力的，使用词法this绑定`。这意味它可以使用封闭的函数上下文或者全局上下文作为 this 的值。\n\n## Promise\n\n传送门：[异步编程（2）：Promise对象](/Question-Bank/execution/asynchronous-promise.md)\n\n## ES6Module模块化：import & export\n\n传送门：[JS模块化规范(5种)-5、ES6module](/Question-Bank/Engineering/js-module.html#_5、es6module)\n\n## Symbol\n\n传送门：[JS专题-变量与类型-(2)JS 3种疑难基础类型-不太熟的symbol类型](/Question-Bank/basic-grammar/variablesAndTypes2.html#不太熟的symbol类型)\n\n## Set和Map数据结构\n- ES6 提供了 Set数据结构 `Set 类似于数组`，但是成员的值都是唯一的，没有重复的值。\n- ES6 提供了 Map数据结构。`Map 类似于对象`，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash结构实现。\n\n## Proxy代理\nES6为了操作对象而提供的新API。\n\n- Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\n- Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\n- ES6原生提供Proxy构造函数，用来生成Proxy实例： var proxy = new Proxy(target, handler)\n    - Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象（有13种方法），用来定制拦截行为。\n\n## Reflect\nReflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。\nReflect对象的`设计目的`：\n1. 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的`新方法将只部署在Reflect对象上`。\n2. `修改某些Object方法的返回结果`，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n3. 让Object操作都`变成函数行为`。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n\n\n## class 语法\n\nES6开始支持定义类（`class`关键字），构造函数（`constructor`关键字），和`extends`关键字来实现继承。\n\n::: warning 默认严格模式\n**类**和**模块**的内部，`默认就是严格模式`，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。ES6 实际上把整个语言升级到了严格模式。\n:::\n\n### constructor 构造方法\n- 通过new命令生成对象实例时，自动调用该方法。\n- 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被`默认添加`。\n- constructor中的this就是实例对象。默认返回的也是this。\n\n### 实例属性（两种写法）\n- 定义在constructor()方法里面的this上面。\n- 定义在类的最顶层（*ES7 提案*），这时不需要在实例属性前面加this。\n\n### 类方法（原型方法）\n类的所有方法都定义在类的prototype属性上面。\n```js\nclass Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\n// 等同于\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n};\n```\n\n::: details 类方法都是”不可枚举的“\n注意：类中定义的内部方法都是”不可枚举的“，而采用ES5构造函数的写法时，是可枚举的：\n```js\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype) // [] ES6中是不可枚举的\nObject.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"]\n```\n\nES5追加的原型方法都是可枚举的。\n```js\nvar Point = function (x, y) {\n  // ...\n};\n\nPoint.prototype.toString = function() {\n  // ...\n};\n\nObject.keys(Point.prototype) // [\"toString\"]，可枚举的\nObject.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"]\n```\n:::\n\n\n### 静态属性\n`ES6 明确规定，Class 内部只有静态方法，没有静态属性`。因此只能将静态属性定义在类的外部，整个类生成以后，再生成静态属性（现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字）。\n```js\nclass Foo {\n}\n\n// 静态属性 只能在 类的外部 追加\nFoo.prop = 1;\nFoo.prop // 1\n```\n\n*ES7 提案*中，可以使用 static 定义一个静态属性：\n```js\nclass Animal {\n    static num = 42;\n\n    constructor() {\n        // ...\n    }\n}\n\nconsole.log(Animal.num); // 42\n```\n\n### 静态方法\n- 在一个方法前，加上static关键字，就表示`该方法不会被实例继承`，而是`直接通过类来调用`，这就称为“`静态方法`”。\n- 如果静态方法包含this关键字，这个this指的是类，而不是实例。\n- 父类的静态方法，可以被子类继承。\n\n```js\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n  static say() {\n      this.classMethod();\n  }\n}\n\nFoo.classMethod() // 'hello'\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n\nFoo.say() // 'hello'，指向类\n\nclass Bar extends Foo {\n}\nBar.classMethod() // 'hello'，可被继承\n```\n\n::: details 例题：函数方法优先级\n函数方法优先级：`实例追加方法` > `构造函数方法` > `原型对象方法` > `（报错）构造函数的静态方法`\n```js\nfunction Foo() {\n  this.print = function() {\n    // 构造函数this上，优先级2\n    console.log('Ctor function')\n  }\n}\n\nFoo.print = function() {\n  // 构造函数静态方法，优先级4，且实例取不到会报错\n  console.log('static function')\n}\n\nFoo.prototype.print = function() {\n  // 原型方法，优先级3\n  console.log('prototype function')\n}\n\nvar foo = new Foo()\n\nfoo.print = function() {\n  // 实例追加方法，优先级1\n  console.log('instance function')\n}\n\na.print()\n```\n此题定义了4种方法，按注释提示，上题会输出`'instance function'`，依次注释掉会按顺序输出不同结果，如果只有构造函数的静态方法会报错，因为a是取不到的。\n\n**注意**：*通常会把原型链上的方法叫做实例方法，因为实例上一版不会追加方法，通过实例调用就会去原型链上找。*\n:::\n\n### this指向问题\n类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法（比如从实例中解构出来单独使用），很可能报错。\n```js\nclass Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n关于JS中的this绑定，可详见传送门[JS执行机制-this指向问题](/Question-Bank/execution/context.html#this指向问题)。\n\n解决方法主要有两类：在constructor中使用bind，或者使用箭头函数。具体可参考传送门[react类组件中处理this绑定的4种方法](/Question-Bank/react/react-handle-this.html)。\n\n\n\n### 私有属性和私有方法\n\n私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。有利于代码的封装，但 ES6 没有提供。可用的解决方案如下：\n#### 1. 将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n```js\nclass Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n```\n上面代码中，foo是公开方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。\n\n\n#### 2. 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\n```js\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass {\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n\n\nconst inst = new myClass();\n\nReflect.ownKeys(myClass.prototype) // [ 'constructor', 'foo', Symbol(bar) ]\n```\n上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但其实，通过Reflect.ownKeys()依然可以拿到它们。\n\n### 存取器 getter/setter\n使用 getter 和 setter 可以改变属性的赋值和读取行为：\n```js\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    get name() {\n        return 'Jack';\n    }\n    set name(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nlet a = new Animal('Kitty'); // setter: Kitty\na.name = 'Tom'; // setter: Tom\nconsole.log(a.name); // Jack\n```\n\n### 类继承 extends/super\n\nsuper可作为函数和对象两种方式使用，且使用方式完全不同：\n#### 1. 作为函数，只能在constructor中使用\nES6 要求，`子类的构造函数必须执行一次super函数`（子类必须在constructor方法中调用super方法），如果不调用super方法，子类就得不到this对象，会报错。\n\n**注意**：super虽然代表了父类A的构造函数，但是`返回的是子类B的实例`，即super内部的this指的是B的实例，\n\n#### 2. 作为对象，使用在函数中\nsuper作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\n\n```js\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 作为函数使用，只能在子类constructor中 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 作为对象使用，调用父类的toString()\n  }\n}\n```\n\n**注意**：如果子类没有定义constructor方法，这个`方法会被默认添加`，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。\n::: details 默认给子类添加constructor和super\n```js\nclass ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n```\n:::\n\n#### ES6继承与ES5继承机制比较\n- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。\n- ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n"},{"title":"ES6类语法中，三种类成员方法有什么区别","url":"/Roundtables/Question-Bank/ES6+/class-method.html","content":"# ES6类语法中，三种类成员方法有什么区别\n\n```js\nclass Demo {\n    method1() {\n        return 1;\n    }\n \n    method2 = () => {\n        return 2;\n    }\n \n    static method3 = {\n        return 3;\n    }\n}\n```\n"},{"title":"CSS命名风格规范","url":"/Roundtables/Question-Bank/Engineering/css-naming-standard.html","content":"# CSS命名风格规范\n\n本文主要简介：BEM, OOCSS, ACSS。\n\n## BEM（Block, Element, Modifier）\nBlock Element Modifier，它是一种前端命名方法，旨在帮助开发者实现模块化、可复用、高可维护性和结构化的CSS代码。\n\n简单说，就是 html 是一个 DOM树，那么你在写样式的的时候就写成一个 BEM树一一对应就可以了\n```scss\n.block{}\n.block__element{}\n.block--modifier{}\n```\n多层dom节点嵌套时\n```html\n<ul class=\"menu\">\n  <li class=\"menu__item\">\n    <a class=\"menu__link\">\n      <span class=\"menu__text\"></span>\n    </a>\n  </li>\n</ul>\n```\n这里的 a 不能写出 menu__item__link 这样就太丑了\n\n## OOCSS（面向对象css）\nObject Oriented CSS 的想法首先要明白 CSS 的 “Object” 是什么。一般指一个视觉上的图案、控件等，且大部分情况下，这种 Object 肯定是可以复用的。\n\nOOCSS 认为 container 和 content 是需要隔离开的。也就是说，尽量不要去使用依赖于节点结构位置的样式定义。\n```scss\n.video-container .title{\n  ...\n}\n```\nOOCSS 中会建议你直接这样去写:\n```scss\n.title{\n  ...\n}\n```\n\n## ACSS（Atomic CSS）\nAtomic CSS 就是 `Style with class`，就好像你所有的样式都是 inline 了一样一目了然。\n\n好处就是不用在管理各种页面各自的样式文件了，你准备好一个原子库，直接写 html 就能把样式写出来。\n\n问题也很明显，如果要做响应式就会比较麻烦，因为你的样式都是原子性的写在 html 中。它会针对每个选择器定义一个可以复用的 class：\n```scss\n.Bgc-fff{\n   background-color: #fff;\n}\n```\n```html\n<div class=\"Bgc-fff\"></div>\n```\n"},{"title":"JS常见设计模式","url":"/Roundtables/Question-Bank/Engineering/design-patterns.html","content":"# JS常见设计模式\n\n## 单例模式\n因为 JavaScript 是无类的语言, 而且 JS 中的全局对象符合单例模式两个条件。很多时候我们把全局对象当成单例模式来使用,\n\n\n## 组合模式\n\n## 发布订阅模式\n\n\n## 观察者模式\n\n## 参考链接\n\n- [JavaScript 中常见设计模式整理](https://juejin.im/post/5afe6430518825428630bc4d)\n\n\n"},{"title":"JS模块化规范(5种)","url":"/Roundtables/Question-Bank/Engineering/js-module.html","content":"---\ntitle: JS模块化规范(5种)\ntags: [AMD, CMD, UMD, CommonJS, ES6Module, 循环引用, define, nodejs]\ncategories: Engineering\n---\n\n# JS模块化规范(5种)\n\n由于ES5没有模块化规范，所以产生了CommonJS、AMD、CMD这三种规范（还有UMD这种融合规范）。在ES6中又新增了ES6Module。因此JS模块化规范共有5种：CommonJS、AMD、CMD、UMD、ES6Module。\n\n这些方案大致分为 `同步` 与 `异步` 两类：除了CommonJS是同步，其余规范都是异步的。\n- 因为服务端模块都存储在本地，所以服务端资源是同步加载的；\n- 但是对于客户端浏览器而言，加载的时间还取决于网速的快慢等因素，可能会由于网络原因陷入“假死”状态。如果使用同步加载，那么大概率会阻塞加载，所以浏览器资源是异步加载的。\n\n\n\n## 1、CommonJS\n`同步加载`、require/module.exports、以**node.js**为代表。\n\nCommonJS定义的模块分为三种：模块引用(require)；模块定义(exports)；模块标识(module)\n```js\n// 导入\nrequire(\"module\");\nrequire(\"../app.js\");\n// 导出\nexports.getStoreInfo = function() {};\nmodule.exports = someValue;\n```\n## 2、AMD\n`异步加载`、`依赖前置`、所有依赖模块的语句，都定义在一个回调函数中，等到加载完成之后，回调函数才执行；以**require.js**为代表.\n```js\n// 定义\ndefine(['./a', './b'], function(a, b) {  // 依赖必须一开始就写好  \n   a.doSomething()    \n   // 此处略去 100 行    \n   b.doSomething()    \n   ...\n});\n// 加载模块\nrequire([\"module\", \"../app\"], function(module, app) {...});\n```\n## 3、CMD\n`异步加载`、`依赖就近`、以**sea.js**为代表。\n```js\ndefine(function(require, exports, module) {\n  var a = require('./a');\n  a.doSomething();\n  // 依赖就近书写，什么时候用到什么时候引入\n  var b = require('./b');\n  b.doSomething();\n});\n```\n## 4、UMD\nUMD是AMD和CommonJS的糅合：\n- AMD 以浏览器第一原则发展异步加载模块。\n- CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装。\n\n**UMD先判断是否支持Node.js(即CommonJS)的模块（就是判断exports是否存在），存在则使用CommonJS模块模式；再判断是否支持AMD（就是判断define是否存在），存在则使用AMD方式加载模块。**\n```js\n(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.eventUtil = factory();\n    }\n})(this, function () {\n    //module ...\n});\n```\n\n## 5、ES6Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，**成为浏览器和服务器通用的模块解决方案**。\n\nES6 模块设计思想：尽量的静态化、使得编译时就能确定模块的依赖关系，以及输入和输出的变量（CommonJS和AMD模块，都只能在运行时确定这些东西）。\n\n使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。\n\n### 静态import函数：\n```js\nimport { lastName } from './profile.js';\n// 或重命名\nimport { lastName as surname } from './profile.js';\n\nimport { getArea, getRadius } from './circle';\n\ngetArea()\ngetRadius()\n\n// 或整体引入\nimport * as circle from './circle';\n\ncircle.getArea()\ncircle.getRadius()\n```\n\n**因为是`在编译阶段执行`，所以import命令会有提升效果，提升到模块的头部**：\n```js\n//假设webpack的入口文件是```main.js```\n\n//main.js\nimport moduleA from 'moduleA'\nconsole.log(1)\n\nimport moduleB from 'moduleB'\nconsole.log(2)\n\n//moduleA.js\nconsole.log(3)\n\n//moduleB.js\nconsole.log(4)\n\n//最终在浏览器控制台中打印出的数字顺序是: 3 4 1 2\n```\n\n### export\nexport default 默认暴露或者export 函数名来暴露某函数名。\n```js\n// 第一组\nexport default function crc32() { // 输出\n    // ...\n}\n\nimport crc32 from 'crc32'; // 输入\n\n// 第二组\nexport function crc32() { // 输出\n    // ...\n};\n\nimport {crc32} from 'crc32'; // 输入\n```\n\n### 动态import()函数\nES2020提案 引入import()函数，支持动态加载模块。import()返回一个 Promise 对象。\n```js\nconst main = document.querySelector('main');\n\nimport(`./section-modules/${someVariable}.js`).then(module => {\n    module.loadPageInto(main);\n}).catch(err => {\n    main.textContent = err.message;\n});\n```\n- import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。\n- import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。\n\n### import 与 export语句 复合写法\n复合写成一行，foo和bar实际上并没有被导入当前模块，只是相当于`对外转发了这两个接口`，导致当前模块不能直接使用foo和bar。\n```js\nexport { foo, bar } from 'my_module';\n```\n\n模块的`接口改名`和`整体输出`，也可以采用这种写法。\n```js\n// 接口改名\nexport { foo as myFoo } from 'my_module';\n\n// 整体输出\nexport * from 'my_module';\n```\n\n### ES6 Module 与 CommonJS 两种模块化规范的比较\n\n本标题又可以视作 *“require与import的区别”*、*“module.exports与export的使用区别”*。\n\n**注意一点**：require/exports 是通用的，为什么这么说呢？因为事实上，目前你所编写的 import/export 最终都是编译为 require/exports 来执行的。\n\n#### CommonJS：\n1. **输出类型不同**：CommonJS 模块输出的是一个`值的拷贝`副本。\n    - 对于基本数据类型，属于值复制。即会被模块缓存一份；也正由于是值的拷贝缓存副本，所以可以对其重新赋值。\n    - 对于引用数据类型，属于浅拷贝。由于两个模块引用的对象或函数指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。\n2. **执行时机不同**：CommonJS 模块是`运行时加载`。\n    - 当使用require命令加载某个模块时，就会运行整个模块的代码。\n    - 当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。\n3. **循环加载时处理不同**：CommonJS 模块是运行时加载。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就**只输出已经执行的部分，还未执行的部分不会输出**。\n\n#### ES6模块：\n1. **输出类型不同**：ES6Module 模块输出的是`值的引用`。\n    - import命令可被视作一种“符号连接”，当模块遇到import命令时，就会生成一个`只读引用`。因为是`只读引用`，所以不论基本数据类型还是引用类型，都不能重新赋值。\n2. **执行时机不同**：ES6Module 模块是`编译时输出接口`。\n    - import命令在编译时建立“符号连接”，等到脚本真正执行时，再根据这个`只读引用`，`动态`地到被加载的那个模块里面去取值。因为是`动态`加载，所以当原始值变化时，不论基本数据类型还是引用类型，import加载的值也会发生变化。\n3. **循环加载时处理不同**：ES6模块是`动态`引用，import的变量不会被缓存，而是成为一个指向被加载模块的引用，**需要开发者自己保证，真正取值的时候能够取到值**。\n\n::: details 循环引用的例子\n```js\n// a.js\nexports.done = false\nlet b = require('./b.js')\nconsole.log('a.js-1', b.done)\nexports.done = true\nconsole.log('a.js-2', '执行完毕')\n\n// b.js\nexports.done = false\nlet a = require('./a.js')\nconsole.log('b.js-1', a.done)\nexports.done = true\nconsole.log('b.js-2', '执行完毕')\n\n// c.js\nlet a = require('./a.js')\nlet b = require('./b.js')\n\nconsole.log('c.js-1', '执行完毕', a.done, b.done)\n// 运行node c.js\nusr:~ usr$  node c.js\nb.js-1 false\nb.js-2 执行完毕\na.js-1 true\na.js-2 执行完毕\nc.js-1 执行完毕 true true\n```\n:::\n\n\n"},{"title":"代码管理风格规范","url":"/Roundtables/Question-Bank/Engineering/repo-naming-standard.html","content":"# 代码管理风格规范\n\n代码管理标准比较流行的有联众方式：`monorepo`、`multirepo`：\n- `Monorepo` 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块/包 (package)；vue3就用此方式；\n    - 目前最常见的 `monorepo` 解决方案是 Lerna 和 yarn 的 workspaces 特性；\n    - lerna 和 yarn-workspace 并不是只能选其一，大多 `monorepo` 即会使用 lerna 又会在 package.json 声明 workspaces。这样的话，无论你的包管理器是 npm 还是 yarn，都能发挥 `monorepo` 的优势；要是包管理是 yarn ，lerna 就会把依赖安装交给 yarn 处理。\n- `Multirepo` 是每个模块建一个 repo。\n- 另外还有git submodule，通过 Git 子模块，可以在当前 repo 中包含其它 repos、作为当前 repo 的子目录使用，同时能够保持 repos 之间的独立。\n"},{"title":"MVVM框架基础","url":"/Roundtables/Question-Bank/MVVM/mvvm-base.html","content":"# MVVM框架基础\n\n## 从 MVC 说起\n以backbone.js为例：\n1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。\n2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。\n3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。\n\n![](./images/mvc.png)\n\n> *mvc最早是一个后端开发的概念，字面上的意思是Model模型，也就是数据；View展示的内容  ；Controler控制器控制mv的内容呈现。在还没有进行前后端分离的时候，前端界面统一由后端进行渲染，JSP就是一个标准的ModelAndView,在后端进行渲染时，通过JSP的特殊标签进行数据注入，而后得到对应的html页面，十分类似es6的字符串模板。jsp在后端渲染时后端会解析这些标签，利用数据填充这些标签标记的位置，然后生成string格式的html文本，然后返回给浏览器。这其中，控制器C所做的事情就是根据请求的资源，控制当前使用哪一个ModelAndView。*\n\n## MVVM 定义及原理\n\nMVVM（Model-View-ViewModel）是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI视图，它负责将数据模型转化成 UI 展现出来；ViewModel 是一个同步View 和 Model的对象。\n\n- MVVM的`本质`是指**双向数据绑定**，即 View 与 Model 之间的双向通信，由 ViewModel 作桥接。\n- 在MVVM架构下，`View`和`Model`之间并没有直接的联系，而是通过一个绑定器`ViewModel对象`进行交互，`Model`和`ViewModel`之间的交互是双向的，因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View上。\n- ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和Model之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理（这就是数据驱动的意义）。\n- View 非常薄，不部署任何业务逻辑，称为\"被动视图\"（Passive View），即没有任何主动性，而ViewModel非常厚，所有逻辑都部署在那里。\n\n![](./images/mvvm.jpg)\n\nVue、Angular都是MVVM的框架，但React不是。\n\n### 双向绑定原理\n\n双向绑定需要实现数据监听，Angluar 早期的脏检查机制开创了 mvvm 先河，但监听效率较低，后来几乎所有框架都改为了 数据劫持(getter/setter) 实现监听。\n以 Vue 的双向绑定实现为例：以`「数据劫持」结合「发布订阅模式」`的方式：\n- \"正向绑定M->V\"：通过`Object.defineProperty()`来为数据添加`getter/setter`，在数据变动时，劫持改变，并发布给订阅者，触发相应的监听回调，更新View；\n- \"反向绑定V->M\"：通过绑定input或change事件，框架内部自动执行完成。\n\n双向绑定具体实现原理，请戳传送门：[]()\n\n### 双向绑定 VS 单向绑定\n*一般只有UI表单控件才存在双向数据绑定，非UI表单控件只有单向数据绑定。*\n\n- 关系：**双向绑定** = **单向绑定** + `UI事件监听`。\n- 双向绑定：通过 ViewModel 实现 Model -> View 及 View -> Model的状态同步；\n- 单向绑定：没有 View -> Model 这一步，需要手动绑定UI事件监听（添加onChange事件）。\n\n**优缺点**：在表单交互较多的情况下，单向数据绑定的优点是数据更易于跟踪管理和维护，缺点是代码量较多比较啰嗦；而双向绑定正好相反，代码简洁开发方便，不过容易造成数据流混乱。\n\n### 观察者模式（发布订阅）\n\n观察者模式，即发布订阅模式：\n![](./images/pub-sub.png)\n\n- Pub：`Observer(观察者`,其实背后就是**defineProperty**)，它监听到Data的变化(触发object.**defineProperty**下的set函数)，通知`Dep(订阅者列表)`；\n- Sub：`Dep(订阅者列表)`会根据`Watcher(订阅者)`对其的订阅来判断是否需要调用**update**回调函数，如果需要便会自动执行**update**回调函数，告知Watcher去**更新View**。\n\n### Vue响应式原理\n\n#### Object.defineProperty\nVue2 的响应式原理是使用Object.defineProperty追踪依赖，当属性被访问或改变时通知变化。\n\n::: tip Vue如何监听对象和数组\nObject.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持。因此，**vue要监听对象和数组，是通过「`遍历数组`」和「`递归遍历对象`」**。\n:::\n\n::: details\n##### 1. object.defineProperty 描述符\n描述符必须是**数据描述符**和**存取描述符**这两种形式之一；不能同时是两者。\n- **数据描述符**和**存取描述符**均具有以下可选键值：\n    - `configurable`：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。\n    - `enumerable`：当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。\n- **数据描述符**可选键值：\n    - `value`：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。\n    - `writable`：当且仅当该属性的 writable 为 true 时，value 才能被赋值运算符改变。默认为 false。\n- **存取描述符**可选键值：\n    - `get`：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。\n    - `set`：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。\n\n##### 2. 使用 object.defineProperty\n```js\n// 1. 隐式 使用 __proto__\nvar obj1 = {};\nvar descriptor = Object.create(null); // 没有继承的属性\n// 默认没有 enumerable，没有 configurable，没有 writable\ndescriptor.value = 'static';\nObject.defineProperty(obj1, 'key', descriptor);\nconsole.log(obj1); // 对象obj2拥有了属性key，值为static\n\n// 2. 显式\nvar obj2 = {};\nObject.defineProperty(obj2, 'key', {\n    enumerable: true,\n    configurable: false,\n    writable: false,\n    value: 'static',\n});\nconsole.log(obj2); // 对象obj2拥有了属性key，值为static\n\n// 3. 在对象中添加一个属性与存取描述符的示例\nvar value = 10;\nObject.defineProperty(obj3, \"key\", {\n    get : function(){\n        return value;\n    },\n    set : function(newValue){\n        value = newValue;\n    },\n    enumerable : true,\n    configurable : true\n});\n\nobj3.key = 38;  // 对象obj3拥有了属性key，值为38\n```\n:::\n\n##### 3. object.defineProperty（ES5）与 reflect.defineProperty（ES6）的区别\nobject上的方法都将慢慢迁移到reflect上。\n1. 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。\n2. 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\n3. 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\n\n##### 4. :tada: Vue中数据劫持的明显缺点（两点）：\n1. 不能检测到**添加**或**删除**的属性。\n    - `object.defineProperty`对于添加的新属性我们并没有监听，而删除属性并不被get和set拦截，所以也检测不到。\n2. 数组方面的变动，如**根据索引改变元素**，以及**直接改变数组长度**，不能被检测到。例如`vm.items[indexOfItem] = newValue`，`vm.items.length = newLength`。\n    - 其实`object.defineProperty`本身是可以监听和响应数组`arr[index] = val`的变动的，但 尤大 说，出于从 性能代价和用户体验收益权衡，并没与实现这个功能。\n\n::: details Vue提供了解决方法：\n1. 由于 性能的考量，Vue **不能检测以下两种`数组`的变动**:\n    - 利用索引直接设置一个数组项时，例如：`vm.items[index] = newValue`，解决方式：\n    ```js\n    // Vue.set\n    Vue.set(vm.items, index, newValue)\n    // 等价于 (vm.$set 实例方法是全局方法 Vue.set 的一个别名)\n    vm.$set(vm.items, index, newValue)\n    \n    // 或 Array.prototype.splice\n    vm.items.splice(index, 1, newValue)\n    ```\n    - 修改数组的长度时，例如：`vm.items.length = newLength`，解决方式：`vm.items.splice(newLength)`\n2. 由于 JS 的限制，Vue **不能检测`对象属性`的添加或删除**，对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性：\n- 解决方式：\n    - 单个属性添加：\n    ```js\n    // 可以使用 方法向嵌套对象添加响应式属性。\n    Vue.set(obj, propertyName, value)\n    vm.$set(obj, propertyName, value)\n    ```\n    - 赋值多个新属性：应该`用两个对象的属性创建一个新的对象`，新的内存地址会促使重新添加监听。\n    ```js\n    // 不要像下面这样：\n    vm.profile = Object.assign(vm.profile, { age: 27 });\n\n    // 正确的做法：使用合并对象创建一个新对象，新的内存地址会促使重新添加监听\n    vm.profile = Object.assign({}, vm.profile, { age: 27 });\n    ```\n    - 单个属性删除：\n    ```js\n    Vue.delete(obj, key)\n    vm.$delete(obj, key)\n    ```\n::: details 上述$set的原理\n- 对于数组，调用splice方法触发响应式；\n- 对于对象，通过调用`defineReactive`方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）。\n:::\n参考链接：[记一次思否问答的问题思考：Vue为什么不能检测数组变动](https://segmentfault.com/a/1190000015783546)\n:::\n\n#### 使用 Proxy 代替 Object.defineProperty\n\n参考链接：[摒弃 Object.defineProperty，基于 Proxy 的观察者机制探索](https://juejin.im/post/5bf3e632e51d452baa5f7375)\n\nQ：为什么要用Proxy代替Object.defineProperty？\n1. Object.defineProperty只能劫持对象的属性，因此需要对每个对象的每个属性进行遍历。Vue里，是通过递归遍历 data对象来实现对数据的监控的，如果属性值也是对象，那么就需要深度遍历。而Proxy能劫持一个完整的对象，不管是对操作性还是性能都是一个很大的提升。\n2. 出于性能的考虑，Vue中Object.defineProperty无法监控到数组索引改变元素，或是数组长度改变，不能实时响应，虽然Vue提供了特殊处理的8种hack数组方法（push、pop、shift、unshift、splice、sort、reverse）来改变和监听数组，但是还是有很大局限性。 而Proxy本身提供了13种劫持操作，可以解决上述问题。\n\n\nQ：为什么vue2.x不使用Proxy呢？\n- Proxy属性在vue2.x之前就有了，为什么vue2.x不使用Proxy呢？一个很重要的原因就是：Proxy是es6提供的新特性，**兼容性不好**，最主要的是这个属性无法用polyfill来兼容。\n\n## React只是一个视图库\n\nReact既不是MVC，也不是MVVM。按照Facebook的说法，React只相当于MVC中的`V`，是**一个UI视图库**。\n\n### 为什么React不是MVVM呢？\n\n- 首先要明白，MVVM最显著的特征就是`「双向绑定」`。而React没有这个，它是`单向数据绑定`的。\n- React本身只是一个函数 **UI = render(data)**，最多算一个从 `M->V` 的`单向数据流库`，其没有ViewModel这个东西，`没有所谓的状态管理`，而只是`数据到视图的驱动`。\n\n### 那React+Redux或React+Mobx之后是MVVM么？\n\n个人认为也不是的。\n*这里的叙述原因还要斟酌*\n- Q：在使用了Redux之后，Redux的store作为Model层，React作为View层，看起来是更改View层的数据就会改动到Model层的数据，那这样是不是就完成了双向的绑定呢？\n- A：其实，React(View层)中的数据 和 Redux(Model层)中的store里的数据，实际上并没有直接联系。\n    - store里的数据更改都是通过dispatch action来实现的，即，在View层向一个输入框输入，如果不进行dispatch action，Model层中的store里的数据是不会变化的，因此可以说是导致Model层中数据变化的本质是dispatch.action导致的变化，和View层并没有直接意义上的联系，不对输入框进行输入也是可以通过dispatch action来改变store里的值从而改变输入框的值。\n    - Redux也就是一种单向数据流的思想，所有的数据都在Redux下的store里，store里的数据有变化时再将数据传到View层中的React里进行重新渲染显示出新的数据。\n\n## Vue是MVVM，但不完全遵循其规则\n\n### Vue的MVVM模式对应关系\n- new Vue() 创建的实例 vm就是ViewModel；\n- el所指定的区域（包括template、style），就是vm所控制的View；\n- data状态对象以及props属性，就是vm所控制的View区域所映射的数据Model。\n```html\n<div id=\"app\">\n    <h1>{{msg}}</h1>\n</div>\n\n<script>\n// new Vue() 创建的实例 vm就是ViewModel\nconst vm = new Vue({\n    el: '#app', // el所指定的区域，就是vm所控制的View\n    data: { // data状态对象，就是vm所控制的View区域所映射的数据Model\n        msg: 'Hello, vue.'\n    }\n})\n</script>\n```\n\n### Vue没有完全遵循MVVM设计规则\n`严格的MVVM要求View不能和Model直接通信`，而Vue在组件提供了`$refs这个属性`，`让Model可以直接操作View`，违反了这一规定。\n\n> Vue官方设计 $refs 主要是提供给 js 程序访问的，并不建议在模板中过度依赖使用它。因为`这意味着在实例之外去访问实例状态`，违背了 Vue 数据驱动的思想。\n\nVue的设计虽然没有完全遵循MVVM但也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。\n\n\n## React VS Vue\n\n有许多相似之处，它们都有：\n- 使用 Virtual DOM；\n- 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件；\n- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n\n不同之处：\n- React 比 Vue 更好的地方，数据流向更清晰，有更丰富的生态系统。\n- Vue 比 React 更好的地方，门槛低，代码更少更易用。\n- :tada:**「数据驱动视图」的原理不同，造成工作方式不同：**\n    - React的工作逻辑是：state只能通过setState改变，而state变化就会执行render，即是一个单向数据流的M->V的视图库。*（如果要添加V->M反向绑定，就需要手动添加onChange事件绑定handler改变setState，重新触发render）*。React的state存在于一个个组件中，并不能叫做VM，react没有VM这个东西。\n    - Vue的工作逻辑是：通过数据劫持和发布订阅结合，实现双向绑定。Vue中不存在类似setState这种唯一改变状态变量途径的方法，而是通过vm自动为数据Model添加监听，在数据改变时调用订阅的监听回调改变View，触发render；另一方面（vue比react多做的事），在例如表单的场景下，又能通过v-model自动完成View层的事件绑定，触发数据Model的变化。即是一个双向数据绑定的MVVM库。\n    - 总得来说：React没有VM而只有组件内的状态state，只能通过唯一的setState途径去改变state，每次setState的动作会触发批处理rerender；Vue没有提供唯一动作(setState)改变状态，Vue实例就是VM，VM通过数据劫持和发布订阅，感知Model的改变后再触发视图更新rerender，而所谓的双向绑定中的反向绑定，只是在表单或自定义组件上使用v-model，来自动完成View层事件监听而已。\n\n\n## MVVM的优缺点\n### 优点\n- 分离视图（View）和模型（Model）,降低代码耦合，提高视图或者逻辑的重用性: \n    - 比如视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定不同的\"View\"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n- 提高可测试性: \n    - ViewModel的存在可以帮助开发者更好地编写测试代码。\n- 自动更新dom: \n    - 利用双向绑定,数据更新后视图自动更新,让开发者从繁琐的手动dom中解放。\n\n### 缺点\n- Bug很难被调试：\n    - 因为使用双向绑定的模式，当你看到界面异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得一个位置的Bug被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的\n- 长期持有内存：\n    - 一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存\n- 大型ViewModel的构建和维护成本：\n    - 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。\n\n"},{"title":"Nginx 相关问题","url":"/Roundtables/Question-Bank/Ops/nginx.html","content":"# Nginx 相关问题\n\n> Nginx相关问题记录\n\n----\n## 1、Nginx目录穿越漏洞\n\n常见于 Nginx 做反向代理的情况，动态的部分被 proxy_pass 传递给后端端口，而静态文件需要 Nginx 来处理。\n\n假设静态文件存储在 /home/目录下，而该目录在 url 中名字为 files ，那么就需要用 alias 设置目录的别名：\n\n```json\nlocation /files { alias /home/; }\n```\n此时，访问http://example.com/files/readme.txt， 就可以获取/home/readme.txt文件。\n\n但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录：\n\n![目录穿越](./images/WX20191024-122130.png)\n\n进而我们获得了一个任意文件下载漏洞。\n\n> 如何解决这个漏洞？\n\n只需要保证 location 和 alias 的值```都有```后缀/ 或```都没有```这个后缀。\n\n## 2、Nginx超时时间设置\n\n### 问题描述\n\n某些大数据量接口在loading一段时间后提示当前请求异常(此错误提示是前端代码给出的提示)，浏览器network中查看对应接口，显示接口status为failed，爆红，没有response体，且接口时间未1min或多一点。\n\n运维同学查日志后发现 nginx报了499 错误，\n\n> 499 是 nginx 扩展的 4xx 错误，目的只是用于记录，并没有实际的响应。\n>> 看一下 nginx 源码 ngx_http_request.h 对 499 的定义：\n\n    /*\n    * HTTP does not define the code for the case when a client closed\n    * the connection while we are processing its request so we introduce\n    * own code to log such situation when a client has closed the connection\n    * before we even try to send the HTTP header to it\n    */\n    # define NGX_HTTP_CLIENT_CLOSED_REQUEST     499\n> nginx 499 代表客户端请求还未返回时，客户端主动断开连接。\n\n### 问题解决时间线\n\n1. 因为表述为 **客户端主动断开连接**，所以团队小伙伴都以为是浏览器主动断开了连接，猜测是不是浏览器有默认超时时间。查阅相关资料后发现Chrome的默认浏览器超时时间至少是5分钟，结合问题中描述的1min，因此判断不是浏览器主动断开连接；\n\n2. 后端同学通过 postman主动调接口，通过html结构的形式，返回 `504 gateway time-out`：\n    ![](./images/nginx-499.png)\n    网关超时，且通过postman而不是浏览器，进一步说明和浏览器没有关系，不是前端的锅，汗！\n\n3. 查阅资料：\n    nginx 499 是客户端主动断开了连接。这里的客户端概念，**是对请求连接过程中的下游服务而言的**，例如`浏览器与 nginx 之间的连接，浏览器为客户端`；`nginx 与其分发的服务而言，nginx 是客户端`；php 处理程序中发起的 curl 请求而言，php-fpm 可视为客户端。\n\n    这里说客户端不一定是浏览器，有可能是nginx，因此从nginx的超时时间设置入手：\n\n    nginx 作为反向代理时，nginx 将请求分发至对应的处理服务器时，有两对超时参数的设置：`proxy_send_timeout` 和 `proxy_read_timeout` ; `fastcgi_send_timeout` 和 `fastcgi_read_timeout`。两对参数分别对应的是 ngx_http_proxy_module 和 ngx_http_fastcgi_module 模块的参数。两对参数默认的超时时间都是 60 s。在 nginx 出现 499 的情况下，可以结合请求断开前的耗时和这两对设定的时间进行对比，看一下是不是在 proxy_pass 或者 fastcgi_pass 处理时，设置的超时时间短了。\n\n    因此尝试设置为5分钟：\n    ![](./images/nginx-499-2.png)\n    但还是同样报错...\n\n4. host绑定IP，绕过安全waf，确定问题所在：\n    运维同学建议host绑定IP，发现请求没问题了，为什么这样呢？\n\n    因为前端到服务器之间，除了通过nginx转发，在此之前还要经过安全waf，`waf = web application firewall`，即是安全部门在前端到应用前面加一个防火墙，统一实施安全策略，之后再到nginx服务器，再到后端`（ 浏览器 => 安全waf => nginx服务器 => 后端服务）`：\n    ![](./images/nginx-499-3.png)\n\n    通过host绑定对应ip，绕过了安全waf，直接打到nginx服务器，就没有任何问题，因此确定是需要在waf层的nginx设置对应超时时间，解决问题。\n\n\n参考链接：[nginx 499 产生的原因](https://www.jianshu.com/p/88fb291fc1ec)\n"},{"title":"FED 座右铭","url":"/Roundtables/Question-Bank/index.html","content":"---\n{\n  \"title\": \"题库 Question-Bank\",\n}\n---\n\n## FED 座右铭\n\n::: theorem Atwood 定律\n**Any application that can be written in JavaScript, will eventually be written in JavaScript.**\n\n**凡是可以用 JavaScript 来写的应用，最终都会用 JavaScript 来写。**\n::: right\n来自 [百度百科](https://baike.baidu.com/item/%E9%98%BF%E7%89%B9%E4%BC%8D%E5%BE%B7%E5%AE%9A%E5%BE%8B/631745?fr=aladdin)\n:::\n\n## 知识结构脑图\n\n<div class=\"container\">\n <iframe  \n  height=600 \n  width=100% \n  src='https://www.processon.com/view/link/5e7831fce4b092510f6d1884'  \n  frameborder=0  \n  allowfullscreen>\n </iframe>\n  <style>\n  .container {\n    overflow: hidden;\n  }\n  </style>\n</div>\n\n## 题库目录\n\n标注：:100:完结题目，:rocket:进行中题目，:bulb:下期题目。\n\n#### 基本语法\n  - [:100:JS专题-变量与类型-(1)JS数据类型](./basic-grammar/variablesAndTypes1.md)\n  - [:100:JS专题-变量与类型-(2)JS 3种疑难基础类型](./basic-grammar/variablesAndTypes2.md)\n  - [:100:javascript数值](./basic-grammar/number)\n  - [:100:JS专题-变量与类型-(3)JS 其他引用类型](./basic-grammar/variablesAndTypes3.md)\n  - [:100:JS专题-变量与类型-(4)JS的类型转换](./basic-grammar/variablesAndTypes4.md)\n  - [:100:JS专题-变量与类型-(5)JS的类型判断方法](./basic-grammar/variablesAndTypes5.md)\n  - [:100:完美实现深拷贝](./basic-grammar/deep-clone.md)\n  - [:100:深度查询](./basic-grammar/deep-query.md)\n  - [:100:链式调用](./basic-grammar/chain-methods.md)\n  - [:100:异步函数promise化(处理回调地狱)](./basic-grammar/callback-hell.md)\n  - [指出下面代码的执行结果](./basic-grammar/type-judge.md)\n  - [:100:数组扁平化](./basic-grammar/flatten-array.md)\n  - [:rocket:一维数组中连续相同的数字转换成二维](./basic-grammar/to-2D-array.md)\n  - [:rocket:数组去重](./basic-grammar/duplicate-remove.md)\n  - [:rocket:判断数组的方法](./basic-grammar/is-array.md)\n  - [:rocket:编写函数createArray(holder, length)返回长度为length，成员都是holder的数组](./basic-grammar/create-array.md)\n  - [:rocket:奇偶打印](./basic-grammar/odd-even-print.md)\n  - [:rocket:bind方法实现](./basic-grammar/bind-implementation.md)\n  - [点击li标签打印该其所处列表次序](./basic-grammar/li-index.md)\n  - [:rocket:实现函数调用节流](./basic-grammar/debounce.md)\n  - [:rocket:实现斐波那契数列](./basic-grammar/fibonacci.md)\n  - [:100:函数式编程柯里化](./basic-grammar/curry.md)\n  - [:100:JS原生选择器](./basic-grammar/js-querySelector.md)\n  - [:bulb:JS中的奇技淫巧](./basic-grammar/js-tricks.md)\n  - [:bulb:实现回到顶部效果](./basic-grammar/back-to-top.md)\n  - [编写js，要求在给定的节点(target)上，实现鼠标移动时，跟随鼠标实时出现表示鼠标主要移动方向的文字：上/下/左/右](./basic-grammar/)\n  - [编写js，将给定的已知节点(img#icon)添加上一个包装节点(div.icon-wrapper)，要求保持该节点对象不变（即不可克隆或者破坏节点上绑定的任意属性值和事件）](./basic-grammar/)\n  - [编写js，要求编写方法，通过事件委托方式，给目标节点（target）的所有具有.btn-delete的子/孙节点绑定click事件（clickHandler）](./basic-grammar/)\n  - [编写js，要求基于localStorage实现一个具有有效期支持的本地存储对象 cookieStorage](./basic-grammar/)\n  - [编写js，实现当浏览器窗口宽度小于500时，全屏显示；大于500时，目标节点总是上下左右居中、长宽分别是整个窗口尺寸的一半；需要支持浏览器窗口尺寸任意改变，并且考虑一定的事件响应性能问题](./basic-grammar/)\n  - [编写css，实现当浏览器窗口宽度小于500时，全屏显示；大于500时，目标节点总是上下左右居中、长宽分别是整个窗口尺寸的一半](./basic-grammar/)\n  - [编写js，实现一个简单的js加载器方法，可以实现按照指定的文件顺序加载js：参数顺序即为串行加载顺序，前序加载成功方可加载下一个；如果某个参数是个数组，则需要并行加载数组中的所有指定文件](./basic-grammar/)\n  - [编写js或者css，实现对目标节点，鼠标移上去不断闪烁的动画效果（闪烁间隔500ms，类似输入时光标闪烁](./basic-grammar/)\n  - [编写js，使下面的代码可以正确运行（注：已知数组默认并没有magicMe方法](./basic-grammar/)\n  - [编写js，实现一个polyfill，用来在低版本浏览器中实现ES5中的Function.prototype.bind()的兼容](./basic-grammar/)\n  - [编写js，实现一个wait(1000, callback1).wait(3000, callback2).wait(1000, callback3)](./basic-grammar/)\n  - [编写js，实现对足球比赛的剩余人数判断](./basic-grammar/football-people)\n  - [编写css，实现iPhone手机主屏幕布局](./basic-grammar/)\n  - [:rocket:打印树形目录结构【难】](./basic-grammar/print-all-directory-file)\n\n#### 面向对象与原型链\n  - [:100:原型链](./object-oriented/prototype-chain.md)\n  - [:100:类的声明与实例](./object-oriented/class-declaration.md)\n  - [:100:类与继承](./object-oriented/class-extends.md)\n\n#### JS的执行机制\n  - [:100:JS的解释器过程](./execution/interpreter.md)\n  - [:100:运行JS](./execution/context.md)\n  - [:100:任务队列与Event-Loop](./execution/event-loop.md)\n  - [:100:异步编程（1）：回调函数](./execution/asynchronous-cb.md)\n  - [:100:异步编程（2）：Promise对象](./execution/asynchronous-promise.md)\n  - [:100:异步编程（3）：Generator函数](./execution/asynchronous-gen.md)\n  - [:100:异步编程（4）：async、await](./execution/asynchronous-async&await.md)\n  - [:100:深入javascript运行机制--部分](./execution/深入javascript运行机制--部分.md)\n\n#### css相关\n  - [:100:多种方式实现三栏布局](./css/layout-3-col.md)\n  - [:rocket:元素居中方法总结](./css/layout-block-center.md)\n  - [:100:盒模型 & 外边距重叠 & BFC](./css/box-sizing&margin-collapse&BFC.md)\n  - [:100:CSS中的定位机制](./css/layout-method.md)\n  - [:100:CSS 基础属性](./css/css-base.md)\n  - [使用scss编写代码，快速创建100条规则](./css.md)\n  - [使用css3编写loading动画](./css.md)\n  - [编写css实现图示中多列分栏布局](./css.md)\n  - [:rocket:移动端响应式适配方案](./css/flexible.md)\n  - [:bulb:样式布局中的奇技淫巧](./css-tricks.md)\n\n#### HTML & DOM\n  - [:100:DOM事件基本概念](./dom/dom-event.md)\n  - [尽可能使用语义化标签给出符合图示的html定义](./dom/)\n  - [编写html注册表单](./dom/)\n  - [设置节点的class](./dom/)\n  - [:bulb:交换两个节点位置](./dom/)\n  - [找出给定DOM节点下所包含的的html标签种类和数量](./dom/)\n  - [实现鼠标在指定节点上移动时，在鼠标位置跟随打印当前时间戳](./dom/)\n  - [通过事件委托实现对1w个按钮绑定点击事件](./dom/)\n\n#### BOM\n  - [:100:BOM对象基础（五大对象）](./bom/bom-base.md)\n  - [:100:前端路由模式](./bom/router.md)\n\n#### 通信\n  - [:100:HTTP 协议](./communication/http.md)\n  - [:100:网络基础](./communication/internet-base.md)\n  - [:100:跨域通信与同源策略](./communication/cross-domain.md)\n  - [:100:CORS 跨域资源共享](./communication/cors.md)\n  - [:100:文件上传实现](./communication/upload.md)\n  - [:100:文件下载实现](./communication/download.md)\n  - [:100:关于Json](./communication/json.md)\n  - [:bulb:关于axios的使用](./communication/axios.md)\n\n#### 浏览器及前端性能\n  - [:100:浏览器工作原理](./browser/browser-mechanism.md)\n  - [:100:浏览器渲染](./browser/render.md)\n  - [:100:提升页面性能的方法](./browser/performance.md)\n  - [:100:从多线程到Event Loop全面梳理](./browser/process-eventloop.md)\n  - [:100:简述输入URL到页面显示全过程](./browser/from-url-input.md)\n  - [:100:from memory cache 与 from disk cache](./browser/memory-or-disk-cache.md)\n\n#### 网络安全\n  - [:100:前端常见安全问题](./security/fe-security.md)\n\n#### 正则表达式\n  - [:100:正则表达式基础](./regular-expression/reg-base.md)\n  - [:100:正则表达式实现大驼峰字符串转换](./regular-expression/upper-camel-case.md)\n  - [:100:使用正则判断给定的股票代码所属市场](./regular-expression/code-to-market.md)\n  - [:100:使用正则验证给定字符串是否是中国居民身份证](./regular-expression/Chinese-ID-card.md)\n\n#### 工程化\n  - [:100:JS模块化规范(5种)](./Engineering/js-module/)\n  - [:100:CSS命名风格规范](./Engineering/css-naming-standard.md)\n  - [:100:代码管理风格规范](./Engineering/repo-naming-standard.md)\n  - [:100:JS常见设计模式](./Engineering/design-patterns.md)\n\n#### ES6+\n  - [:100:ES6相比于ES5有什么不同](./ES6+/ES6)\n  - [:bulb:ES6类语法中，三种类成员方法有什么区别](./ES6+/class-method)\n\n#### TypeScript\n  - [:100:TypeScript学习笔记](./typescript/typescript-base.html)\n  - [:100:ts与js的区别？ts的优势是什么？](./typescript/typescript-base.html#ts定义)\n  - [:100:数组与元祖tuple有什么区别？元祖越界元素的类型有什么限制？](./typescript/typescript-base.html#元组-tuple)\n  - [:100:ts中的基础类型有哪些？](./typescript/typescript-base.html#原始数据类型)\n  - [:100:ts中string与String有什么区别？](./typescript/typescript-base.html#ts中string与string有什么区别？)\n  - [:100:void、never、any、unknow有什么区别？string可以赋予前面提到的四种类型吗？](./typescript/type-difference)\n  - [:100:联合类型union与交叉类型intersection有什么区别？](./typescript/typescript-base.html#高级类型1-联合类型（-：union-types）)\n  - [:100:类型断言type assert与类型保护type guards有什么区别？](./typescript/typescript-base.html#区分类型1-类型断言)\n  - [:100:什么是泛型？有什么好处？](./typescript/typescript-base.html#泛型)\n  - [:100:什么是类型兼容？](./typescript/ts-compatibility.md)\n\n\n#### 框架基础\n  - [MVVM框架基础](./MVVM/mvvm-base.md)\n\n#### React\n  - [:100:Element、Component、Node、Instance如何区分？](./react/element-component-instance-node)\n  - [:100:无状态组件](./react/SFC.md)\n  - [:100:react中的Component和PureComponent有什么区别？](/./react/SFC.html#purecomponent-vs-component)\n  - [:100:react类组件中处理this绑定的4种方法](./react/react-handle-this.md)\n  - [:100:根据要求定义react组件 Student](./react/Student)\n  - [:100:React-Router使用关键点](./react/react-router-dom.md)\n  - [:rocket:给出基于react-router的路由定义](./react/declare-react-router)\n  - [编写时间打印组件](./react/time-console)\n  - [:rocket:React组件分类（不同角度）](./react/component-classify.md)\n  - [:rocket:React中的代码复用（Render-Props、HOC）](./react/react-reuse.md)\n  - [:rocket:编写react高阶组件实现时间显示组件随时间不断更新 withClock](./react/withClock.md)\n  - [:100:React 生命周期](./react/lifecycle)\n  - [:100:JSX 语法](./react/jsx-render)\n  - [:100:React事件机制](./react/react-event.md)\n  - [:100:setState的执行机制](./react/setState.md)\n  - [:100:React虚拟DOM相关](./react/react-virtual-dom.md)\n  - [:100:React Refs相关](./react/refs.md)\n  - [:100:关于props.children的一切](./react/children.md)\n  - [:100:React Fiber](./react/fiber.md)\n  - [:bulb:React未归类知识点补充](./react/react-other-points.md)\n  - [:100:React Hooks 概述](./react/react-hooks.md)\n  - [:100:Function VS Class 组件（最大区别 - Capture Value）](./react/function-vs-class.md)\n  - [:rocket:React Hooks 使用技巧](./react/black-magic-of-hooks.md)\n  - [react-transition-group的Transition/CSSTransition实现原理是什么？](./react/)\n  - [react-transition-group的TransitionGroup实现原理是什么？](./react/)\n  - [请列举不少于10个ant-design用过的组件](./react/)\n\n#### Vue\n  - [:100:Vue框架基础](./vue/vue-base)\n  - [:100:vue-router路由](./vue/vue-router)\n  - [:100:Vuex状态管理](./vue/vuex.md)\n  - [:100:自定义组件实现v-model的双向绑定](./vue/customized-v-model)\n  - [:100:$listeners & $attrs](./vue/listeners-and-attrs)\n  - [:100:编写自定义指令，实现动态列表加载](./vue/v-loadmore)\n  - [:100:实现可搜索可分片加载的select组件](./vue/v-search-select)\n  - [:100:关于ElementUI的无限滚动](./vue/v-infinite-scrol)\n  - [根据要求定义vue组件 Student](./vue/Student)\n\n#### Nodejs\n  - [:100:EventEmitter实现](/Roundtable/Question-Bank/nodejs/eventEmitter)\n  - [:100:Node模块机制的实现](/Roundtable/Question-Bank/nodejs/Node模块机制的实现)\n\n#### 包管理\n  - [:100:package.lock.json](/Roundtable/Question-Bank/pkgmanage/package.lock.json)\n  - [简述npm是什么](/Roundtable/Question-Bank/basic-grammar/)\n  - [npm和yarn的区别](/Roundtable/Question-Bank/basic-grammar/)\n  - [什么是语义化版本控制？有什么好处？](/Roundtable/Question-Bank/basic-grammar/)\n  - [npm包的^ ~有什么区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [1.0.0-alpha、1.0.0、1.0.0-alpha.1、1.0.0-beta的先后顺序是什么？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何快速生成package.json文件](/Roundtable/Question-Bank/basic-grammar/)\n  - [package中的dependencies、devDepencdencies、peerDependencies有什么区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何安装一个依赖包信息到devDependencies中？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何查询一个包是否存在、如何搜索依赖包？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何查看本地安装的依赖包？](/Roundtable/Question-Bank/basic-grammar/)\n  - [@next @beta @latest 和@x.x.x 等有什么区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [@babel/core这种基于scope的包管理方式相比于babel-core有何优势？](/Roundtable/Question-Bank/basic-grammar/)\n\n#### 运维相关\n  - [:100:Nginx相关问题](/Roundtable/Question-Bank/Ops/nginx)\n\n#### 工作实践\n  - [:100:如何保证产品质量](/Roundtable/Question-Bank/work-practices/product-quality)\n  - [:100:前端工程化部署方案](/Roundtable/Question-Bank/work-practices/deploy)\n  - [:100:ElementUI Message 二次封装](/Roundtable/Question-Bank/work-practices/eleMessage)\n  - [:100:Mobx 使用踩坑记录](/Roundtable/Question-Bank/work-practices/mobx-cases)\n  - [:100:异步请求中打开新窗口拦截问题](/Roundtable/Question-Bank/work-practices/windowInject)\n  - [:100:vue css中/deep/深度选择](/Roundtable/Question-Bank/work-practices/deepcss)\n  - [:100:团队代码质量：eslint+husky+prettier+lint-staged](/Roundtable/Question-Bank/work-practices/eslintPrettier)\n  - [:100:前端多语言方案实现总结](/Roundtable/Question-Bank/work-practices/i18n)\n\n\n#### Webpack\n  - [关于babel](./webpack/babel.md)\n  - [代码分割技术](./webpack/code-splitting.md)\n  - [:bulb:列举不少于5个loader,要求简述其作用和使用](/Roundtable/Question-Bank/basic-grammar/)\n  - [:bulb:列举不少于5个plugin，要求简述其作用和使用](/Roundtable/Question-Bank/basic-grammar/)\n  - [style-loader css-loader scss-loader有什么区别，他们的调用顺序是什么？](/Roundtable/Question-Bank/basic-grammar/)\n  - [webpack配置中的entry属性有哪几种配置方式？](/Roundtable/Question-Bank/basic-grammar/)\n  - [webpack配置中的output下的，path和publicPath分别什么作用？](/Roundtable/Question-Bank/basic-grammar/)\n  - [webpack的输出中，hash和chunkhash有什么区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如果想在项目中无需导入模块即可全局使用jQuery的$，需要如何配置webpack？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如果项目中某些模块所属目录路径特别深(../../../../compoennts/User)，如何使用webpack配置优化？](/Roundtable/Question-Bank/basic-grammar/)\n  - [webpack如何抽取公共chunk?(回答webpack3或者4都可以)](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何配置webpack，以更好的支持持久化缓存（caching）](/Roundtable/Question-Bank/basic-grammar/)\n  - [什么是tree shaking？](/Roundtable/Question-Bank/basic-grammar/)\n  - [webpack4的splitChunks的主要用法是什么？](/Roundtable/Question-Bank/basic-grammar/)\n  - [列举webpack可以配置哪几种devTool来控制souceMap的输出？他们的性能如何？](/Roundtable/Question-Bank/basic-grammar/)\n  - [列举webpack的插件系统有哪些勾子？如何编写一个webpack插件？](/Roundtable/Question-Bank/basic-grammar/)\n  - [babel-core和babel-cli的区别](/Roundtable/Question-Bank/basic-grammar/)\n  - [babel的preset和plugin有什么区别](/Roundtable/Question-Bank/basic-grammar/)\n  - [列举babel的常用插件](/Roundtable/Question-Bank/basic-grammar/)\n  - [简述babel的实现原理是什么](/Roundtable/Question-Bank/basic-grammar/)\n  - [列举ES6+中哪些特性可以使用babel实现哪些不可以？](/Roundtable/Question-Bank/basic-grammar/)\n\n\n#### Git\n  - [常用的git命令有哪些](/Roundtable/Question-Bank/basic-grammar/)\n  - [commit、stash、push有啥区别、fetch和pull有啥区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [谈谈git的工作区（workspace）、暂存区(stash)、仓库（repos）、远程仓库（remote repos）](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何查看本地/远程分支、如何新建、删除分支？](/Roundtable/Question-Bank/basic-grammar/)\n  - [rebase和merge有啥区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [reset和revert的区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [谈谈对branch和tag的区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [git如何配置提交人信息？](/Roundtable/Question-Bank/basic-grammar/)\n  - [平常是如何在项目中使用git的？你们在使用/知道的git工作流是什么/有哪些](/Roundtable/Question-Bank/basic-grammar/)\n  - [项目代码commit msg有没有约定一些书写规范？在用/知道的git commit msg规范有哪些](/Roundtable/Question-Bank/basic-grammar/)\n  - [谈谈如何使用git进行多人协作开发](/Roundtable/Question-Bank/basic-grammar/)\n\n#### ESLint\n  - [项目中在用的提高代码质量的工具都有哪些](/Roundtable/Question-Bank/basic-grammar/)\n  - [html、css、js的代码检查工具都有哪些](/Roundtable/Question-Bank/basic-grammar/)\n  - [eslint的作用是什么，用来解决什么问题](/Roundtable/Question-Bank/basic-grammar/)\n  - [eslint如何开启或关闭对当前文件的检查（对当前行的检查）](/Roundtable/Question-Bank/basic-grammar/)\n  - [eslint如何配置全局变量的支持？](/Roundtable/Question-Bank/basic-grammar/)\n  - [eslint可以重读哪些配置文件？读取配置文件的优先级是什么？](/Roundtable/Question-Bank/basic-grammar/)\n  - [列举eslint的哪些rules是可以通过--fix命令修复的？](/Roundtable/Question-Bank/basic-grammar/)\n\n#### PWA\n  - [什么是PWA？](/Roundtable/Wanted/pwa)\n  - [什么是service worker？什么是web worker？](/Roundtable/Wanted/pwa)\n  - [pwa和react-native、flutter、weex等有何区别？各自优势是什么？](/Roundtable/Question-Bank/cross-platform/)\n\n#### 待分类\n  - [prefetch和preload是指什么？二者的区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [async和defer是指什么？二者的区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [es module中默认导出和子导出有何区别？](/Roundtable/Question-Bank/basic-grammar/)\n  - [es module中的as语法有什么作用？](/Roundtable/Question-Bank/basic-grammar/)\n  - [为什么promise的回调异步会比setTimeout优先执行？](/Roundtable/Question-Bank/basic-grammar/)\n  - [es6中的async/await语法如何捕获rejected状态？](/Roundtable/Question-Bank/basic-grammar/)\n  - [es6中的proxy、reflect可以用来做什么？](/Roundtable/Question-Bank/basic-grammar/)\n  - [es6中的proxy和defineProperty在数据拦截方面有什么异同点？](/Roundtable/Question-Bank/basic-grammar/)\n  - [:rocket:application/x-www-form-urlencoded、multipart/form-data、json、xml四种主流post数据的编码方式有何区别、各自有什么优劣？](/Roundtable/Question-Bank/basic-grammar/content-type)\n  - [举例js中常见的设计模式有哪些？](/Roundtable/Question-Bank/basic-grammar/)\n  - [如何设计实现类似jQuery的链式调用？](/Roundtable/Question-Bank/basic-grammar/)\n  - [请简述设计实现用户头像上传预览功能大概实现思路](/Roundtable/Question-Bank/basic-grammar/)\n  - [请简述实现前端路由功能的所涉及到的技术和思路](/Roundtable/Question-Bank/basic-grammar/)\n  - [请简述实现模态框的思路](/Roundtable/Question-Bank/basic-grammar/)\n  - [请简述实现slider/swiper效果的思路](/Roundtable/Question-Bank/basic-grammar/)\n  - [请简述如何对多图片页面实现lazyload的思路](/Roundtable/Question-Bank/basic-grammar/)\n  - [为什么静态资源要使用cdn，其好处是什么？](/Roundtable/Question-Bank/basic-grammar/)\n\n"},{"title":"实现回到顶部效果","url":"/Roundtables/Question-Bank/basic-grammar/back-to-top.html","content":"# 实现回到顶部效果\n\n原生js返回顶部\n## a标签锚点定位\n`<a>`标签锚点定位，这是最简单的。（a标签的href属性等于要到达位置元素的id值，或使用a标签本身的name属性查找）\n```html\n<body>\n    <!-- 设置锚点 -->\n    <a href=\"#mark-1\">跳转到区域一</a><br>\n    <a href=\"#mark-2\">跳转到区域二</a>\n    <br><br><br><br><br><br><br><br><br><br><br><br> <br><br><br><br><br><br><br><br><br><br><br><br>\n    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>\n     <div id=\"mark-1\">区域一</div>\n     <!-- 如果要测试name效果，可以注销上面一段，然后点击锚点mark-2跳转到区域二 -->\n     <a href=\"\"  name=\"mark-2\"></a><div>区域二</div>\n</body>\n```\n上面只是跳转同一页面，如果要跳到另一个页面的锚点目标，就需要先跳转页面。例如a.html跳到b.html中，在a.html这样设置锚点：\n```html\n<a href=\"b.html#mark\">跳到b页面</a>\n```\n\n\n## 根节点设置scrollTop为0。\njs直接设置，也无动画效果不好，注意兼容写法：\n```js\n// 兼容写法\ndocument.body.scrollTop = 0；\ndocument.documentElement.scrollTop = 0; \n```\n\n\n## 设置动画效果\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n        li { height: 100px;border-bottom: 1px solid #ccc; }\n        #toTop {display: none;position: fixed;right: 20px;bottom: 20px; background: #ccc; border-radius: 5px;padding: 10px 15px;}\n    </style>\n</head>\n<body>\n    <div class=\"demo\" style=\"height: 2000px;\">\n        <ul>\n            <li>demo1</li>\n            <li>demo2</li>\n            <li>demo3</li>\n            <li>demo4</li>\n            <li>demo5</li>\n            <li>demo6</li>\n            <li>demo7</li>\n            <li>demo8</li>\n            <li>demo9</li>\n            <li>demo10</li>\n        </ul>\n    </div>\n    <div id=\"toTop\">back</div>\n</body>\n</html>\n\n<script>\n　　 //  匀速返回 （定时器开启前速度已经计算好）\n    var toTop = document.querySelector('#toTop')\n    toTop.onclick = function(){\n        var dom = document.querySelector('body');\n        var h = dom.scrollTop;\n        var subH = parseInt(h / 50);\n        var timer = setInterval(function(){\n            h -= subH;\n            if(h <= 0){\n                dom.scrollTop = 0;\n                clearInterval(timer);\n            }else{\n                dom.scrollTop = h;\n            }\n        },1)    \n    }\n    window.onscroll = function(){\n        if(window.pageYOffset>300){\n            toTop.style.display = \"block\";\n        }else{\n            toTop.style.display = \"none\";\n        }\n    }\n</script>\n<script>\n// 以下是变速效果\nfunction goTop() {\n　　// 由快到慢  （每次开启定时器都重新计算速度）\n    timer = setInterval( function(){\n        //获取滚动条的滚动高度\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n        //用于设置速度差，产生缓动的效果\n        var speed = Math.floor(-scrollTop / 8);\n        document.documentElement.scrollTop = document.body.scrollTop = scrollTop + speed;//用纯数字赋值\n        isTop =true;  //用于阻止滚动事件清除定时器\n        if(scrollTop == 0){\n            clearInterval(timer);\n        }\n    },50 );\n}\n</script>\n```\n\n\n"},{"title":"bind方法实现","url":"/Roundtables/Question-Bank/basic-grammar/bind-implementation.html","content":"---\ntitle: bind方法实现\ndate: 2019-01-14 10:30:00\ntags: [js, 算法]\ncategories: javascript\n---\n\n# bind方法实现\n\n> bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。bind的作用与call和apply相同，区别是call和apply是立即调用函数，而bind是返回了一个函数，需要调用的时候再执行。\n\n> 要求实现Function.prototype.bind方法（注意，该方法要求实现到函数对象原型上，并且支持额外参数传递）\n\n## johninch\n\n### call、apply、bind的区别\n- func.call(thisValue, arg1, arg2, …)：可以理解为在thisValue的作用域内应用func， arg1, arg2是可以传入的参数。\n- func.apply(thisValue, [arg1, arg2, …])：apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。\n- func.bind(thisValue, arg1, arg2,…)：bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。\n\n### 模拟实现bind的关键点是如下几点：\n1. `返回一个函数`；\n2. `可以分开传入参数`: 函数需要传name和age两个参数，竟然还可以在bind的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数age。\n```js\nvar foo = {\n  value: 1\n}\nfunction bar(name, age) {\n  console.log(this.value)\n  console.log(name)\n  console.log(age)\n}\n\nvar bindFoo = bar.bind(foo, 'Amy')\nbindFoo('26')\n// 1\n// Amy\n// 26\n```\n3. `实现构造函数`效果：当bind返回的函数作为构造函数的时候，把原函数当成构造器，bind时指定的this值会失效，但传入的参数依然生效。\n\n### 只实现“返回函数”和“分开传入参数”\n```js\nFunction.prototype._bind = function(ctx) {\n    const args = Array.prototype.slice.call(arguments, 1);\n    let self = this;\n\n    return function() {\n        // 注意这里的arguments是指_bind返回的函数所接收的参数\n        const bindArgs = Array.prototype.slice.call(arguments);\n        self.apply(ctx, args.concat(bindArgs));\n    }\n}\n```\n### 完全模拟实现3条规则\n```js\nFunction.prototype._bind = function(ctx) {\n    const args = Array.prototype.slice.call(arguments, 1);\n    let self = this;\n\n    let result = function() {\n        const bindArgs = Array.prototype.slice.call(arguments);\n        self.apply(this instanceof self ? this : ctx, args.concat(bindArgs));\n    }\n\n    let tmp = function () {}\n\n    tmp.prototype = this.prototype;\n    result.prototype = new tmp();\n\n    return result;\n}\n```\n> - 当_bind作为构造函数时，`this instanceof self`中的this指向实例，self指向绑定的原函数，此时判断条件为`true`，_bind指定的上下文ctx应失效，而应该是this；\n> - 当_bind作为普通函数时，`this instanceof self`中的this指向window，self指向绑定的原函数，此时判断条件为`false`，_bind指定的上下文对象ctx应成立；\n> - 在return前，需要`修改返回函数的原型对象为绑定函数（原函数）的原型对象`，从而`实现实例继承原函数的原型`；\n> - 但有个问题，如果直接赋值会导致修改返回函数的prototype时，原函数的原型对象也会被改变，因此使用一个`中间的函数做中转`；\n\n## superwyk\n### 方法一\n```js\n// es5 实现\nFunction.prototype.bind = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const context = args[0];\n    args.splice(0, 1);\n    const _this = this;\n    return function () {\n        const newArgs = args.concat(Array.prototype.slice.call(arguments));\n        console.log(context, args, arguments, newArgs)\n        return _this.apply(context, newArgs);\n    }\n}\n```\n\n### 方法二\n```js\n// es6 实现\nFunction.prototype.bind = function (...args) {\n    const [context, ...rest] = args;\n    const _this = this;\n    return function (...additionArgs) {\n        const newArgs = [...rest, ...additionArgs];\n        return _this.apply(context, newArgs);\n    }\n}\n```\n\n## mtd\n### 模拟实现apply\n\n```js\nFunction.prototype._apply = function(ctx) {\n  const context = ctx || window;\n  const fn = Symbol();\n\n  // 首先要获取调用call的函数，用this可以获取\n  context[fn] = this;\n  var args = arguments[1]; //获取传入的数组参数\n  if (!args) {\n    return context[fn]();\n  }\n  let value = context[fn](...args);\n  delete context[fn];\n\n  return value;\n};\n```\n\n### 模拟实现call\n\n```js\nFunction.prototype._call = function(context) {\n  // [].shift._apply(arguments) 拿到第一个参数\n  return this._apply(([].shift._apply(arguments)), arguments)\n};\n```\n\n### 模拟实现bind\n\n```js\nFunction.prototype._bind = function (context) {\n  let me = this;\n\n  let args = Array.prototype.slice._call(arguments, 1);\n\n  /**\n   * bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数，\n   * bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数\n   *\n   */\n  let F = function () {};\n  F.prototype = this.prototype;\n\n  let bound = function () {\n    let innerArgs = Array.prototype.slice._call(arguments);\n    let finalArgs = args.concat(innerArgs);\n    return me._apply(this instanceof F ? this : context || this, finalArgs);\n  };\n\n  bound.prototype = new F();\n  return bound;\n};\n```\n\n### 使用\n```js\nlet obj = {\n  name: \"xiaohong\",\n  sayHello: function (age) {\n    console.log(this.name, age);\n  }\n};\n\nlet ming = {\n  name: \"xiaoming\",\n};\n\nobj.sayHello._apply(ming, [23]);  // xiaoming 23\nobj.sayHello._call(ming, 23);  // xiaoming 23\n\nlet fn = obj.sayHello._bind(ming, 23);\nfn();       // xiaoming 23\n\nlet bound = new fn();  // undefined 23\n```\n\n## Caleb\n\n``` js\nFunction.prototype.newBind = function(context) {\n  var self = this,\n      args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    var newArg = Array.prototype.slice.call(arguments);\n    return self.apply(context, args.contact(newArg))\n  }\n}\n\n```\n\n## Wlxm\n\n```js\nfunction bind(fn: Function, ctx: any, ...bindArgs: any) {\n    return function(...args: any) {\n        return fn.call(ctx, ...bindArgs, ...args);\n    }\n}\n```"},{"title":"解决回调地狱","url":"/Roundtables/Question-Bank/basic-grammar/callback-hell.html","content":"### 解决回调地狱\n\n> 解决回调地狱：实现一个函数，可以将异步函数转化成promise函数。\n\n<details>\n<summary>例子</summary>\n例如：```node```中```fs```模块的读文件```API```: ```fs.readFile(path[, options], callback)```；写文件```fs.writeFile(path[, options], callback)```。\n\n当我们要对a.txt文件进行读取，写入'hello world'，再读取b.txt并将b.txt内容追加到a.txt：\n**调用原生API写法如下：**\n```js\nimport * as fs from 'fs';\n\n// 读取\nfs.readFile('a.txt', (error, data) => {\n    if (error) {\n        console.error(error);\n\n        throw error;\n    }\n\n    console.log(data);\n    const dataBuffer = new Uint8Array(Buffer.from('hello world'));\n\n    fs.writeFile('a.txt', dataBuffer, error => {\n        if (error) {\n            console.error(error);\n\n            throw error;\n        }\n\n        fs.readFile('b.txt', (error, data) => {\n            if (error) {\n                console.error(error);\n\n                throw error;\n            }\n\n            fs.writeFile('a.txt', data, error => {\n                if (error) {\n                    console.error(error);\n\n                    throw error;\n                }\n                // 如果...\n            })\n        })\n    })\n})\n```\n**将API封装程Promise后到写法如下：**\n```js\nimport * as fs from 'fs';\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\n(async () => {\n   try {\n        let data = await readFile('a.txt');\n\n        console.log(data);\n\n        const dataBuffer = new Uint8Array(Buffer.from('hello world'));\n\n        await writeFile('a.txt', dataBuffer);\n\n        data = await readFile('b.txt');\n\n        await writeFile('a.txt', data);\n   } catch (error) {\n       console.error(error);\n   }\n})()\n```\n</details>\n\n----\n\n#### 推荐答案:\n\n```js\nconst promisify = fnWithCallback =>\n    (...args) => new Promise((resolve, reject) =>\n        fnWithCallback(\n            ...args,\n            (err, result) => err ? reject(err) : resolve(result)\n        )\n    )\n```\n\n----\n\n<details>\n<summary>febcat:</summary>\n\n```javascript\nconst promisify = fuc => (file, dataBuffer) =>\n  new Promise(resolve =>\n    if (dataBuffer) { // write\n      fuc(file, dataBuffer, err => {\n        if(err) {\n          console.log('write error', err)\n\n          throw error\n        } else resolve()\n      })\n    } else { // reade\n      fuc(file, (err, data) => {\n        if (err) {\n          console.log('read error', err)\n\n          throw error\n        } else resolve(data)\n      })\n    }\n  )\n```\n</details>\n\n<details>\n<summary>Xmtd:</summary>\n\n```js\nlet promisify = function (fn) {\n    return function (...args) {\n        return new Promise((resolve, reject) => {\n            fn(...args, (error, data) => {\n                if (error) {\n                    reject(error);\n                }\n                resolve(data);\n            })\n        })\n    }\n};\n```\n\n</details>\n\n<details>\n<summary>niannings:</summary>\n\n```js\nconst promisify = fnWithCallback =>\n    (...args) => new Promise((resolve, reject) =>\n        fnWithCallback(\n            ...args,\n            (err, result) => err ? reject(err) : resolve(result)\n        )\n    )\n```\n</details>\n"},{"title":"链式调用实现","url":"/Roundtables/Question-Bank/basic-grammar/chain-methods.html","content":"---\n{\n  \"title\": \"链式调用实现\",\n}\n---\n\n### 链式调用实现\n\n> 实现类似Jquery的链式调用\n> 例如：$('div').addClass('add-class')\n\n----\n\n#### 推荐答案:\n\n```js\n  let jq = function (selector) {\n    return new jq.prototype.init(selector);\n  };\n\n  jq.prototype.init = function (selector) {\n    this.el = document.querySelector(selector);\n\n    return this;\n  };\n\n  jq.prototype.on = function (name, fn) {\n    this.el.addEventListener(name, fn);\n\n    return this;\n  };\n  jq.prototype.attr = function (name, value) {\n    if (!value) {\n      return this.el.getAttribute(name);\n    } else {\n      this.el.setAttribute(name, value);\n      return this;\n    }\n  };\n  jq.prototype.init.prototype = jq.prototype;\n\n  // jq('#test').on('click', function () {}).attr('title', '1111')\n```\n\n----\n<details>\n<summary>johninch:</summary>\n\n- 原理：其实链式调用就是让一个类的每个方法都返回this值，从而达到链式调用；\n- 步骤：首先创建一个构造函数，把那些元素作为数组保存在一个实例属性中，并把所有定义在构造器函数上的prototype属性指向对象中的方法都返回用以调用方法的那个实例的引用，那么它就具有了进行链式调用的能力。\n\n```js\nfunction JQuery(selector) {\n    this.elements = document.querySelectorAll(selector);\n}\n\nJQuery.prototype = {\n    eq: function(index) {\n        this.elements = [this.elements[index]]\n        return this;\n    },\n    css: function(prop, value) {\n        this.elements.forEach(function(el) {\n            // 动态设置属性\n            el.style[prop] = value;\n        })\n        return this;\n    },\n    show: function() {\n        this.css('display', 'block')\n        return this;\n    },\n}\n\nwindow.$ = function(selector) {\n  return new JQuery(selector);\n}\n\n$('div').eq(0).css('width', '200px').show();\n```\n这段代码很明显在prototype上的三个函数都返回了this，在函数中实现对应的功能也是直接使用this来获取值，然后修改this中的值再返回this，这样在下次调用的时候还是JQuery对象，从而实现了链式调用。既然函数都是在原型链上，那么肯定需要创建一个对象才能去调用函数吧，而我们并没看到new JQuery，而且也没有看见$符号，那怎么才能使用呢。\n\n说到链式调用，还能想到curry：\n```js\nfunction add(num){\n    var sum = 0\n    sum = sum + num\n    var tempFun = function(numB) {\n        if(arguments.length === 0) {\n            return sum\n        } else {\n            sum = sum + numB\n            return tempFun\n        }\n\n    }\n\n    tempFun.valueOf = function() {\n        return sum\n    }\n    tempFun.toString = function() {\n        return sum + ''\n    }\n\n    return tempFun\n}\n```\n[相关链接](https://segmentfault.com/q/1010000004342477)\n\n</details>\n\n<details>\n<summary>febcat:</summary>\n\n```javascript\nclass Chain {\n    constructor() {\n      this.dom = null\n      this.fontColor = '#000'\n      this._init()\n    }\n\n    _init() {\n      window.$ = this._$.bind(this)\n    }\n\n    _$(tagName) {\n      if (!tagName) {\n        console.error('Chain: tagName not found')\n        return\n      }\n\n      const newDom = document.createElement(tagName)\n\n      newDom.style.color = this.fontColor\n      newDom.style.width = 100 + 'px'\n      newDom.style.height = 100 + 'px'\n      this.dom = newDom\n\n      return this\n    }\n\n    _setColor(c) {\n      this.dom.style.color = this.fontColor =  c\n\n      return this\n    }\n\n    _getColor() {\n      return this.fontColor\n    }\n\n    color(c) {\n      return c ? this._setColor(c) : this._getColor()\n    }\n\n    show() {\n      document.querySelector('body').appendChild(this.dom)\n\n      return this\n    }\n  }\n\n  new Chain()\n  console.log('------ chain ------')\n  console.log('chain=> show ', $('div').color('green').background('#000').show())\n  console.log('chain=> color ', $('div').color())\n\n```\n</details>\n\n<details>\n<summary>Caleb:</summary>\n\n``` javascript\nvar $ = function(id) {\n\tvar dom = document.getElementById(id);\n\treturn new $2(dom);\n}\n\nvar $2 = function(dom) {\n\tthis.dom = dom\n};\n\n$2.prototype = {\n\taddClass : function(className){\n\t\tif(this.dom){\n\t\t\tthis.dom.setAttribute('class', className)\n\t\t}\n\t\treturn this\n\t}\n}\n\n$('div').addClass('ppp')\n\n```\n</details>\n\n<details>\nsdfsdfsdf\n<summary>Xmtd:</summary>\n\n```js\n  let jq = function (selector) {\n    return new jq.prototype.init(selector);\n  };\n\n  jq.prototype.init = function (selector) {\n    this.el = document.querySelector(selector);\n\n    return this;\n  };\n\n  jq.prototype.on = function (name, fn) {\n    this.el.addEventListener(name, fn);\n\n    return this;\n  };\n  jq.prototype.attr = function (name, value) {\n    if (!value) {\n      return this.el.getAttribute(name);\n    } else {\n      this.el.setAttribute(name, value);\n      return this;\n    }\n  };\n  jq.prototype.init.prototype = jq.prototype;\n\n  // jq('#test').on('click', function () {}).attr('title', '1111')\n```\n</details>\n\n<details>\n<summary>niannings:</summary>\n\n```js\n/**\n * 将一个对象转化为可链式调用的对象\n * @param {object} obj 对象\n*/\nconst chainify = obj =>\n  new Proxy(Object(obj), {\n    get(o, p, r) {\n      if (typeof o[p] === 'function') {\n        return (...args) => {\n          o[p](...args);\n\n          return r\n        }\n      }\n\n      return Reflect.get(o, p, r);\n    }\n  });\n\n// 测试\nconst a = {\n  p: 100,\n  foo() {\n    console.log(1)\n  },\n  bar(x) {\n    console.log(x + this.p)\n  }\n}\n\nchainify(a).foo().bar(100)\n```\n</details>\n"},{"title":"HTTP content-type类型","url":"/Roundtables/Question-Bank/basic-grammar/content-type.html","content":"---\ntitle: content-type.md\ndate: 2019-12-12 17:21:04\ntags: [http]\n---\n# HTTP content-type类型\n\n- application/json\n\n\n- multipart/form-data (Multipart 类型)\nFormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据。其主要用于发送表单数据；\n``` js\nvar formData = new FormData();\nformData.append(\"username\", \"Groucho\");\nformData.append(\"accountnum\", 123456); //数字123456会被立即转换成字符串 \"123456\"\n\n// HTML 文件类型input，由用户选择\nformData.append(\"userfile\", fileInputElement.files[0]);\n\n// JavaScript file-like 对象\nvar content = '<a id=\"a\"><b id=\"b\">hey!</b></a>'; // 新文件的正文...\nvar blob = new Blob([content], { type: \"text/xml\"});\n\n请求体\ntitle: 122\ncorporation_id: 201\ndetail_url: esop/fRwhNbrD7D8.pdf\nemployees: (binary)\n```\n<strong>formData只能接受file、blob及string类型</strong>\n\n- application/x-www-form-urlencoded\n数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值. 非字母或数字的字符会被 编码: 这也就是为什么这种类型不支持二进制数据(应使用 multipart/form-data 代替).\n``` js\nPOST / HTTP/1.1\nHost: foo.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 13\n\nsay=Hi&to=Mom\n```\n![](https://upload-images.jianshu.io/upload_images/5863464-eefb916cd00ff9f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/813/format/webp)\n- MIME类型\n\nMIME的组成结构非常简单；由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。type 表示可以被分多个子类的独立类别。subtype 表示细分后的每个类型。\n\nMIME类型对大小写不敏感，但是传统写法都是小写\n\n- xml\nXML 有两种 MIME 媒体类型：text/xml 和 application/xml：\n\n1. application/xml 媒体类型：推荐使用。如果 MIME 用户代理或 Web 用户代理不支持这个媒体类型，会转为 application/octet-stream，当做二进制流来处理。application/xml 实体默认用 UTF-8 字符集。Content-type: application/xml; charset=\"utf-8\" 或 <?xml version=\"1.0\" encoding=\"utf-8\"?> 都可以生效。\n\n2. text/xml 媒体类型：如果 MIME 用户代理或 Web 用户代理不支持这个媒体类型，会将其视为 text/plain，当做纯文本处理。text/xml 媒体类型限制了 XML 实体中可用的编码类型（例如此时支持 UTF-8 但不支持 UTF-16，因为使用 UTF-16 编码的文本在处理 CR，LF 和 NUL 会导致异常转换）。text/xml 实体在 XML 头指定编码格式无效，必须在 HTTP 头部的 Content-Type: 中指定才会生效（例如 <?xml version=\"1.0\" encoding=\"utf-8\"?> 无法设置字符集，Content-Type: text/xml; charset=\"utf-8\" 则可以）。没有设置字符集时默认使用“us-ascii”字符集。\n"},{"title":"编写函数createArray(holder, length)返回长度为length，成员都是holder的数组","url":"/Roundtables/Question-Bank/basic-grammar/create-array.html","content":"---\ntitle: 编写函数createArray(holder, length)\ndate: 2019-01-14 10:14:00\ntags: [js, 算法]\ncategories: javascript\n---\n\n# 编写函数createArray(holder, length)返回长度为length，成员都是holder的数组\n\n## superwyk\n### 方法一\n```js\nfunction createArray(holder, length){\n    const arr = new Array(length);\n    arr.fill(holder);\n    return arr;\n}\n```\n\n### 方法二\n```js\n// es6方法\nfunction createArray(holder, length){\n    const arr = [];\n    while(length--){\n        arr.push(holder);\n    }\n    return arr;\n}\n```\n\n## febcat\n### 方法一\n``` js\nconst createArray = (holder, length) => {\n  let newHolder = [];\n\n  while (length > 0) {\n    newHolder.push(holder);\n    length--;\n  }\n\n  return newHolder;\n};\n\nconsole.log(\"createArray\", JSON.stringify(createArray(1, 5)));\n```\n\n### 方法二\n``` js\nconst createArray2 = (holder, length) => {\n  let holderType = Object.prototype.toString.call(holder);\n  let holderStr = holder + \"\";\n  let regStr = `(${holderStr})`;\n  let holderInit = res => {\n    switch (holderType) {\n      case \"[object Number]\":\n        return res.map(item => item - \"\");\n      case \"[object Null]\":\n        return res.map(() => null);\n      case \"[object Boolean]\":\n        return res.map(item => JSON.parse(item));\n      default:\n        return res;\n    }\n  };\n\nconsole.log(\"createArray2\", JSON.stringify(createArray2(\"true\", 5)));\n```\n\n## Mtd\n\n```js\n// fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引\n\n// es6\nfunction createArray(holder, length) {\n  let arr = new Array(length);\n  arr.fill(holder);\n  \n  return arr;\n}\n\nfunction createArray(holder, length) {\n  let arr = [];\n  while (length--) {\n    arr.push(holder)\n  } \n  \n  return arr;\n}\n```\n\n## Wlxm\n\n```\n1. Array(length).fill(holder)\n2. new Array(length).fill(holder)\n3. for循环填充\n```\n"},{"title":"函数式编程与柯里化","url":"/Roundtables/Question-Bank/basic-grammar/curry.html","content":"# 函数式编程与柯里化\n\n## 为什么函数是一等公民\n\n前端有3种常用的编程范式（`面向对象`、`过程式编程`、`函数式编程`）。我们常听说「**函数是JavaScript的一等公民**」，那么怎样理解这里的“一等公民”呢？\n\n`一等公民`，实际上说的是函数和其他对象一样，没什么特殊的...**你可以像对待任何其他数据类型一样对待它们**，即可以把函数存在数组里，当作参数传递，赋值给变量...等等，这也是**函数式编程**的思想基础。\n\n## 函数柯里化\n请编写函数实现`fn(2)(3)(4)=24`:\n```js\nfunction fn(n1) {\n    return function fn2(n2) {\n        return function fn3(n3) {\n            return n1 * n2 * n3;\n        }\n    }\n}\n\nfn(2)(3)(4) // 24\n```\n或者：\n```js\nfunction fn(n) {\n    var num = n;\n    return function fn2(n) {\n        num = num * n;\n        return function fn3(n) {\n            num = num * n;\n            return num;\n        }\n    }\n}\n\nfn(2)(3)(4) // 24\n```\n\n"},{"title":"实现防抖函数 debounce","url":"/Roundtables/Question-Bank/basic-grammar/debounce.html","content":"### 实现防抖函数 debounce\n\n## mtd\n```js\n /**\n  * 当持续触发事件时，debounce 会合并事件且不会去触发事件，当一定时间内没有触发再这个事件时，才真正去触发事件\n  */\n \n  // 非立即执行\n  const debounce = (func, wait, ...args) => {\n    let timeout;\n    return function(){\n      const context = this;\n      if (timeout) clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        func.apply(context, args)\n      },wait);\n    }\n  }\n \n \n    // 立即执行\n    const debounce = (func, wait, ...args) => {\n      let timeout;\n      return function(){\n        const context = this;\n        if (timeout) clearTimeout(timeout);\n        let callNow = !timeout;\n        timeout = setTimeout(() => {\n          timeout = null;\n        },wait)\n    \n        if(callNow) func.apply(context,args)\n      }\n    }\n    \n    // 结合版\n    \n  function debounce(func,wait,immediate) {\n      var timeout;\n\n      return function () {\n        var context = this;\n        var args = arguments;\n\n        if (timeout) clearTimeout(timeout);\n        if (immediate) {\n          var callNow = !timeout;\n          timeout = setTimeout(function(){\n            timeout = null;\n          }, wait)\n          if (callNow) func.apply(context, args)\n        }\n        else {\n          timeout = setTimeout(function(){\n            func.apply(context, args)\n          }, wait);\n        }\n      }\n    }\n    \n```\n\n### 实现节流函数 throttle\n\n```js\n    /*\n    * throttle（节流），当持续触发事件时，保证间隔时间触发一次事件\n    * 持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件\n    */\n    \n    // 在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。\n    const throttle = (func, wait, ...args) => {\n      let pre = 0;\n      return function(){\n        const context = this;\n        let now = Date.now();\n        if (now - pre >= wait){\n          func.apply(context, args);\n          pre = Date.now();\n        }\n      }\n    }\n    \n    //  在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次\n    const throttle = (func, wait, ...args) => {\n      let timeout;\n      return function() {\n        const context = this;\n\n        if (!timeout) {\n          timeout = setTimeout(() => {\n            timeout = null;\n            func.apply(context, args);\n          }, wait)\n        }\n      }\n    };\n    \n    // 结合版\n    /**\n     * @desc 函数节流\n     * @param func 函数\n     * @param wait 延迟执行毫秒数\n     * @param type 1 时间戳版(立即执行) 2 定时器版(非立即执行)\n     */\n    function throttle(func, wait ,type) {\n      if(type===1){\n        var previous = 0;\n      }else if(type===2){\n        var timeout;\n      }\n\n      return function() {\n        var context = this;\n        var args = arguments;\n        if(type===1){\n          var now = Date.now();\n\n          if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n          }\n        }else if(type===2){\n          if (!timeout) {\n            timeout = setTimeout(function() {\n              timeout = null;\n              func.apply(context, args)\n            }, wait)\n          }\n        }\n\n      }\n    } \n```\n\n## johninch\n\n### 防抖debounce\n\n- 函数防抖是指频繁触发的情况下，只有足够的空闲时间，才执行代码一次\n- 函数防抖的要点，需要一个setTimeout来辅助实现。延迟执行需要跑的代码。\n- 如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。\n- 如果计时完毕，没有方法进来访问触发，则执行代码。\n```js\nconst debounce = (handler, delay) => {\n  let timer;\n  return function() {\n    const ctx = this;\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      handler.apply(ctx, arguments)\n    }, delay)\n  }\n}\n\n/**\n * @param {*} handler\n * @param {*} delay \n * @param {boolean} immediate: 是否立即执行一次\n */\nconst debounce2 = (handler, delay = 300, immediate = false) => {\n  let timer;\n  let canDo = true\n  return function() {\n    const ctx = this;\n    if (timer) clearTimeout(timer);\n    if (immediate) {\n      if (canDo) {\n        canDo = false\n        handler.apply(ctx, arguments)\n      }\n      timer = setTimeout(() => {\n        canDo = true\n      }, delay)\n    } else {\n      timer = setTimeout(() => {\n        handler.apply(ctx, arguments)\n      }, delay)\n    }\n  }\n}\n```\n### 节流throttle\n\n- 函数节流是指一定时间内js方法只跑一次。\n- 函数节流的要点是，声明一个变量当标志位，记录当前代码是否在执行。\n- 如果空闲，则可以正常触发方法执行；如果代码正在执行，则取消这次方法执行，直接return。\n```js\nconst throttle = (handler, delay) => {\n  let canDo = true;\n  return function() {\n    if (!canDo) {\n      return;\n    }\n    let ctx = this;\n    setTimeout(() => {\n      handler.apply(ctx, arguments)\n    }, delay)\n  }\n}\n\n/**\n * @param {*} handler\n * @param {*} delay \n * @param {boolean} immediate: 是否立即执行一次\n */\nconst throttle2 = (handler, delay = 300, immediate = false) => {\n  let canDo = true;\n  return function() {\n    if (!canDo) {\n      return;\n    }\n    if (immediate) {\n      handler.apply(this, arguments)\n      canDo = false\n      setTimeout(() => {\n        canDo = true\n      }, delay)\n    } else {\n      let ctx = this;\n      setTimeout(() => {\n        handler.apply(ctx, arguments)\n      }, delay)\n    }\n  }\n}\n```\n\n## superyk\n### 防抖\n```js\n// 防抖，maxWait防止假死\nfunction debounce(fun, wait, maxWait){\n    let timer = null;\n    let lastRunTime = Date.now();\n\n    return function(...args){\n        const context = this;\n        const now = Date.now();\n\n        if(timer) {\n            clearTimeout(timer);\n            if(now - lastRunTime > maxWait){\n                lastRunTime = Date.now();\n                fun.apply(context, args);\n            }\n        } else {\n            lastRunTime = Date.now(); // 立即执行\n            fun.apply(context, args); // 立即执行\n        }\n\n        timer = setTimeout(function(){\n            timer = null;\n            // lastRunTime = Date.now(); // 延迟执行\n            // fun.apply(context, args); // 延迟执行\n        }, wait);\n    }\n}\n```\n### 节流\n```js\nfunction throttle(fun, wait){\n    let timer = null;\n\n    return function(...args){\n        const context = this;\n        if(timer) return;\n\n        timer = setTimeout(function(){\n            timer = null;\n            // fun.apply(context, args); // 延迟执行\n        }, wait);\n\n        fun.apply(context, args); // 立即执行\n    }\n}\n```\n\n## Wlxm\n\n```js\nfunction throttle(fn: Function, timeout: number = 200, immediate = false) {\n    let timer: number = null;\n    let isNotExecuted = true;\n\n    return function(...args: any) {\n        if (timer !== null) {\n            if (isNotExecuted && immediate) {\n                fn(...args);\n                isNotExecuted = false;\n            }\n\n            return;\n        }\n\n        timer = setTimeout(() => {\n            fn(...args);\n            timer = null;\n        }, timeout);\n    }\n}\n```"},{"title":"深拷贝","url":"/Roundtables/Question-Bank/basic-grammar/deep-clone.html","content":"---\n{\n    \"title\": \"完美深拷贝\",\n}\n---\n\n### 深拷贝\n\n> 实现深拷贝，尽可能完美实现\n\n<details>\n<summary>推荐答案:</summary>\n\n```js\n// 可继续遍历的数据类型\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n// 不可继续遍历的数据类型\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\n// 可继续遍历类型合集\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n// 工具函数-通用while循环，性能更好\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\n// 工具函数-判断是否为引用类型\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\n// 工具函数-获取实际类型\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\n// 工具函数-初始化被克隆的对象\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\n// 工具函数-克隆Symbol\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\n// 工具函数-克隆正则\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\n// 工具函数-克隆函数\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\n// 工具函数-克隆不可遍历类型\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型（即非包装类型的基础数据类型）\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化-根据不同类型进行操作\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 处理 循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n\n```\n***相关知识点链接：***\n- [本文链接 - 如何写出一个惊艳面试官的深拷贝?](https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1#heading-6)\n- [类型转换之装箱操作 - toObject](https://juejin.im/post/5cbaf130518825325050fb0a \"装箱\")\n- [类型转换之拆箱操作 - ToPrimitive](https://juejin.im/post/5ccfb58f518825405a198fcd \"拆箱\")\n- [原来JS还可以这样拆箱转换详解](http://www.cppcns.com/wangluo/javascript/251632.html)\n\n\n</details>\n\n----\n\n<details>\n<summary>febcat:</summary>\n\n```javascript\nconst deepClone = obj => {\n    if (typeof obj !== 'object') {\n      console.info(`deepClone: not object, is ${typeof obj}`)\n      return obj\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.reduce((arr, item) => arr.concat(deepClone(item)), [])\n    }\n\n    return Object.entries(obj).filter(item => obj.hasOwnProperty(item[0])).reduce((newObj, [key, value]) => {\n      newObj[key] = deepClone(value)\n\n      return newObj\n    }, {})\n  }\n```\n</details>\n\n<details>\n<summary>Caleb:</summary>\n\n``` javascript\nfunction deepClone(origin){\n\tlet target = Array.isArray(origin) ? [] : {};\n\n\tif (typeof origin !== 'object'){\n\t\treturn origin;\n\t}\n\n\tfor(let i in origin){\n\t\tif(origin.hasOwnProperty(i)) {\n\t\t\tif(typeof origin[i] === 'object' && origin[i] !== 'null'){\n\t\t\t\ttarget[i] = origin[i]\n\t\t} else {\n\t\t\t\ttarget[i] = deepClone(origin[i])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn target\n}\n\n```\n</details>\n\n<details>\n<summary>Xmtd:</summary>\n\n```js\nfunction cloneDeep(target) {\n    if (!target || typeof target !== 'object') {\n        return target;\n    }\n    \n    let result = Array.isArray(target) ? [] : {};\n    \n    for (let name in target) {\n        if (target.hasOwnProperty(name)) {\n            if (typeof target[name] === 'object') {\n                result[name] = cloneDeep(target[name]);\n            } else {\n                result[name] = target[name]\n            }\n        }\n    }\n    \n    return result;\n}\n```\n</details>\n\n<details>\n<summary>niannings:</summary>\n\n```js\nconst getType = v =>\n  v === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name.toLowerCase();\n\nconst canTraverse = o => {\n  const checkSet = new Set(['array', 'object']);\n\n  return checkSet.has(getType(o));\n};\n\nconst clone = obj => {\n  let ret = new obj.constructor();\n  let stack = [obj];\n  let refMap = new WeakMap();\n  let traverseObj;\n\n  refMap.set(obj, ret);\n\n  while (traverseObj = stack.pop()) {\n    let entries = Object.entries(traverseObj);\n    let len = entries.length;\n    let cur = refMap.get(traverseObj);\n\n    for (let i = 0; i < len; i++) {\n      let [k, v] = entries[i];\n\n      if(canTraverse(v) && !refMap.has(v)) {\n        cur[k] = new v.constructor();\n\n        refMap.set(v, cur[k]);\n        stack.push(v);\n      } else if (refMap.has(v)) {\n        cur[k] = refMap.get(v);\n      } else {\n        cur[k] = v;\n      }\n    }\n  }\n\n  return ret;\n}\n\n// 测试用例\n// 普通对象\nlet a = {\n  b: {\n    c: []\n  },\n  d: 1,\n  e: /\\w/,\n  f: null,\n  g: undefined,\n  h: \"hello niannings\"\n};\n\nlet b = clone(a);\n\nconsole.log(\"---测试对象---\");\nconsole.log(a, b);\nconsole.log(\"a === b: \", a === b); // false\nconsole.log(\"a.b === b.b\", a.b === b.b); // false\nconsole.log(\"a.b.c === b.b.c\", a.b.c === b.b.c); // false\n\n// 测试循环引用\n\nb.r = b;\nb.s = b.b;\n\nlet bb = clone(b);\n\nconsole.log(\"---测试循环引用---\");\nconsole.log(b, bb);\nconsole.log(\"b.r === bb.r: \", b.r === bb.r);\n\n// 数组\nlet c = [1, a, \"hello\"];\n\nlet d = clone(c);\n\nconsole.log(\"---测试数组---\");\nconsole.log(c, d);\nconsole.log(\"d === c: \", d === c);\nconsole.log(\"c[1] === d[1]: \", c[1] === d[1]);\nconsole.log(\"c[1].b === d[1].b: \", c[1].b === d[1].b);\n```\n</details>\n\n<details>\n<summary>superwyk:</summary>\n\n```js\n// 只考虑基本数据类型、数组、plain Object的复制\nfunction deepCopy(o) {\n    // 判断是否为数组\n    if (Object.prototype.toString.call(o) === '[object Array]') {\n        let array = [];\n        for (let i = 0; i < o.length; i++) {\n            array[i] = deepCopy(o[i]);\n        }\n        return array;\n    } else if (Object.prototype.toString.call(o) === '[object Object]') {\n        let object = {};\n        let keys = Object.keys(o);\n        for (let i = 0; i < keys.length; i++) {\n            object[keys[i]] = deepCopy(o[keys[i]]);\n        }\n        return object;\n    } else {\n        return o;\n    }\n}\n```\n\n</details>"},{"title":"深度查询实现","url":"/Roundtables/Question-Bank/basic-grammar/deep-query.html","content":"---\n{\n    \"title\": \"深度查询实现\",\n}\n---\n\n### 深度查询实现\n\n> 实现lodash中的get方法：get(target, path, defaultValue)，深度查询一个数组或者对象中的值(数组和对象不止一层嵌套)，查询不到默认返回undefined。参照[lodash/._get](https://www.lodashjs.com/docs/latest#_getobject-path-defaultvalue)\n\n```js\n// example\nvar object = { 'a': [{ 'b': { 'c': 3 } }] };\n \n_.get(object, 'a[0].b.c'); // => 3\n_.get(object, ['a', '0', 'b', 'c']); // => 3\n_.get(object, 'a.b.c', 'default'); // => 'default'\n\n```\n----\n\n#### 推荐答案:\n\n```js\nfunction get (source, path, defaultValue = undefined) {\n  // a[3].b -> a.3.b\n  const paths = path.replace(/\\[(\\S+)\\]/g, '.$1').split('.').filter(key => key)\n  // const paths = path.split(/[[\\].]/g).filter(key => key); // 这里可以直接用正则 [[\\].] 或匹配\n\n  let result = source\n  for (const p of paths) {\n    // null 与 undefined 取属性会报错，所以使用 Object 包装一下\n    result = Object(result)[p]\n\n    if (result === undefined) {\n      return defaultValue\n    }\n  }\n  return result\n}\n\nget(object, 'a[3].b', undefined);\n```\n<!-- ![object(undefined)](../../_media/md-images/object(undefined).png) -->\n[相关链接]](https://juejin.im/post/5cd938135188250f21618765)\n\n----\n\n<details>\n<summary>组员答案:</summary>\n\n```js\nfunction get (source, path, defaultValue = undefined) {\n  // a[3].b -> a.3.b\n  const paths = path.replace(/\\[(\\S+)\\]/g, '.$1').split('.').filter(key => key)\n  // const paths = path.split(/[[\\].]/g).filter(key => key); // 这里可以直接用正则 [[\\].] 或匹配\n\n  let result = source\n  for (const p of paths) {\n    // null 与 undefined 取属性会报错，所以使用 Object 包装一下\n    result = Object(result)[p]\n\n    if (result === undefined) {\n      return defaultValue\n    }\n  }\n  return result\n}\n\nget(object, 'a[3].b', undefined);\n```\n<!-- ![object(undefined)](../../_media/md-images/object(undefined).png) -->\n[相关链接]](https://juejin.im/post/5cd938135188250f21618765)\n\n----\n\n#### febcat:\n\n```javascript\nconst get = (obj, path, defaultBack= undefined) => {\n    if (typeof obj !== 'object') {\n        console.error(`get: require object, but ${typeof obj}`)\n        return defaultBack\n    }\n\n    const rule = Array.isArray(path) ? path.join(',').replace(/\\,/g, '.') : path\n    const preRule = rule.replace(/\\[(\\d+)\\]/g, (match, $1, index) => index ? '.' + $1 : $1).split('.')\n    const nextRule = preRule.slice(1).join('.')\n    const key = preRule[0]\n\n    return obj.hasOwnProperty(key)\n        ? nextRule\n        ? get(obj[key], nextRule)\n        : /(\\[\\])|(\\{\\})/g.test(JSON.stringify(obj[key]))\n            ? defaultBack\n            : obj[key]\n        : defaultBack\n    }\n}\n```\n----\n\n#### Caleb:\n\n``` javascript\nvar IsEmptys = value => {\n  if(value === undefined || value === null || typeof value === 'object' && (Object.keys(value) && Object.keys(value).length === 0 || value.length === 0)){\n    return true\n  }\n  return false\n}\n\nfunction get(target, rule){\n  const formatRule = typeof rule === 'string' ? rule.replace(/\\[|\\]|\\./g, '').split('') : rule;\n  const len = formatRule.length;\n  const returnValue = target[formatRule[0]];\n  if(IsEmptys(returnValue)){\n      return undefined;\n  }\n\n  if(len === 1){\n      console.log('ooooo', returnValue)\n      return returnValue\n  }\n\n  formatRule.shift();\n  get(returnValue, formatRule);\n\n}\n```\n----\n\n#### Xmtd:\n\n```js\n  function get(target, rule, defaultBack) {\n    let ruleType = typeof rule === 'string' ? 'string' : Array.isArray(rule) ? 'array' : 'noSupport';\n\n    if (ruleType === 'noSupport') {\n      throw Error('no support rule');\n\n      return;\n    }\n\n    let result = target;\n\n    let nameArr = ruleType === 'string' ? rule.replace(/(\\[|\\]|\\.)/g, ',').split(\",\").filter((item) => item) : rule;\n\n    for (let i = 0; i < nameArr.length; i++) {\n      if (result[nameArr[i]] !== null && result[nameArr[i]] !== undefined) {\n        result = result[nameArr[i]];\n      } else {\n        result = defaultBack;\n        break;\n      }\n    }\n\n    return result;\n\n  }\n```\n----\n\n#### niannings:\n\n```js\nconst execExp = (state, exp, defaultBack = undefined) => {\n  const keys = exp.split(/[[\\].]/g).filter(key => key !== \"\");\n  const flag = keys.length;\n  let value = state;\n\n  for (let i = 0; i < flag; i++) {\n    value = value[keys[i]];\n\n    if (value === undefined) {\n      return defaultBack;\n    }\n  }\n\n  return value;\n};\n```\n</details>\n"},{"title":"数组去重","url":"/Roundtables/Question-Bank/basic-grammar/duplicate-remove.html","content":"---\ntitle: 数组去重\ndate: 2019-01-14 10:30:00\ntags: [js, 算法]\ncategories: javascript\n---\n\n# 数组去重\n\n## superwyk\n### 方法一\n```js\nfunction duplicateRemove(arr) {\n    return [... new Set(arr)]\n}\n```\n### 方法二\n```js\nfunction duplicateRemove(arr) {\n    const result = [];\n    arr.forEach(item => {\n        if (!~result.indexOf(item)) {\n            result.push(item)\n        }\n    });\n    return result;\n}\n```\n\n## johninch\n\nlet arr = [1, 'a', 'a', 2, 2, 3];\n\n### 方法一\n```js\nfunction unique1(arr) {\n  return Array.from(new Set(arr))\n}\n\nconsole.log(unique1(arr))\n```\n\n### 方法二\n```js\nfunction unique2(arr) {\n  return [...new Set(arr)]\n}\n\nconsole.log(unique2(arr))\n```\n\n### 方法三\n```js\nfunction unique3(arr) {\n  return arr.filter((item, index, array) => array.indexOf(item) === index)\n}\n\nconsole.log(unique3(arr))\n```\n\n### 方法四\n```js\nfunction unique4(arr) {\n  return arr.reduce((prev, cur) => {\n    return prev.includes(cur) ? prev : [...prev, cur]\n  }, [])\n}\n\nconsole.log(unique4(arr))\n```\n\n### 方法五\n```js\nfunction unique5(arr) {\n  const seen = new Map()\n  return arr.filter(item => {\n    return !seen.has(item) && !!seen.set(item, 1)\n  })\n}\n\nconsole.log(unique5(arr))\n```\n\n## Mtd\n\n````js\nfunction uniq(arr) {\n  if (!arr || !arr.length) {\n    return [];\n  }\n\n  let result = [];\n  let i = 0;\n  while (i < arr.length) {\n    if (result.indexOf(arr[i]) === -1) {\n      result.push(arr[i])\n    }\n    i++;\n  }\n\n  return result\n}\n````\n\n## febcat\n### 方法一\n``` js\nconst duplicateRemove = arr => {\n  // 正则\\1以为重复第一个括号内的内容\n  let arrToStr = arr.sort().join(\",\") + \",\",\n    newArr = [];\n\n  newArr = arrToStr.replace(/(\\d,)\\1+/g, (match, p1, index, target) => p1);\n\n  return newArr\n    .split(\",\")\n    .map(item => item && +item)\n    .filter(i => i);\n};\n\nconsole.log(\n  \"duplicateRemove\",\n  JSON.stringify(\n    duplicateRemove([2, 3, 1, 2, 1, 6, 3, 3, 13, 4, 5, 2, 3, 6, 6])\n  )\n);\n```\n### 方法二\n``` js\nconst duplicateRemove2 = arr => {\n  let newArr = [];\n\n  arr.map(item => (!newArr.includes(item) ? newArr.push(item) : null));\n\n  return newArr;\n};\n\nconsole.log(\n  \"duplicateRemove2\",\n  JSON.stringify(duplicateRemove2([1, 3, 2, 6, 3, 3, 13, 4, 5, 2, 3, 6, 6]))\n);\n```\n\n## niannings\n\n## Caleb\n``` js\n[...new Set(arr)]\n\n```\n\n"},{"title":"实现斐波那契数列","url":"/Roundtables/Question-Bank/basic-grammar/fibonacci.html","content":"---\ntitle: 实现斐波那契数列\ndate: 2019-01-14 10:38:00\ntags: [js, 算法, 尾调用]\ncategories: javascript\n---\n\n# 实现斐波那契数列\n\n实现指定区间内的斐波那契数列。斐波那契是指从第三项开始，每一项都为其前两项的值之和：1 2 3 5 8 13 21 34 ...\n例如，给定 100, 2000，需要打印 100 101 201 302 503 805 1308\n\n## superwyk\n### 方法一\n```js\n// es5 实现\nfunction fibonacci(startValue, maxValue) {\n    let result = []\n\n    let beforeAgain = startValue;\n    let before = startValue + 1;\n    let current = before + beforeAgain;\n    if (current < maxValue) {\n        result = [beforeAgain, before];\n    }\n    while (current < maxValue) {\n        result.push(current);\n        beforeAgain = before;\n        before = current;\n        current = before + beforeAgain;\n    }\n\n    return result;\n}\n```\n\n### 方法二\n```js\n// es6 generator实现\nfunction* genFibonacci(startValue, maxValue) {\n    let before = startValue + 1;\n    let current = startValue + before;\n\n    if (current < maxValue) {\n        yield startValue;\n        yield before;\n    }\n    console.log(before, current);\n    while (current < maxValue) {\n        yield current;\n        [before, current] = [current, before + current];\n    }\n}\nconst fibonacci = [...genFibonacci(200, 2000)];\n```\n\n## Johninch\n\n接下来按各种方法实现fibonacci数列，而这道题的目标是输出fib数组的范围，其中只有迭代方法和generator方法适合做。\n\n### 迭代实现 fibonacci\n```js\n// 基本fibonacci循环\nfunction fib(n) {\n  let n1 = 1, n2 = 1, sum\n  let arr = [n1, n2]\n  for(let i = 3; i <= n; i++) {\n    sum = n1 + n2\n    n1 = n2\n    n2 = sum\n    arr.push(sum)\n  }\n\n  console.log(arr) // fib(9): [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  return sum\n}\n\nconsole.log(fib(9)) // 34\n```\n#### 输出fib范围：\n```js\n// 基本fibonacci循环\nfunction fibRange(start, end) {\n  let n1 = 1, n2 = 1, sum\n  let arr = [n1, n2]\n  for(let i = 3; i <= end; i++) {\n    sum = n1 + n2\n    n1 = n2\n    n2 = sum\n    arr.push(sum)\n  }\n\n  console.log(arr.slice(start))\n  return sum\n}\n\nfibRange(6, 9)) // [8, 13, 21, 34]\n```\n\n\n### 递归实现 fibonacci\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow），数字过大内存不足浏览器会`有假死现象`。\n```js\n// 递归实现fibonacci (n太大会使浏览器假死)\nfunction fib2(n) {\n  if (n <= 2) {\n    return 1\n  }\n  return fib2(n-2) + fib2(n-1)\n}\n\nconsole.log(fib2(9)) // 34\n```\n\n### 使用尾递归实现 fibonacci\n- 使用尾调用优化，详见[es6-函数的扩展-尾调用优化](http://es6.ruanyifeng.com/?search=%E5%B0%BE%E8%B0%83%E7%94%A8&x=0&y=0#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96)\n- 尾调用由于是函数的最后一步操作，不需要保留外层函数的调用帧（因为调用位置、内部变量等信息都不会再用到了），所以`直接用内层函数的调用帧取代外层函数的调用帧`即可。做到每次执行时，调用帧只有一项。\n- 尾调用自身，就称为尾递归。对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n```js\n// 尾递归实现fibonacci (尾调用优化)\nfunction fib3(n, n1 = 1, n2 = 1){\n  if (n <= 2) {\n      return n2;\n  } else {\n      return fib3(n-1, n2, n1 + n2);\n  }\n}\n\nconsole.log(fib3(9)) // 34\n```\n\n注意：如何区分是否是尾调用\n```js\n// 是尾调用：某个函数的最后一步是调用另一个函数\nfunction f(x){\n  return g(x);\n}\n\n// 不是：调用g(x)之后，还有赋值操作\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 不是：调用g(x)之后，还有加法操作\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 不是：并没有将g(x)调用返回\nfunction f(x){\n  g(x);\n}\n\n// 是尾调用：尾调用不一定出现在函数尾部，只要是最后一步操作即可\n// 函数m和n都属于尾调用，因为它们都是函数f的最后一步操作\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n### 使用“记忆”方法减少运算量。\n> 在一个数组里保存我们的储存结果，储存结果隐藏在闭包中.\n```js\nconst fib4 = (function() {\n  var memo = [0, 1];\n  return function _fib(n) {\n    var result = memo[n];\n    if (typeof result !== \"number\") {\n      memo[n] = _fib(n - 1) + _fib(n - 2);\n      result = memo[n];\n    }\n    return result;\n  };\n})();\n\nconsole.log(fib4(9)); // 34\n```\n\n### generator实现fib\n```js\nfunction* fib5(x) {\n  let a = 1, b = 1, n = 1;\n  while (n <= x) {\n    yield a;\n    [a, b] = [b, a + b];\n    n++;\n  }\n}\nconsole.log([...fib5(9)]);\n```\n\n#### 输出fib范围：\n```js\nfunction* fibRange5(start, end) {\n  let a = 1, b = 1, n = 1;\n  while (n <= end) {\n    if (n >= start) {\n      yield a;\n    }\n    [a, b] = [b, a + b];\n    n++;\n  }\n}\nconsole.log([...fibRange5(6, 9)]); // [8, 13, 21, 34]\n```\n\n## febcat\n```js\nconst fibonacci = (start, maxValue) => {\n  let variate = 1,\n    oldStart;\n\n  while (start <= maxValue) {\n    console.log(\"fibonacci\", start);\n\n    oldStart = start;\n    start += variate;\n    variate = oldStart;\n  }\n};\n\nfibonacci(5, 1000);\n```\n### Mtd\n\n```js\n// 递归\nfunction fibonacci(min, max, arr){\n  if (!arr) {\n    arr = [min, min + 1];\n  }\n\n  let _len = arr.length;\n  let _sub = arr[_len - 2] + arr[_len - 1];\n  if (_sub < max){\n    arr.push(_sub);\n    fibonacci(min, max, arr);\n  }\n\n  return arr;\n}\n\n// 循环\nfunction fibonacci2(min ,max) {\n  let next = min + 1;\n  let before = min;\n\n  if (next > max) {\n    return [min]\n  }\n  let arr = [before, next];\n  let current = before + next;\n\n  while (current < max) {\n    arr.push(current);\n    before = next;\n    next = current;\n    current = before + next;\n  }\n\n  return arr;\n  ```\n  \n## Caleb\n``` js\nvar fibonacci = function(start, end) {\n    var result = [start];\n    if(start === end) return result;\n    result.push(start+1);\n    while(result[result.length-1]<=end){\n        var len = result.length;\n        result.push(result[len-1]+result[len-2])\n    }\n    return result.toString()\n}\n```\n\n## Wlxm\n\n```js\nfunction fibonacci(n: number) {\n    let pre = 1;\n    let cur = 1;\n    const ret = [pre];\n\n    while (n > 1) {\n        let _cur = cur;\n        ret.push(cur);\n        cur += pre;\n        pre = _cur;\n        n--;\n    }\n\n    return ret;\n}\n```\n"},{"title":"实现数组扁平化","url":"/Roundtables/Question-Bank/basic-grammar/flatten-array.html","content":"---\n{\n    \"title\": \"数组扁平化\",\n}\n---\n\n啦啦啦啦\n\n### 实现数组扁平化\n\n> 数组扁平化： [1, [2, [3, 4]]] =>> [1, 2, 3, 4]\n\n#### 推荐答案:\n\n>> 方法一：常规递归：\n\n```js\nlet newArr = []\nfunction flatten(arr) {\n    for(let i = 0; i < arr.length; i++) {\n        if (Array.isArray(arr[i])) {\n            flatten(arr[i])\n        } else {\n            newArr.push(arr[i])\n        }\n    }\n}\n\nflatten([1, [2, [3, 4]]])\nconsole.log(newArr)\n```\n\n以上递归使用了全局变量，递归函数应该是完整功能隔离的，下面是优化后的递归:\n\n```js\nfunction flatten(arr) {\n    let newArr = []\n    for(let i = 0; i < arr.length; i++) {\n        if (Array.isArray(arr[i])) {\n            newArr = newArr.concat(flatten(arr[i]))\n        } else {\n            newArr.push(arr[i])\n        }\n    }\n\n    return newArr\n}\nflatten([1, [2, [3, 4]]])\n```\n以下将 result 作为第二个参数 传入的方式也很巧妙\n```js\nfunction flatten(target, result = []) {\n    target.forEach((item) => {\n        if (Array.isArray(item)) {\n            flatten(item, result);\n        } else {\n            result.push(item);\n        }\n    });\n\n    return result;\n}\n```\n\n使用reduce迭代器简化上述递归方法:\n```js\nfunction flatten(arr) {\n    return arr.reduce((prev, item) => {\n        return prev.concat(Array.isArray(item) ? flatten(item) : item)\n    }, [])\n}\n```\n\n>> 方法二：使用ES6扩展运算符（一次只能展开一层）\n\n```js\nfunction flatten(arr) {\n    while(arr.some(item => Array.isArray(item))) {\n        arr = [].concat(...arr)\n        // 也可以利用apply方法 arr = [123].concat.apply([], arr)\n        // 由于 apply 的第二个参数传入的是[a, b, c],所以每次也只能展开一层\n        // 前面的[123]是随便写的，只要是数组即可，apply的第一个参数[]借用了[123]的concat方法，才是真正的方法调用者\n    }\n    return arr\n}\n\nflatten([1, [2, [3, 4]]])\n```\n\n>> 方法三：由于元素均为数字，因此可使用隐式类型转换\n\n```js\n[1, [2, [3, 4]]].toString().split(',').map(i => Number(i))\n// toString也可以替换成join方法，也可以达到隐式类型转换的目的\n```\n\n----\n\n<details>\n<summary>组员答案</summary>\n\n#### johninch\n\n>> 方法一：常规递归：\n\n```js\nlet newArr = []\nfunction flatten(arr) {\n    for(let i = 0; i < arr.length; i++) {\n        if (Array.isArray(arr[i])) {\n            flatten(arr[i])\n        } else {\n            newArr.push(arr[i])\n        }\n    }\n}\n\nflatten([1, [2, [3, 4]]])\nconsole.log(newArr)\n```\n\n以上递归使用了全局变量，递归函数应该是完整功能隔离的，下面是优化后的递归:\n\n```js\nfunction flatten(arr) {\n    let newArr = []\n    for(let i = 0; i < arr.length; i++) {\n        if (Array.isArray(arr[i])) {\n            newArr = newArr.concat(flatten(arr[i]))\n        } else {\n            newArr.push(arr[i])\n        }\n    }\n\n    return newArr\n}\nflatten([1, [2, [3, 4]]])\n```\n\n使用reduce迭代器简化上述递归方法:\n```js\nfunction flatten(arr) {\n    return arr.reduce((prev, item) => {\n        return prev.concat(Array.isArray(item) ? flatten(item) : item)\n    }, [])\n}\n```\n\n>> 方法二：使用ES6扩展运算符（一次只能展开一层）\n\n```js\nfunction flatten(arr) {\n    while(arr.some(item => Array.isArray(item))) {\n        arr = [].concat(...arr)\n    }\n    return arr\n}\n\nflatten([1, [2, [3, 4]]])\n```\n\n>> 方法三：由于元素均为数字，因此可使用隐式类型转换\n\n```js\n[1, [2, [3, 4]]].toString().split(',').map(i => Number(i))\n// toString也可以替换成join方法，也可以达到隐式类型转换的目的\n```\n----\n#### febcat:\n\n```javascript\nconst flattenArray = array => {\n  if (!/\\[\\S+\\]/.test(JSON.stringify(array))) {\n    return array\n  }\n\n  return [\n    ...new Set(\n      array.reduce((arr, item) => {\n        return Array.isArray(item) ?  arr.concat(flattenArray(item)) : arr.concat(item)\n      },[])\n    )\n  ]\n}\n\n```\n----\n#### Caleb:\n\n* 1. 使用ES6 flat方法\n\n``` javascript\n[1, [2, [3, 4]]].flat(Infinity)\n\n```\n* 2. 使用Generate函数语法 实现flat的功能\n\n``` javascript\nconst arr = [1, [2, [3, 4]]];\nconst flatCopy = function* (a) {\n\tif (!Array.isArray(a)){\n\t\treturn false;\n\t}\n\n\tconst len = a.length;\n\tfor (let i=0; i < len; i++){\n\t\tconst item = a[i];\n\t\tif (typeof item === 'number'){\n\t\t\tyield item\n\t\t} else {\n\t\t\tyield* flatCopy(item)\n\t\t}\n\t}\n}\n\nconst arr2 = [];\n\nfor(let j of flatCopy(arr)){\n\tarr2.push(j)\n}\n\n```\n----\n#### Xmtd:\n\n```js\n  function flatten(target, result = []) {\n    target.forEach((item) => {\n      if (Array.isArray(item)) {\n        flatten(item, result);\n      } else {\n        result.push(item);\n      }\n    });\n\n    return result;\n  }\n  \n  // 方法\n  target.flat(Infinity);\n\n  // 类型改变了\n  target.toString().split(',');\n```\n</details>\n"},{"title":"编写js，实现对足球比赛的剩余人数判断","url":"/Roundtables/Question-Bank/basic-grammar/football-people.html","content":"# 编写js，实现对足球比赛的剩余人数判断\n\n足球比赛的规则，我们应该都很了解，现在让我们来用代码模拟一场足球比赛：\n\n规则：两队名为“A”和“B”各有11名球员;每支球队的球员从1到11进行编号。队员收到红牌会被直接罚下场，收到两张黄牌也会被罚下场。如果其中一支球队剩下的球员少于7人，则裁判立即停止比赛，并且少于7名球员的球队输掉比赛。\n\n现在，让我们实现一个函数，输入一个数组，数组的内容是裁判员判罚的内容，数组的每一项包括：队伍名称（A或B），队员编号(1 到 11)，以及受到惩罚（R：红牌，Y：黄牌）。输出两个队伍最后剩余的人数：\n\n例如：\n\n    输入：[\"A4Y\", \"A5R\", \"B5R\", \"A4Y\", \"B6Y\"]，输出：[9,10]\n    输入：[]，输出：[11, 11]\n    输入：[\"A4R\", \"A4R\", \"A4R\"]，输出：[10,11]"},{"title":"判断数组的方法","url":"/Roundtables/Question-Bank/basic-grammar/is-array.html","content":"---\ntitle: 判断数组的方法\ndate: 2019-01-14 10:04:00\ntags: [js, 算法]\ncategories: javascript\n---\n\n# 判断数组的方法\n\n## superwyk\n### 方法一\n```js\n// 最常用方法\nfunction isArray(arr){\n    return Object.prototype.toString.call(arr) === '[object Array]';\n}\n```\n\n### 方法二\n```js\n// es6方法\nfunction isArray(arr){\n    return Array.isArray(arr);\n}\n```\n\n### 方法三\n```js\nfunction isArray(arr){\n    return arr.constructor === Array;\n}\n```\n\n### 方法四\n```js\nfunction isArray(arr){\n    return arr instanceof Array;\n}\n```\n\n## johninch\n### 方法一\n```js\n// es5 方法\nfunction isArray(arr){\n    return Object.prototype.toString.call(arr) === '[object Array]';\n}\n```\n\n### 方法二\n```js\n// es6 方法\nfunction isArray(arr){\n    return Array.isArray(arr);\n}\n```\n\n### 方法三\n有误差，不推荐：\n```js\nfunction isArray(arr){\n    return arr.constructor === Array;\n}\n```\n\n### 方法四\n有误差，不推荐：\n```js\nfunction isArray(arr){\n    return arr instanceof Array;\n}\n```\n\n### 方法五\n比较麻烦，不推荐：通过判断数组的属性来间接判断 有length属性且不可枚举(因为也可以为对象添加属性)，有splice\n```js\nfunction isArray(arr){\n    return arr && typeof arr === \"object\" &&\n        typeof arr.splice === \"function\" &&\n        typeof arr.length === \"number\" && !arr.propertyIsEnumerable(\"length\")\n}\n```\n\n## Mtd\n```js\n\nfunction isArray(arr) {\n  if (Array.isArray) {\n    return Array.isArray(arr);\n  } else {\n    return Object.prototype.toString.call(arr) === '[object Array]'\n  }\n}\n```\n\n## Wlxm\n```\n1. Array.isArray\n2. Object.toString.call(*) === '[object Array]'\n3. Object(*).constructor === Array\n4. * instanceof Array\n5. Object(*).constructor.name === 'Array'\n```\n\n"},{"title":"JS原生选择器","url":"/Roundtables/Question-Bank/basic-grammar/js-querySelector.html","content":"# JS原生选择器\n\n## querySelectorAll方法相比getElementsBy系列方法有什么区别？\n\n#### 1. 所属W3C规范不同\n- querySelectorAll属于W3C中的Selectors API规范。\n- getElementsBy系列则属于W3C的DOM规范。\n\n#### 2. 接收参数不同\n- querySelectorAll方法接收的参数是一个CSS选择符。\n- getElementsBy系列接收的参数只能是单一的className、tagName和name。\n \n#### 3. 返回值差异\n- querySelectorAll 返回的是一个`静态NodeList`。NodeList对象会包含文档中的所有节点，如Element、Text和Comment等。\n- getElementsBy系列的返回的是一个 `HTMLCollection 对象`。HTMLCollection对象只会包含文档中的Element节点。\n\n"},{"title":"JS中的奇技淫巧","url":"/Roundtables/Question-Bank/basic-grammar/js-tricks.html","content":"# JS中的奇技淫巧\n\n## Math.max.apply\n`Math.max(param1,param2...)`参数不支持数组，可以借助apply得到一个数组中最大的一项：\n```js\nvar max = Math.max.apply(null, array)\n```\n```js\n// 以下等价：\nvar max = Math.max(10, 20,30);   \nvar max = Math.max.call(null,10, 20,30); \nvar max = Math.max.apply(null,[10, 20,30]);\nvar max = Math.max(...[10, 20,30]);\n```\n\n## 进制转换 parseInt(s, m).toString(n)\n\n#### parseInt与toString\n- 进制转换：`parseInt(s, m).toString(n)`; \n    - 将`m`进制字符串`s`，转成`10`进制整数；\n    - 再将此`10`进制整数，转换为`n`进制字符串。\n\n- **parseInt(str, radix)**: 将str按照radix进制编码转换为10进制**返回对应数字** (radix支持 [2, 36] 之间的整数, 默认为10);\n- **Number.toString(radix)**: 返回表示该数字的指定进制形式的**字符串** (radix支持 [2, 36] 之间的整数, 默认为10);\n\n#### rgb颜色 转 16进制hex\n'rgb(255, 255, 255)' => #ffffff\n```js\nvar str = 'rgb(255, 255, 255)'\n\nconst rgbToHex = (str) => {\n    return '#' + str.match(/rgb\\((.+)\\)/)[1]\n        .split(/,\\s/)\n        .map(s => parseInt(s, 10).toString(16))\n        .join('')\n}\n\nrgbToHex(str)\n```\n\n\n## 伪数组转换\n\n#### 什么是伪数组\n- 伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可用真正数组的遍历方法来遍历它们。\n- 典型的伪数组有：函数的`arguments`参数，还有像调用getElementsByTagName、document.childNodes之类返回的`NodeList`对象都属于伪数组。\n\n#### 转换方法\n- 转换方法1：`Array.prototype.slice.call(fakeArray)`或者`[].slice.call(fakeArray)`；\n- 转换法法2：使用ES6中`Array.from`；\n\n\n\n## in 关键字的作用\n\nJS 关键字 `in` 的使用方法：\n#### 1、for...in 声明用于对数组或者对象的index或key进行遍历。\n写法格式：for(var v in arrObj) {...}\n- 当arrObj是`数组`时，v代表数组`index`;\n- 当arrObj是`对象`时，v代表对象`key`;\n\n#### 2、判断元素 是否为 数组的index 或 对象的key：\n```js\nvar arr = [\"a\",\"2\",\"str\"];  \nvar result = (\"str\" in arr);  // false\nvar result1 = (2 in arr);   // true\nvar result2 = (3 in arr);   // false\n\nvar obj = { w:\"wen\", j:\"jian\", b:\"bao\"} \nvar result = ('jian' in obj); // false   \nvar result1 = (\"j\" in obj);  // true\n```\n\n## b = a.filter(Boolean)\n\n实际上，下面这样的写法是一种简写模式:\n```js\nb = a.filter(Boolean);\n// 它等价于\nb = a.filter(function (x) { return Boolean(x); });\n```\n\nECMAScirpt5 中 Array 类中的 filter 方法使用目的是移除所有的 ”false“ 类型元素  (false, null, undefined, 0, NaN, '')：\n```js\nvar a=[1,2,\"b\",0,{},\"\",NaN,3,undefined,null,5];\nvar b=a.filter(Boolean); // [1,2,\"b\",{},3,5]\nBoolean 是一个函数，它会对遍历数组中的元素，并根据元素的真假类型，对应返回 true 或 false.\n\n// 例如：\nBoolean(0); // false\nBoolean(true); // true\nBoolean(1); // true\nBoolean(\"\"); // false\nBoolean(\"false\"); // true. \"false\"是一个非空字符串\n```\n\n## ['1', '2', '3'].map(parseInt)\n返回 `[ 1, NaN, NaN ]`：\n```js\nparseInt('1', 0); // 0或省略时，以十进制转换\nparseInt('2', 1); // radix不在2~36的返回NaN\nparseInt('3', 2); // 二进制数没有3，只有0 1 ，所以NaN\n```\n- array.map(function(item,index,arr), thisValue):map返回一个经过函数映射的数组。item当前数组元素；index是当前元素索引；arr是数组本身；thisValue是可选值，对象作为该执行回调时使用，传递给函数，用作 'this' 的值，如果省略了 thisValue ，'this' 的值为 'undefined'。\n- parseInt(str,radix):解析一个字符串，并返回一个整数。Str是输入字符串；radix是运算基数(进制)，可选值，介于`2到36之间`，如果省略该参数或其值为0，则数字将以10为基础来解析。如果它以“0x”或“0X”开头，将以16为基数。如果该参数小于2或者大于36，则parseInt()将返回NaN。\n\n## 判断空对象\n\njs判断空对象\n#### 1. 将json对象转化为json字符串，再判断该字符串是否为'{}'\n```js\nvar data = {};\nvar b = (JSON.stringify(data) == \"{}\");\nalert(b);//true\n```\n\n#### 2. for in 循环判断\n```js\nvar obj = {};\nvar b = function() {\n   for(var key in obj) {\n      return false;\n    }\n    return true;\n}\nalert(b());//true\n```\n\n#### 3. Object.getOwnPropertyNames()方法\n注意：此方法不兼容ie8，其余浏览器没有测试\n```js\nvar data = {};\nvar arr = Object.getOwnPropertyNames(data);\nalert(arr.length == 0);//true\n```\n\n#### 4. 使用ES6的Object.keys()方法\n与3方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组\n```js\nvar data = {};\nvar arr = Object.keys(data);\nalert(arr.length == 0);//true\n```\n\n## 数组方法 sort排序\n不传排序规则函数时，默认是按照字符编码Unicode的顺序进行排序。\n```js\narr.sort((a, b) => a - b) // 升序\narr.sort((a, b) => a.age - b.age) // 按属性升序\narr.sort((a, b) => b - a) // 降序\narr.sort(() => Math.random() < 0.5 ? 1 : -1) // 乱序\n```\n\n## 数组方法 slice与concat\n`.slice(0)`与`.concat()`均不改变原数组，且均为**浅拷贝**，即副本仅为源数据的引用，当源数据的属性均为非引用类型时，浅拷贝也能像深拷贝一样达到主副对象属性隔离的目标，但当源数据属性为引用类型时，由于浅拷贝都是指针引用，则改变其一另一个也跟着变化。\n\n## 字符串常用方法\n- 字符方法：\n    - charAt()，返回在指定位置的字符\n    - charCodeAt()，返回在指定位置的字符的Unicode码\n- 位置方法：\n    - indexOf()\n    - lastIndexOf()\n- 删除首尾空格：\n    - trim()\n- 大小写转换方法：\n    - toLowerCase()\n    - toUpperCase()\n- 字符串操作方法：\n    - concat(),实际中用+号更方便\n    - slice(1,4) 截取1到3的字符串，支持负值，传入负值与长度相加\n\t- substring(1,4) 截取1到3的字符串，不接受负参数\n\t- substr()的第二个参数指定返回字符数\n- 字符串模式匹配方法：\n    - match()\n    - search()\n    - raplace()\n    - split()\n\n\n\n\n\n\n"},{"title":"点击li标签打印该其所处列表次序","url":"/Roundtables/Question-Bank/basic-grammar/li-index.html","content":"# 点击li标签打印该其所处列表次序\n\n```html\n<ul class=\"list\">\n    <li>item 1</li>\n    ...\n    <li>item 1</li>\n</ul>\n```"},{"title":"JS数值方法","url":"/Roundtables/Question-Bank/basic-grammar/number.html","content":"---\n{\n    title: JS数值方法\n}\n---\n# JS数值方法\n\n## 科学计数法\n\n以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。\n1. 小数点前的数字多于21位。\n\n```js\n1234567890123456789012\n// 1.2345678901234568e+21\n\n123456789012345678901\n// 123456789012345680000\n```\n2. 小数点后的零多于5个。\n\n```js\n// 小数点后紧跟5个以上的零，\n// 就自动转为科学计数法\n0.0000003 // 3e-7\n\n// 否则，就保持原来的字面形式\n0.000003 // 0.000003\n```\n\n## 与数值相关的全局方法\n### parseInt()\n\nparseInt方法用于将字符串转为整数。\n- 如果字符串头部有空格，空格会被自动去除。\n- 如果parseInt的参数不是字符串，则会先转为字符串再转换。\n\n```js\nparseInt(1.23) // 1\n// 等同于\nparseInt('1.23') // 1\n```\n\n- 字符串转为整数的时候，是**一个个字符依次转换**，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。\n\n```js\nparseInt('12abc') // 12\n```\n\n- 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。\n- 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。\n\n```js\nparseInt('0xff') // 255\n```\n\n- 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。\n\n```js\n// 这里整数部分有22位，超过了21位\nparseInt(1000000000000000000000.1) // 1\n// 相当于\nparseInt('1e+21') // 1\n\n// 控制台\n1000000000000000000000.1 // 输入\n1e+21 // 输出\n```\n\n#### parseInt()用于进制转换\n- parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数\n\n```ts\nfunction parseInt(str: string, decimal: number = 10): number;\n\n// 1000的二进制转化成十进制是 8\nparseInt('1000', 2) // 8\nparseInt('1000', 6) // 216\nparseInt('1000', 8) // 512\n// 超过36\nparseInt('10', 37) // NaN\nparseInt('10', 1) // NaN\nparseInt('10', 0) // 10\nparseInt('10', null) // 10\nparseInt('10', undefined) // 10\n```\n\n- 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。\n\n```js\n// 二进制没有5 4 6，因此只取了已经转换的值\nparseInt('1546', 2) // 1\nparseInt('546', 2) // NaN\n```\n\n- 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。\n\n```js\nparseInt(0x11, 36) // 43\nparseInt(0x11, 2) // 1\n\n// 等同于\nparseInt(String(0x11), 36)\nparseInt(String(0x11), 2)\n\n// 等同于\n// 十六进制的0x11会被先转为十进制的17，再转为字符串\nparseInt('17', 36)\nparseInt('17', 2)\n```\n\n- 对于八进制\n\n```js\nparseInt(011, 2) // NaN\n\n// 等同于\nparseInt(String(011), 2)\n\n// 等同于\nparseInt(String(9), 2)\n```\n\n> **注意**：JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。\n\n- 总结\n\nparseInt的第一个参数无论如何都会先转换为十进制表示法，再转换为字符串，最后将该字符串转换为十进制。\n\n### parseFloat()\n\n### isNaN()\n\n### isFinite()\nisFinite方法返回一个布尔值，表示某个值**是否为正常的数值**。\n\n```js\nisFinite(Infinity) // false\nisFinite(-Infinity) // false\nisFinite(NaN) // false\nisFinite(undefined) // false\nisFinite(null) // true\nisFinite(-1) // true\n```\n\n除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。\n\n## 参考文章\n\n[JavaScript 标准参考教程(基本语法之数值) —— 阮一峰](https://wangdoc.com/javascript/types/number.html)\n"},{"title":"编写js代码，实现奇数次调用时，打印1，偶数次调用时打印2","url":"/Roundtables/Question-Bank/basic-grammar/odd-even-print.html","content":"---\ntitle: 奇偶打印\ndate: 2019-01-14 10:21:00\ntags: [js, 算法]\ncategories: javascript\n---\n\n# 编写js代码，实现奇数次调用时，打印1，偶数次调用时打印2\n```js\nfoo(); // 1\nfoo(); // 2\nfoo(); // 1\nfoo(); // 2\n```\n\n## superwyk\n### 方法一\n```js\n// 闭包实现\nfunction foo(){\n    let flag = false; // 基数打印标记\n    return function(){\n        if(flag){\n            console.log(2);\n        } else{\n            console.log(1);\n        }\n        flag = !flag;\n    }\n}\nvar print = foo();\nprint();\n```\n\n### 方法二\n```js\n// es6 iterator实现\nvar foo = {\n    [Symbol.iterator]: function (){\n        let flag = false; // 基数打印标记\n        return {\n            next: function(){\n                let value = flag ? 2 : 1;\n                flag = !flag;\n                console.log(value);\n                return {\n                    value,\n                    done: false\n                }\n            }\n        }\n    }\n}\n\nvar print = foo[Symbol.iterator]().next;\nprint();\n```\n\n### 方法三\n```js\n// es6 generator实现\nfunction* gen() {\n    let flag = false; // 基数打印标记\n    for (; ;) {\n        if (flag) {\n            console.log(2);\n            flag = !flag;\n            yield 2;\n        } else {\n            console.log(1);\n            flag = !flag;\n            yield 1;\n        }\n    }\n}\nvar generator = gen();\nvar print = generator.next.bind(generator);\nprint();\n```\n\n## johninch\n\n### 方法一\n> 思路：使用自执行函数在定义时就执行，return之后的闭包函数才是foo的实际函数体这样每次调用foo就会自增闭包作用域中的count变量，从而判断奇偶不同输出\n```js\nconst foo = (() => {\n    let counter = 1;\n    return () => {\n        if (counter % 2 === 0) {\n            console.log(2)\n        } else {\n            console.log(1)\n        }\n        counter++\n    }\n})()\n\nfoo() // 1\nfoo() // 2\nfoo() // 1\nfoo() // 2\nfoo() // 1\nfoo() // 2\n```\n### 方法二\n```js\nlet foo = () => {\n  console.log(foo.counter++ % 2 ? 1 : 2);\n};\n\nfoo.counter = 1;\n\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\n```\n\n### 方法三\n使用Proxy代理一个`匿名函数`，通过实例的apply方法 拦截函数的调用；\n```js\nconst foo = new Proxy(function() {}, {\n  counter: 1,\n  apply: function(target, ctx, args) {\n    console.log(this.counter++ % 2 ? 1 : 2);\n    return Reflect.get(target, ctx, args);\n  }\n}\n);\n\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\n```\n\n> - Proxy对象的拦截操作（如上为apply，其他还有如get、delete、has...），内部调用对应的Reflect方法，保证原生行为能够正常执行。添加的额外工作，就是将每一次操作输出一行日志而已。\n> - Reflect对象的方法与Proxy对象的方法一一对应，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。\n\n### 方法四\n使用Proxy代理一个`空对象`，通过实例的get方法 对象的属性访问；\n```js\nconst bar = new Proxy({}, {\n      counter: 1,\n      get: function(target, propKey, receiver) {\n        console.log(this.counter++ % 2 ? 1 : 2);\n        return Reflect.get(target, propKey, receiver);\n      }\n    }\n  );\n\nconst foo = () => bar.counter\n\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\nfoo();\n```\n\n## Mtd\n\n```js\n// 匿名函数\nlet foo = (\n  function () {\n    let counter = 0;\n    return function () {\n      let _counter = ++counter % 2 === 0 ? 2 : 1;\n      console.log(_counter)\n    }\n  }\n)()\n\n// 代理\nlet foo = new Proxy(function () {}, {\n  counter: 0,\n  apply: function () {\n    let counter = ++this.counter % 2 === 0 ? 2 : 1;\n    console.log(counter)\n  }\n});\n\n\n```\n\n## Wlxm\n\n```js\nfunction log12() {\n  console.log(log12.counter++ % 2 === 0 ? 2 : 1);\n}\n\nlog12.counter = 1;\n```\n"},{"title":"打印树形目录结构，node实现","url":"/Roundtables/Question-Bank/basic-grammar/print-all-directory-file.html","content":"---\ntitle: 打印树形目录结构\ndate: 2019-01-14 10:46:00\ntags: [node, 算法]\ncategories: javascript\n---\n\n# 打印树形目录结构，node实现\n实现函数，参数为目录的路径。然后打印出类似命令行上的tree命令的效果。（可用node fs，如果fs操作不熟悉，可以自己声明变量保存目录的结构数据，然后将该变量输出）\n```\n├── app\n│   ├── components\n│   │   ├── Address\n│   │   ├── Button\n│   │   ├── CountrySelect\n│   │   ├── DatePicker\n│   │   ├── Debug\n```\n\n## superwyk\n### 方法一\n```js\n// 使用同步api实现，阻塞运行，性能不大好\nconst fs = require('fs');\nconst path = require('path');\n\nconst directoryLabel = '├── ';\nconst hierarchyLabel = '│   ';\n\nfunction printDirectory(dir, deep = \"\"){\n    const files = fs.readdirSync(dir, {encoding: 'utf-8'})\n    for(let i = 0; i < files.length; i++){\n        const childDir = path.resolve(dir, files[i]);\n\n        console.log(deep + directoryLabel + files[i]);\n        const stats = fs.statSync(childDir);\n        if(stats.isDirectory()){\n            printDirectory(childDir, deep + hierarchyLabel);\n        }\n    }\n}\n\nfunction printAllDirectory(dir){\n    console.log(directoryLabel + path.basename(dir));\n    printDirectory(dir, hierarchyLabel);\n}\n\nprintAllDirectory('/Users/wuyongkun/Documents/test');\n```\n#### warn: 异步执行api，有问题\n```js\n// 异步执行有问题，没有按文件夹嵌套顺序打印\nfunction printDirectory(dir, deep = \"\"){\n    fs.readdir(dir, {encoding: 'utf-8'}, function(err, files){\n        if(err) throw err;\n        for(let i = 0; i < files.length; i++){\n            const childPath = path.resolve(dir, files[i]);\n            console.log(deep + directoryLabel + files[i]);\n            fs.stat(childPath, function(err, stats){\n                if(err) throw err;\n                if(stats.isDirectory()){\n                    printDirectory(childPath, deep + hierarchyLabel);\n                }\n            })\n        }\n    });\n}\n```\n\n### 方法二\n```js\n// 异步化改造\nconst fs = require('fs');\nconst path = require('path');\n\nconst directoryLabel = '├── ';\nconst hierarchyLabel = '│   ';\n\nfunction readDir(directory){\n    return new Promise((resolve, reject) => {\n        fs.readdir(directory, {encoding: 'utf-8'}, function(err, files){\n            if(err) reject(err);\n            resolve(files);\n        });\n    });\n}\n\nfunction isDirectory(path){\n    return new Promise((resolve, reject) => {\n        fs.stat(path, function(err, stats){\n            if(err) reject(err);\n            resolve(stats.isDirectory());\n        })\n    })\n}\n\nasync function printDirectory(dir, deep = ''){\n    const files = await readDir(dir, deep);\n    for(const file of files){\n        const childDir = path.resolve(dir, file);\n        console.log(deep + directoryLabel + file);\n        const isdirectory = await isDirectory(childDir);\n        if(isdirectory){\n            await printDirectory(childDir, deep + hierarchyLabel);\n        }\n    }\n}\n\nfunction printAllDirectory(dir){\n    console.log(directoryLabel + path.basename(dir));\n    printDirectory(dir, hierarchyLabel);\n}\n\nprintAllDirectory('/Users/wuyongkun/Documents/test');\n```"},{"title":"一维数组中连续相同的数字转换成二维","url":"/Roundtables/Question-Bank/basic-grammar/to-2D-array.html","content":"# 一维数组中连续相同的数字转换成二维\n\n例如：[1,1,2,3,3,3,3,4,5,5,5,6,6] 将被转换为 [[1,1],2,[3,3,3],4,[5,5,5],[6,6]]\n\n## johninch\n```js\nfunction arrayTo2D(arr) {\n  let tempArr = [],\n    cur = arr[0],\n    newArr = [];\n\n  arr.forEach((item, i) => {\n    if (item === cur) {\n      tempArr = tempArr.concat(item);\n    } else {\n      tempArr.length > 1 ? newArr.push(tempArr) : newArr.push(tempArr[0]);\n      cur = item;\n      tempArr = [item];\n    }\n  });\n\n  tempArr.length > 1 ? newArr.push(tempArr) : newArr.push(tempArr[0]);\n\n  return newArr;\n}\n\nlet a = [1, 1, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 6];\n\nconsole.log(arrayTo2D(a));\n```\n## Caleb\n``` js\nfunction to2D(arr) {\n    if(!arr) return []\n    if(arr.length<2) return arr\n    let result = [];\n    let temporateArr = [];\n    for ( let i=0;i<arr.length;i++ ) {\n        if (temporateArr.length === 0 ) {\n            temporateArr.push(arr[i])\n        } else if (temporateArr.includes(arr[i])){\n            temporateArr.push(arr[i])\n        } else {\n            result.push(temporateArr.length>1? [...temporateArr] : temporateArr[0]);\n            temporateArr = [arr[i]];\n        }\n    }\n    if (temporateArr.length>0) {\n      result.push(temporateArr.length>1? [...temporateArr] : temporateArr[0]);\n    }\n  return result\n}\n```\n\n## superwyk\n```js\nfunction to2DArray(arr){\n    let result = [];\n    let i = 0, j = 1;\n    while(j < arr.length){\n        if(arr[i] === arr[j]){\n            j++;\n        } else {\n            if(i + 1 === j){\n                result.push(arr[i]);\n            } else{\n                result.push(arr.slice(i, j))\n            }\n            i = j;\n            j++;\n        }\n\n        if(j === arr.length){\n            if(i + 1 === j){\n                result.push(arr[i]);\n            } else{\n                result.push(arr.slice(i, j))\n            }\n        }\n    }\n\n    return result;\n}\n```\n\n## Febcat\n``` js\nconst arrayTo2D = arr => {\n  return [...new Set(arr)].map(item => {\n    let filterTtem = arr.filter(i => i === item);\n\n    return filterTtem.length !== 1 ? filterTtem : filterTtem[0];\n  });\n};\n\nconsole.log(\n  \"arrayTo2D\",\n  JSON.stringify(arrayTo2D([1, 1, 2, 3, 3, 3, 3, 4, 5, 5, 5, 6, 6]))\n);\n```\n\n## Mtd\n```js\nfunction arrayTo2D(arr) {\n  let arr2D = [];\n  let arr2Dindex = 0;\n\n  let start = arr[0];\n  let i = 1;\n  let next = arr[i];\n  let index = 0;\n\n  while (index < arr.length - 1) {\n    if (start === next) {\n      if (!arr2D[arr2Dindex]) {\n        arr2D[arr2Dindex] = [start, next]\n      } else {\n        Array.isArray(arr2D[arr2Dindex]) ? (arr2D[arr2Dindex].push(next)) : (arr2D[arr2Dindex] = [next, next])\n      }\n    } else {\n      arr2Dindex++;\n      arr2D[arr2Dindex] = next\n    }\n\n    index++;\n    i++;\n    start = next;\n    next = arr[i];\n  }\n\n  return arr2D\n}\n```\n\n## Wlxm\n```ts\nfunction composeArrRepeat(arr: any[]) {\n    const ret = [];\n    let len = arr.length;\n\n    if (len < 2) {\n        return [...arr];\n    }\n\n    let slider: any[];\n    let p = 0;\n    let q = 1;\n\n    while (q <= len) {\n        if (arr[p] !== arr[q]) {\n            slider = arr.slice(p, q);\n\n            if (slider.length < 2) {\n                ret.push(...slider);\n            } else {\n                ret.push(slider);\n            }\n\n            p = q;\n        }\n\n        q++;\n    }\n\n    return ret;\n}\n```"},{"title":"类型转换判断","url":"/Roundtables/Question-Bank/basic-grammar/type-judge.html","content":"# 类型转换判断\n\n```js\n4 + '5'; // '45'\n4 + true; // 5\n1 + 2 + '3' + 4; // '334'\n \n0 == false; // true\n0 == '0'; // true\n0 == ''; // true\n0 == null; // false\nnull == false; // false\n[] == []; // false\n[] == ![]; // true\n[] == 0; // true\nNaN == NaN; // false\n0 == NaN; // false\n1 === new Number(1); // false\n1 instanceof Number; // false\n \ntypeof []; // object\ntypeof null; // object\ntypeof /1/; // object\ntypeof abc; // undefined\ntypeof NaN; // number\ntypeof new Boolean(true); // object\n```\n\n知识点参考传送门：[JS专题-变量与类型-(4)JS的类型转换](/Roundtable/Question-Bank/basic-grammar/variablesAndTypes4)\n"},{"title":"JavaScript数据类型","url":"/Roundtables/Question-Bank/basic-grammar/variablesAndTypes1.html","content":"---\n{\n    \"title\": \"JS专题-变量与类型-(1)JS数据类型\",\n}\n---\n\n> 本文是在 ConardLi的“[【JS 进阶】你真的掌握变量和类型了吗](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)”文章上的总结和扩展，集中记述了js中的变量和数据类型的相关知识点及应用场景，共分为5部分。\n\n> 本文为“JS专题-变量与类型”的第一篇，1）JS数据类型，主要关注JS中变量在内存中的具体存储形式。\n\n<!-- more -->\n\n# JavaScript数据类型\n\n## 数据类型分类\n\n[ECMAScript标准](http://www.ecma-international.org/ecma-262/9.0/index.html)规定了`7`种数据类型，其把这`7`种数据类型又分为两种：原始类型 和 对象类型。\n- 原始类型\n    - Null：只包含一个值：null\n    - Undefined：只包含一个值：undefined\n    - Boolean：包含两个值：true和false\n    - Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）\n    - String：一串表示文本值的字符序列\n    - Symbol：一种实例是唯一且不可改变的数据类型\n(在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持)\n\n- 对象类型（引用类型）\n    - Object：除了常用的Object，Array、Date、RegExp、Function等都属于特殊的对象\n\n## 为什么区分原始类型和对象类型\n\n1. 首先搞明白原始类型的特性 —— `不可变性`\n\n    在ES标准中，原始类型被定义为`primitive values`，即原始值，代表值本身是不可被改变的。\n    以字符串为例：在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的。\n\n    ```js\n        var str = 'ConardLi';\n\n        str.slice(1);\n        str.substr(1);\n        str.trim(1);\n        str.toLowerCase(1);\n        str[0] = 1;\n\n        console.log(str);  // ConardLi\n    ```\n    这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变str，这就印证了字符串的不可变性。\n\n2. 内存空间 —— `栈内存`与`堆内存`\n    ```js\n        var str = 'ConardLi';\n\n        str += '6'\n\n        console.log(str);  // ConardLi6\n    ```\n    > 上面的str值改变了，这违背了原始值的不可变性吗？\n    并没有! 这在内存原理上是有根据的，在js中，变量在内存中需要空间来存储，`内存空间被分为两种，栈内存与堆内存`。\n\n    2.1 栈内存（原始类型）\n    - 存储的值大小固定\n    - 空间较小\n    - 可以直接操作其保存的变量，运行效率高\n    - 由系统自动分配存储空间\n\n    js中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。\n\n    ![栈示例](./images/variablesAndTypes/stack1.png)\n\n    执行 `str += '6'`的操作，实际上是在栈中`又开辟了一块内存空间`用于存储'ConardLi6'，然后将变量str指向这块空间，所以这`并不违背不可变性`的特点。\n\n    ![栈示例2](./images/variablesAndTypes/stack2.png)\n\n    2.2 堆内存（引用类型）\n    - 存储的值大小不定，可动态调整\n    - 空间较大，运行效率低\n    - 无法直接操作其内部存储，使用引用地址读取\n    - 通过代码进行分配空间和释放\n    - 如果程序员没有主动通过代码释放，则由操作系统自动回收\n\n    习惯于把对象称为引用类型，引用类型的`值实际存储在堆内存`中，它在`栈中只存储了一个固定长度的地址`，这个地址指向堆内存中的值。\n\n    ```js\n    var obj1 = {name:\"ConardLi\"}\n    var obj2 = {age:18}\n    var obj3 = function(){...}\n    var obj4 = [1,2,3,4,5,6,7,8,9]\n    ```\n    ![堆示例](./images/variablesAndTypes/heap.png)\n\n    当然，引用类型就不再具有不可变性了，可以轻易改变它。\n\n    以数组为例，它的很多方法都是`变异方法`，都可以改变它自身。\n    - `pop()` 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素\n    - `push()` 向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度\n    - `shift()` 把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值\n    - `unshift()` 向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度\n    - `reverse()` 颠倒数组中元素的顺序，改变原数组，返回该数组\n    - `sort()` 对数组元素进行排序，改变原数组，返回该数组\n    - `splice()` 从数组中添加/删除项目，改变原数组，返回被删除的元素\n\n## `比较`原始类型与引用类型\n复制、比较、值传递和引用传递\n\n### 复制\n关于复制，原始类型和引用类型的表现是不一样的：\n- 原始类型的复制\n```js\nvar name = 'ConardLi';\nvar name2 = name;\nname2 = 'code秘密花园';\nconsole.log(name); // ConardLi;\n```\n![原始类型复制](./images/variablesAndTypes/copy-basic-type.png)\n内存中有一个变量name，值为ConardLi。我们从变量name复制出一个变量name2，此时在内存中`创建了一个块新的空间`用于存储ConardLi，虽然两者值是相同的，但是`两者指向的内存空间完全不同`，这两个变量参与任何操作都互不影响。\n\n- 引用类型的复制\n```js\nvar obj = {name:'ConardLi'};\nvar obj2 = obj;\nobj2.name = 'code秘密花园';\nconsole.log(obj.name); // code秘密花园\n```\n![引用类型复制](./images/variablesAndTypes/copy-reference-type.png)\n当我们复制引用类型的变量时，`实际上复制的是栈中存储的地址`，所以复制出来的obj2实际上和obj`指向的堆中同一个对象`。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，`这就是为什么会有深拷贝和浅拷贝`的原因。\n\n### 比较\n- `对于原始类型，比较时会直接比较它们的值`，如果值相等，即返回true。\n- `对于引用类型，比较时会比较它们的引用地址`，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。\n\n![类型比较](./images/variablesAndTypes/Comparison-of-types.png)\n\n### 值传递和引用传递\n\n- 参数是原始类型\n```js\nlet name = 'ConardLi';\nfunction changeValue(name) {\n    name = 'code秘密花园';\n}\nchangeValue(name);\nconsole.log(name); // 'ConardLi'\n```\n是`值传递`：函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。\n\n- 参数是引用类型\n```js\nlet obj = {};\nfunction changeValue(obj) {\n    obj.name = 'ConardLi';\n    obj = {name:'code秘密花园'};\n}\nchangeValue(obj);\nconsole.log(obj.name); // ConardLi\n```\n同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，依然是`值传递`\n::: tip\n明确一点，ECMAScript中所有的函数的参数都是**按值传递**的。\n:::\n"},{"title":"分不清的`null`和`undefined`","url":"/Roundtables/Question-Bank/basic-grammar/variablesAndTypes2.html","content":"---\ntitle: JS专题-变量与类型-(2)JS 3种疑难基础类型\ndate: 2019-11-14 19:56:00\ntags: [前端基础, 变量, 数据类型]\ncategories: javascript\n---\n\n> 本文是在 ConardLi的“[【JS 进阶】你真的掌握变量和类型了吗](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)”文章上的总结和扩展，集中记述了js中的变量和数据类型的相关知识点及应用场景，共分为5部分。\n\n> 本文为“JS专题-变量与类型”的第2篇，2）JS 3种疑难基础类型，主要关注null/undefined，Symbol，Number三种疑难基础JS类型。\n\n<!-- more -->\n\n## 分不清的`null`和`undefined`\n\n在原始类型中，有两个类型Null和Undefined，他们都有且仅有一个值，null和undefined\n\n- `null`\n    - 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。\n    - 所以对象的某个属性值为null是正常的，null转换为数值时值为`0`。\n- `undefined`\n    - 表示“缺少值”，即此处应有一个值，但还没有定义，\n    - 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。\n    - undefined 转为数值时为`NaN`(非数字值的特殊值)\n    - 典型用法是：变量被声明了，但没有赋值时，就等于undefined；调用函数时，应该提供的参数没有提供，该参数等于undefined；对象没有赋值的属性，该属性的值为undefined；函数没有返回值时，默认返回undefined。\n\n> JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有\"undefined\"这种情况，就会直接编译失败，所以在它不需要一个这样的类型。\n\n## 不太熟的`Symbol`类型\n\nSymbol类型是ES6中新加入的一种原始类型。\n\n### Symbol的特性\n\n1. 独一无二\n\n    直接使用Symbol()创建新的symbol变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的toString()方法。\n\n    ```js\n    var sym1 = Symbol();  // Symbol() \n    var sym2 = Symbol('ConardLi');  // Symbol(ConardLi)\n    var sym3 = Symbol('ConardLi');  // Symbol(ConardLi)\n    console.log(sym2 === sym3);  // false\n\n    var sym4 = Symbol({name:'ConardLi'}); // Symbol([object Object])\n    ```\n\n    用两个相同的字符串创建两个Symbol变量，它们是不相等的，独一无二的。\n\n    如果我们想创造两个相等的Symbol变量，可以使用`Symbol.for(key)`。\n    > 使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。\n\n    ```js\n    var sym1 = Symbol.for('ConardLi');\n    var sym2 = Symbol.for('ConardLi');\n    console.log(sym1 === sym2); // true\n    ```\n\n2. 原始类型\n\n    注意是使用Symbol()函数创建symbol变量，并非使用构造函数，使用new操作符会直接报错。\n    ```js\n    new Symbol(); // Uncaught TypeError: Symbol is not a constructor\n    ```\n    可以使用typeof运算符判断一个Symbol类型:\n    ```js\n    typeof Symbol() === 'symbol'\n    typeof Symbol('ConardLi') === 'symbol'\n    ```\n\n3. 不可枚举\n\n- 当使用Symbol作为对象属性时，可以保证对象不会出现重名属性，调用`for...in`不能将其枚举出来，另外调用`Object.getOwnPropertyNames`、`Object.keys()`也不能获取Symbol属性。\n\n- 可以调用`Object.getOwnPropertySymbols()`用于专门获取Symbol属性。\n\n    ```js\n    var obj = {\n        name: 'ConardLi',\n        [Symbol('name2')]: 'code秘密花园'\n    }\n    Object.getOwnPropertyNames(obj); // [\"name\"]\n    Object.keys(obj); // [\"name\"]\n    for (var i in obj) {\n        console.log(i); // name\n    }\n    Object.getOwnPropertySymbols(obj) // [Symbol(name)]\n    ```\n\n### Symbol的应用场景\n\n- 应用一：防止XSS\n\n    JSON中不能存储Symbol类型的变量，这就是防止XSS的一种手段\n\n- 应用二：私有属性\n    在类中模拟私有属性，控制变量读写：\n    ```js\n    const privateField = Symbol();\n    class myClass {\n        constructor() {\n            this[privateField] = 'ConardLi';\n        }\n        getField() {\n            return this[privateField];\n        }\n        setField(val) {\n            this[privateField] = val;\n        }\n    }\n    ```\n\n- 应用三：防止属性污染\n\n    在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用Symbol作为对象属性可以保证永远不会出现同名属性。\n\n\n## 不老实的`Number`类型（取值精度与大数问题）\n\n小数精度计算不精确的问题：比如0.1+0.2!==0.3\n\n### 1. 为什么会出现 `精度丢失`？\n\n计算机中所有的数据都是`以二进制存储`的，所以在计算时计算机要把数据先转换成`二进制`进行计算，然后再把计算结果转换成`十进制`。在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。\n\n### 2. 小数的`二进制`大多数都是`无限循环`的，JS是`怎么来存储`他们的呢？\n\n- ECMAScript中的Number类型遵循`IEEE 754`标准。使用`64位固定长度`来表示。不单单是JS，很多语言的数字类型都遵循这个标准，例如JAVA,所以很多语言同样有着上面同样的问题。\n\n    ![精度位数](./images/variablesAndTypes/precision.png)\n\n- IEEE754标准 包含一组实数的二进制表示法。它有三部分组成：符号位、指数位、尾数位。JS使用的是`64位双精度浮点数编码`，所以它的`符号位`占`1位`，`指数位`占`11位`，`尾数位`占`52位`。\n\n- `符号位`就是标识正负的，`1`表示`负`，`0`表示`正`；`指数位`存储科学计数法的指数；`尾数位`存储科学计数法后的`有效数字`；\n\n    ![64位双精度](./images/variablesAndTypes/64double.png)\n\n    以`0.1`为例：它的二进制为：`0.0001100110011001100...`，为了节省存储空间，在计算机中它是以科学计数法表示的，也就是 1.100110011001100... X 2<sup>-4</sup>\n\n所以我们 **通常看到的二进制，其实是计算机实际存储的尾数位。**\n\n### 3. JS中的`toString(2)`\n\n- 由于尾数位只能存储52个数字，这就能解释toString(2)的执行结果了:由于限制，有效数字第53位及以后的数字是不能存储的，它遵循，如果是1就向前一位进1，如果是0就舍弃的原则。\n\n- 0.1的二进制科学计数法第53位是1，0.2有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了0.1+0.2!=0.3。\n\n- 事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决:\n    - [number-precision](https://github.com/nefe/number-precision)\n    - [mathjs](https://github.com/josdejong/mathjs/)\n\n### 4. JS能表示的`最大数字`\n\n- 由与IEEE 754双精度64位规范的限制：64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数。\n\n- 则 JS 能够表示的数值范围为 2<sup>1024</sup> 到 2<sup>-1023</sup> 之间（`不含两个端点`），超出这个范围的数无法表示。\n\n- 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JS 无法表示这么大的数，这时就会返回Infinity。\n    ```js\n    Math.pow(2, 1024) // Infinity\n    ```\n- 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JS 无法表示这么小的数，这时会直接返回0。\n    ```js\n    Math.pow(2, -1075) // 0\n    ```\n- JS 提供Number对象的`MAX_VALUE`和`MIN_VALUE`属性，\n    ```js\n    Number.MAX_VALUE // 1.7976931348623157e+308\n    Number.MIN_VALUE // 5e-324\n    Math.pow(2, -1074) // 5e-324\n    ```\n    尾数位能表达的最大数字即尾数位都为 1的情况，所以JS 能表示的`最大数字`即为 1.111...X 2<sup>1023</sup>这个结果转换成十进制是1.7976931348623157e+308,这个结果即为`Number.MAX_VALUE`。\n\n### 5. `最大安全整数`\n\n- JS 能够准确表示的整数范围在 -2<sup>53</sup> 到 2<sup>53</sup> 之间（`不含两个端点`），超过这个范围，无法精确表示这个值。\n\n    ```js\n    Math.pow(2, 53) // 9007199254740992\n    9007199254740992  // 9007199254740992\n\n    // 超出2的53次方之后，这个数就不精确了\n    9007199254740993  // 9007199254740992\n    Math.pow(2, 53) === Math.pow(2, 53) + 1 // true\n    ```\n\n- JS 中`Number.MAX_SAFE_INTEGER`表示最大安全整数，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是1.111...X 2<sup>52</sup>。\n\n- ES6 引入了 `Number.MAX_SAFE_INTEGER` 和 `Number.MIN_SAFE_INTEGER` 这两个常量，用来表示这个范围的上下限（JS能够精确表示的极限）:\n\n    ```js\n    Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true\n    Number.MAX_SAFE_INTEGER === 9007199254740991 // true\n    \n    Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true\n    Number.MIN_SAFE_INTEGER === -9007199254740991 // true\n    ```\n\n- 官方也考虑到了这个问题，bigInt类型在es10中被提出，现在Chrome中已经可以使用，使用bigInt可以操作超过最大安全数字的数字。但我们同样可以用工具库来帮助我们解决:\n    - [node-bignum)](https://github.com/justmoon/node-bignum)\n    - [node-bigint](https://github.com/substack/node-bigint)\n\n"},{"title":"引用类型细分","url":"/Roundtables/Question-Bank/basic-grammar/variablesAndTypes3.html","content":"---\ntitle: JS专题-变量与类型-(3)JS 其他引用类型\ndate: 2019-11-18 15:10:11\ntags: [前端基础, 变量, 数据类型, 装箱拆箱]\ncategories: javascript\n---\n\n> 本文是在 ConardLi的“[【JS 进阶】你真的掌握变量和类型了吗](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)”文章上的总结和扩展，集中记述了js中的变量和数据类型的相关知识点及应用场景，共分为5部分。\n\n> 本文为“JS专题-变量与类型”的第3篇，3）JS 其他引用类型，主要关注常用的引用类型（Object、Array、Date、RegExp、Function）之外，三种包装类型（Boolean、Number、String）。\n\n<!-- more -->\n\n# 引用类型细分\n\n在ES标准定义中，Object代表了引用类型，其实它的背后代表了很多引用类型变量，它们并不是由Object构造的，但是它们原型链的终点都是Object。\n\n## 普通引用类型\n\n- Object 对象\n- Array 数组\n- Date 日期\n- RegExp 正则\n- Function 函数\n\n## 特殊引用类型：包装类型\n\n- Boolean\n- Number\n- String\n\n```js\ntrue === new Boolean(true); // false\n123 === new Number(123); // false\n'ConardLi' === new String('ConardLi'); // false\nconsole.log(typeof new String('ConardLi')); // object\nconsole.log(typeof 'ConardLi'); // string\n```\n\n### 为什么要有包装类型（包装类型和原始类型的区别）？\n\n> 引用类型和包装类型的主要区别就是**对象的生存期**。\n> 使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。\n\n既然原始类型不能扩展属性和方法，为了便于操作基本类型值，ES就提供了上述3种包装类型。那么我们是如何使用原始类型调用方法的呢？这就要引出装箱与拆箱了。\n\n### 装箱与拆箱\n\n- 装箱转换：把基本类型转换为对应的包装类型\n- 拆箱操作：把引用类型转换为基本类型\n\n每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码：\n\n```js\nvar name = \"ConardLi\";\nvar name2 = name.substring(2);\n```\n实际上发生了以下几个过程：\n1. 创建一个String的包装类型实例\n2. 在实例上调用substring方法\n3. 销毁实例\n\n也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用Number和Boolean类型时，也会发生这个过程。\n\n从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的`toPrimitive`原则来进行`抽象操作`，一般会调用引用类型的`valueOf`和`toString`。\n\n### 自动拆箱规则（`toPrimitive` 转换规则）\n- **默认情况下，执行这个抽象操作时会`先执行valueOf`方法，如果返回的不是原始值，会`继续执行toString`方法，如果返回的还不是原始值，那么会报错**;\n- 如果有指定转换类型时，情况又会有所不同：\n    - 引用类型转换为Number类型，先调用valueOf，再调用toString\n    - 引用类型转换为String类型，先调用toString，再调用valueOf\n    - 若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。\n- 注意：valueOf和toString方法在Date，array等对象中有些是被重写过的，所以不同对象调用此方法可能产生的操作不同，如果没有这些方法，会调用最原始的Object.prototype上的valueOf和toString方法\n\n### 主动拆箱装箱（显式类型转换）\n除了上述程序中自动的拆箱装箱操作，我们也可以手动拆箱装箱：\n```js\nvar num = new Number(\"123\");  \nconsole.log( typeof num.valueOf() ); //number\nconsole.log( typeof num.toString() ); //string\n```\n"},{"title":"JS的类型转换","url":"/Roundtables/Question-Bank/basic-grammar/variablesAndTypes4.html","content":"---\ntitle: JS专题-变量与类型-(4)JS的类型转换\ndate: 2019-11-21 11:03:52\ntags: [前端基础, 变量, 数据类型, 类型转换]\ncategories: javascript\n---\n\n> 本文是在 ConardLi的“[【JS 进阶】你真的掌握变量和类型了吗](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)”文章上的总结和扩展，集中记述了js中的变量和数据类型的相关知识点及应用场景，共分为5部分。\n\n> 本文为“JS专题-变量与类型”的第4篇，4）JS的类型转换，由于JavaScript是`弱类型`的语言，所以类型转换发生非常频繁，前一章的装箱和拆箱其实就是一种类型转换。类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。强制转换规则比较正常，在前一篇包装类型中已有描述，本文主要关注`让人头疼的可能发生隐式类型转换`的几个场景，以及如何转换：\n\n<!-- more -->\n\n# JS的类型转换\n\n由于JavaScript是`弱类型`的语言，所以类型转换发生非常频繁，前一章的装箱和拆箱其实就是一种类型转换。类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。强制转换规则比较正常，在前一篇包装类型中已有描述，本文主要关注`让人头疼的可能发生隐式类型转换`的几个场景，以及如何转换：\n\n## 隐式类型转换的场景\n- if语句和逻辑语句\n- 数学运算符\n- Native调用(如console.log、alert)\n\n## 类型转换规则\n\n各种类型间互转所符合的隐式类型转换规则如下表：\n\n![隐式类型转换规则表](./images/variablesAndTypes/implicit-conversion-rules.png)\n\n### if语句和逻辑语句\n\n在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面`6种`情况会转换成false，`null、undefined、''、NaN、0、false`。\n\n\n### 数学运算符\n\n- 在对各种`非Number`类型运用除加法之外的数学运算符`(- * / % > < )`时，会先将`非Number`类型转换为`Number`类型:\n\n```js\n1 - true // 0\n1 - null //  1\n1 * undefined //  NaN\n2 * ['5'] //  10\n```\n\n- 注意：`+是个例外`，它既可以是算术加号，又可以是字符串连接符号，具体的要看它的操作数：\n    1. 当一侧为String类型，会优先将另一侧转换为字符串类型进行`拼接`。\n    2. 当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型`相加`。\n    3. 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后`拼接`。\n\n```js\n123 + '123' // 123123   （规则1）\n123 + null  // 123    （规则2）\n123 + true // 124    （规则2）\n123 + {}  // 123[object Object]    （规则3）\n```\n\n- 注意：`{}更是个例外`，{}在+号前，系统判断其为代码块，不参加运算；{}在+号后，被当做对象处理：\n\n```js\n123 + {} // 123[object Object]\n{} + 123 // 123 \n123 - {} // NaN\n{} - 123 // -123\n```\n\n## ==\n\n使用`==`时，若两侧类型相同，则比较结果和`===`相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）：\n\n1. NaN\n\n`NaN`和其他任何类型比较永远返回false(包括和他自己)。\n```js\nNaN == NaN // false\n```\n\n2. Boolean\n\nBoolean和其他任何类型比较，`Boolean首先被转换为Number类型`。\n    **注意：**undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0：\n```js\ntrue == 1  // true \ntrue == '2'  // false\ntrue == ['1']  // true\ntrue == ['2']  // false\n\nundefined == false // false\nnull == false // false\n```\n\n3. null和undefined\n\n`null == undefined`比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。\n```js\nnull == undefined // true\nnull == '' // false\nnull == 0 // false\nnull == false // false\nundefined == '' // false\nundefined == 0 // false\nundefined == false // false\n```\n\n4. String和Number\n\nString和Number比较，先将String转换为Number类型。\n```js\n123 == '123' // true\n'' == 0 // true\n```\n\n5. 原始类型和引用类型\n\n当原始类型和引用类型做比较时，引用类型会依照`ToPrimitive`规则转换为原始类型:\n```js\n'[object Object]' == {} // true\n'1,2,3' == [1, 2, 3] // true\n```\n**注意：**\n```js\n[] == ![] // true\n```\n复制代码!的优先级高于==，![]首先会被转换为false，然后根据上面第二点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。\n```js\n[null] == false // true\n[undefined] == false // true\n```\n复制代码根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0\n\n::: warning\n既然 == 有这么多坑，请务必使用 === 来判断值相等\n:::\n\n## `!`非逻辑\n\n逻辑非（!）操作符首先通过`Boolean()`函数将它的操作值转换为布尔值，`然后求反`。\n\n## 有意思的面试题\n\n#### 一道经典的面试题，如何让：`a == 1 && a == 2 && a == 3`。\n根据`拆箱转换`，以及`==的隐式转换`，写出答案：\n```js\nconst a = {\n   value:[3,2,1],\n   valueOf: function () {return this.value.pop(); },\n}\n```\n\n#### 如何判断两个对象相等\n转换为字符串判断\n```js\nJSON.stringify(obj) === JSON.stringify(obj2); // true\n```\n"},{"title":"JS的类型判断方法","url":"/Roundtables/Question-Bank/basic-grammar/variablesAndTypes5.html","content":"---\ntitle: JS专题-变量与类型-(5)JS的类型判断方法\ndate: 2019-11-21 19:33:29\ntags: [前端基础, 变量, 数据类型, 类型判断]\ncategories: javascript\n---\n\n> 本文是在 ConardLi的“[【JS 进阶】你真的掌握变量和类型了吗](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)”文章上的总结和扩展，集中记述了js中的变量和数据类型的相关知识点及应用场景，共分为5部分。\n\n> 本文为“JS专题-变量与类型”的第5篇，5）JS的类型判断方法，推荐使用 `typeof`、`Object.prototype.toString.call()`，不要用`instanceof`。\n\n<!-- more -->\n\n# JS的类型判断方法\n\n推荐使用 `typeof`、`Object.prototype.toString.call()`，不要用`instanceof`。\n\n## typeof\n\n**typeof可以用来准确判断**\n- 除`null以外的原始类型`\n- 以及`function`这种引用类型\n```js\ntypeof 'ConardLi'  // string\ntypeof 123  // number\ntypeof true  // boolean\ntypeof Symbol()  // symbol\ntypeof undefined  // undefined\n\ntypeof function(){}  // function\n```\n**typeof不适用于判断**\n- 大部分引用类型（除了上面的function类型）\n- 原始类型 null\n```js\ntypeof [] // object\ntypeof {} // object\ntypeof new Date() // object\ntypeof /^\\d*$/; // object\n\ntypeof null // object  初版Js就留下来的bug\n```\n\n## instanceof\n\n::: warning\n首先要明确一点的是：**使用instanceof来检测数据类型不是它的设计初衷**，它`不能检测原始数据类型`，且`对于引用类型的判断也不准确`。\n:::\n\n它可以判断一些引用类型，原理是通过原型链：\n```js\n[] instanceof Array // true\nnew Date() instanceof Date // true\nnew RegExp() instanceof RegExp // true\n```\n简单回顾下原型链的规则：\n- 1.`所有引用类型都具有对象特性`，即可以自由扩展属性\n- 2.所有引用类型都具有一个`__proto__（隐式原型）`属性，是一个普通对象\n- 3.所有的**函数**都具有`prototype（显式原型）`属性，也是一个普通对象\n- 4.所有引用类型`__proto__`值指向它构造函数的`prototype`\n- 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的`__proto__`中去找\n\n`[] instanceof Array`是用来判断 对象[] 是否是构造函数 Array 的实例。其原理是根据 实例对象[] 的__proto__属性 与 构造函数 Array 的prototype属性 `是否引用的是同一个原型对象地址来判断`的。\n\n`[] instanceof Array`实际上是判断`Array.prototype`是否在`[]`的原型链上，但在这条原型链上的构造函数都是实例对象的构造函数，因此通过原型来判断就会造成误差：\n```js\n[] instanceof Object // true\nfunction(){}  instanceof Object // true\n```\n\n> 顺便想一下：怎样判断一个实例对象的直接构造函数是谁呢？\n>> 只能通过原型对象的constructor属性来判断是否：`o.__proto__.constructor === M`\n>>> 注意：o.__proto__.constructor与o.constructor是一样的，其实本质就是通过原型链找到constructor属性。\n\n## toString\n\n- 在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。\n- 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。`如果此方法在自定义对象中未被覆盖`，toString() 返回 **\"[object type]\"**，其中type是对象的类型。\n- 上面提到了`如果此方法在自定义对象中未被覆盖`，toString才会达到预想的效果，事实上，大部分引用类型比如`Array、Date、RegExp`等**都重写了toString方法**。\n- 我们可以直接调用Object原型上未被覆盖的toString()方法，使用`call来改变this`指向来达到我们想要的效果。\n\n![Object.prototype.toString.call()](./images/variablesAndTypes/Object.prototype.toString.call.png)\n\n"},{"title":"BOM基础（五大对象）","url":"/Roundtables/Question-Bank/bom/bom-base.html","content":"---\ntitle: BOM基础（五大对象）\ntags: [Window, Location, Navigator, Screen, History]\ncategories: bom\n---\n\n# BOM基础（五大对象）\n\n## Window对象\n- window对象是js中的顶级对象，所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法。\n- 在调用的时候可以省略window。\n- window.open()与window.close()\n\n## Location对象\n\n### 属性\n\n封装当前窗口正在打开的url的对象，location可获得url中各个部分。\n\n- `location.hash`：设置或返回从井号 (#) 开始的 URL（锚）。\n- `location.host`：设置或返回主机名和当前 URL 的端口号。\n- `location.hostname`：设置或返回当前 URL 的主机名。\n- `location.port`：设置或返回当前 URL 的端口号。\n- `location.protocol`：设置或返回当前 URL 的协议。\n- `location.pathname`：设置或返回当前 URL 的路径部分，`从域名后的/到?前`。\n- `location.search`：设置或返回`从问号 (?) 开始`的 URL（查询部分）。\n- 跳转: location=\"url\"；location.href=\"url\"；location.assign(\"url\"); 以下效果一样：\n    - `window.location` = \"http://www.cnblogs.com\";\n    - `location.href`=\"http://www.cnblogs.com\";\n    - `location.assign`(\"http://www.cnblogs.com\");\n- 跳转: 禁止后退 `location.replace`(\"url\")。\n- 刷新: `location.reload`([force])，`force是可选参数`，默认为 false，从客户端缓存里取当前页。\n \t   当设置为 true，则以 GET 方式，从服务端取最新的页面，相当于客户端点击 F5(\"刷新\")。\n\n### 重定向 href与replace的区别\n- location.href='http://www.xxx.com/'，会在浏览器的历史浏览记录，即history对象中增加一条新的记录。\n- location.replace('http://www.xxx.com/')，相当于用replace中的url`替换`了现有的页面url，并把`history中的url也替换为重定向后的url`。因此是`后退不了`的。\n\n\n## History对象\n\n保存当前窗口打开过的url的历史记录栈。\n\n- 前进一页：history.go(1)；\n- 后退一页：history.go(-1)；\n- 刷新：history.go(0)；\n- 前进一页：history.forward();\n- 后退一页：history.back();\n\n### H5中 History 新增API\n\n- `history.pushState()`      ：添加新的状态到历史状态栈\n- `history.replaceState()`   ：用新的状态代替当前状态\n- `history.state `           ：返回当前状态对象\n\n传送门：[前端路由-history模式](./router.html#history模式)\n\n\n## Navigator对象\n\n封装浏览器配置信息的对象。\n\n- `navigator.userAgent`: 描述浏 **览器名称** 和 **版本号** 的字符串。\n- `navigator.geolocation`: 只读属性返回一个 Geolocation 对象，通过这个对象可以访问到设备的位置信息:\n    - Geolocation.getCurrentPosition()：确定设备的位置并返回一个携带位置信息的 Position 对象。\n- `navigator.cookieEnabled`: 识别浏览器是否启用了cookie，如果启用，返回true，否则返回false。\n- `navigator.plugins`: 保存了浏览器安装的所有插件的信息。\n\n## Screen对象\n\nScreen对象包含有关客户端显示屏幕的信息。获取screen.XXX属性。\n\n### 图解 ev.clientX，ev.screenX，ev.pageX，ev.offsetX\n\n![](./images/screen-distance.png)\n\n- `clientX` 是目标点距离`浏览器视口左边界`中的位置；\n- `screenX` 是目标点距离`显示器左边界`的位置；\n- `pageX` 是目标点距离`页面左边界`中的位置（`clienX+横向滚动条距离`）；\n- `offsetX` 是目标点距离`当前dom左边沿`的位置；\n\n"},{"title":"前端路由模式","url":"/Roundtables/Question-Bank/bom/router.html","content":"---\ntitle: 前端路由模式\ntags: [SPA, hash, history]\ncategories: bom\n---\n\n# 前端路由模式\n\n## 什么是 SPA\nSPA (single page web application) 译为单页Web应用。\n简单的说 SPA 就是一个WEB项目只有一个 HTML 页面，一旦页面加载完成，SPA 不会跳转到其他页面，而是利用 JS 动态的变换 HTML 的内容，从而来模拟多个视图间跳转。\n\n![](./images/spa.png)\n\n在 SPA 的应用设计中，一个应用只有一个HTML文件，在HTML文件中包含一个占位符（即图中的 container），占位符对应的内容由每个视图来决定，对于 `SPA 来说，页面的切换就是视图之间的切换`。\n\n## SPA 优缺点\n\n### 优点\n- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n- 对服务器压力小；\n- 前后端职责分离，架构清晰；\n### 缺点\n- **首次加载耗时多**：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n- **需要管理前进后退路由**：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\n- **SEO 难度较大**：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n\n## 前端路由\n\n### 为什么会有「前端路由」\nAjax异步获取数据，从而促使了Spa发展，动态改变html，无需刷新页面而更新，提升了WEB交互体验，但因为SPA中页面本身的 url不会变化，这导致了两个问题：\n- SPA **无法记住用户的操作记录**，无论是`刷新`、`前进`还是`后退`，都无法展示用户真实的期望内容。\n- SPA 中虽然由于业务的不同会有多种页面展示形式，但`对 SEO 不友好`，**只有一个 url，不方便搜索引擎进行收录**。\n\n### 『前端路由』是什么\n\n简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，`为 SPA 中的每个视图展示形式匹配一个特殊的 url`。`在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现`。\n\n::: tip 实现两点\n因此，前端路由需要**实现两点**：\n1. 能改变 url 但不让浏览器向服务器发送请求。\n2. 可以监听到 url 的变化。\n:::\n\nhash、history模式都可以实现上述两点。\n\n## hash模式\n\n这里的 hash 就是指 url 后的 # 号以及后面的字符。比如说 \"www.baidu.com/#XXXX\" 中的\"#XXXX\"。[传送门]\n\n### hash模式原理\n\n由于 `hash 值的变化不会导致浏览器向服务器发送请求`，而且 hash 的改变会`触发 hashchange 事件`，因此符合「前端路由」的实现条件。在H5的history模式出现之前，都是用hash模式的。\n\n### 基于hash方式「实现简单前端路由」\n\n::: details 代码\n```js\nclass HashRouter{\n    constructor(){\n        //用于存储不同hash值对应的回调函数\n        this.routers = {};\n        window.addEventListener('hashchange',this.load.bind(this),false)\n    }\n    //用于注册每个视图\n    register(hash,callback = function(){}){\n        this.routers[hash] = callback;\n    }\n    //用于注册首页\n    registerIndex(callback = function(){}){\n        this.routers['index'] = callback;\n    }\n    //用于处理视图未找到的情况\n    registerNotFound(callback = function(){}){\n        this.routers['404'] = callback;\n    }\n    //用于处理异常情况\n    registerError(callback = function(){}){\n        this.routers['error'] = callback;\n    }\n    //用于调用不同视图的回调函数\n    load(){\n        let hash = location.hash.slice(1),\n            handler;\n        //没有hash 默认为首页\n        if(!hash){\n            handler = this.routers.index;\n        }\n        //未找到对应hash值\n        else if(!this.routers.hasOwnProperty(hash)){\n            handler = this.routers['404'] || function(){};\n        }\n        else{\n            handler = this.routers[hash]\n        }\n        //执行注册的回调函数\n        try{\n            handler.apply(this);\n        }catch(e){\n            console.error(e);\n            (this.routers['error'] || function(){}).call(this,e);\n        }\n    }\n}\n```\n演示一下：\n```html\n<body>\n    <div id=\"nav\">\n        <a href=\"#/page1\">page1</a>\n        <a href=\"#/page2\">page2</a>\n        <a href=\"#/page3\">page3</a>\n        <a href=\"#/page4\">page4</a>\n        <a href=\"#/page5\">page5</a>\n    </div>\n    <div id=\"container\"></div>\n    <script>\n        let router = new HashRouter();\n        let container = document.getElementById('container');\n\n        //注册首页回调函数\n        router.registerIndex(() => container.innerHTML = '我是首页');\n\n        //注册其他视图回到函数\n        router.register('/page1',() => container.innerHTML = '我是page1');\n        router.register('/page2',() => container.innerHTML = '我是page2');\n        router.register('/page3',() => container.innerHTML = '我是page3');\n        router.register('/page4',() => {throw new Error('抛出一个异常')});\n\n        //加载视图\n        router.load();\n        //注册未找到对应hash值时的回调\n        router.registerNotFound(() => container.innerHTML = '页面未找到');\n        //注册出现异常时的回调\n        router.registerError((e) => {\n            container.innerHTML = '页面异常，错误消息：<br>' + e.message);\n        })\n    </script>\n</body>\n```\n:::\n\n\n\n## history模式\n\n传送门 [H5中 History 新增API](./bom-base.html#h5%E4%B8%AD-history-%E6%96%B0%E5%A2%9Eapi)\n\n### histroy模式原理\n\n1. 由于 **history.pushState()** 和 **history.replaceState()** `可以改变 url 同时，不会刷新页面`，所以在 HTML5 中的 histroy 具备了实现前端路由的能力：\n    - **参数**\n        history.pushState() 和 history.replaceState() 均接收三个参数（state, title, url）：\n        - state：合法的 JS 对象，可以用在 `popstate事件`中，[传送门：window.onpopstate](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onpopstate) ；\n        - title：现在大多浏览器忽略这个参数，可以直接用 null 代替；\n        - url：任意有效的 URL，用于更新浏览器的地址栏；\n    - **history.pushState() 和 history.replaceState() 的区别**\n        - history.pushState() 在保留现有历史记录的同时，将 url 加入到历史记录中。\n        - history.replaceState() 会将历史记录中的当前页面历史替换为 url。\n\n2. 关于如何监听，因为history 的改变并不会触发任何事件，所以我们无法直接监听 history 的改变而做出相应的改变。但我们可以：`拦截所有可能触发 history 改变的情况，变相监听 history 的改变`。对于SPA的 history 模式，只有四种方式能改变url：\n    1. 点击浏览器的前进或后退按钮；\n    2. 点击 a 标签；\n    3. 在 JS 代码中触发 history.pushState 函数；\n    4. 在 JS 代码中触发 history.replaceState 函数；\n\n\n### 关键问题：history模式为什么需要后端支持？\n需要注意的是，history 在修改 url 后，虽然页面并不会刷新，但如果我们**手动刷新**，或**通过 url 直接进入应用**的时候，服务端是无法识别这个 url 的。\n\n因为我们是**单页应用，只有一个 html 文件，服务端在处理其他路径的 url 的时候，就会出现404的情况**。\n\n所以，如果要应用 history 模式，**需要在服务端增加一个覆盖所有情况的候选资源**：`如果 URL 匹配不到任何静态资源，则应该返回单页应用的 html 文件`。\n\n### 基于history方式「实现简单前端路由」\n\n::: details 代码\n```js\nclass HistoryRouter{\n    constructor(){\n        //用于存储不同path值对应的回调函数\n        this.routers = {};\n        this.listenPopState();\n        this.listenLink();\n    }\n    //监听 popstate 用于处理前进后退时调用对应的回调函数\n    listenPopState(){\n        window.addEventListener('popstate',(e)=>{\n            let state = e.state || {},\n                path = state.path || '';\n            this.dealPathHandler(path)\n        },false)\n    }\n    //全局监听A链接，阻止A链接的默认事件，获取A链接的href属性，并调用 history.pushState 方法\n    listenLink(){\n        window.addEventListener('click',(e)=>{\n            let dom = e.target;\n            if(dom.tagName.toUpperCase() === 'A' && dom.getAttribute('href')){\n                e.preventDefault()\n                this.assign(dom.getAttribute('href'));\n            }\n        },false)\n    }\n    // load 方法，用于首次进入页面时 根据 location.pathname 调用对应的回调函数\n    load(){\n        let path = location.pathname;\n        this.dealPathHandler(path)\n    }\n    //用于注册每个视图\n    register(path,callback = function(){}){\n        this.routers[path] = callback;\n    }\n    //用于注册首页\n    registerIndex(callback = function(){}){\n        this.routers['/'] = callback;\n    }\n    //用于处理视图未找到的情况\n    registerNotFound(callback = function(){}){\n        this.routers['404'] = callback;\n    }\n    //用于处理异常情况\n    registerError(callback = function(){}){\n        this.routers['error'] = callback;\n    }\n    // 跳转到path\n    // 定义 assign 方法，用于通过 JS 触发 history.pushState 函数\n    assign(path){\n        history.pushState({path},null,path);\n        this.dealPathHandler(path)\n    }\n    // 替换为path\n    // 定义 replace 方法，用于通过 JS 触发 history.replaceState 函数\n    replace(path){\n        history.replaceState({path},null,path);\n        this.dealPathHandler(path)\n    }\n    //通用处理 path 调用回调函数\n    dealPathHandler(path){\n        let handler;\n        //没有对应path\n        if(!this.routers.hasOwnProperty(path)){\n            handler = this.routers['404'] || function(){};\n        }\n        //有对应path\n        else{\n            handler = this.routers[path];\n        }\n        try{\n            handler.call(this)\n        }catch(e){\n            console.error(e);\n            (this.routers['error'] || function(){}).call(this,e);\n        }\n    }\n}\n```\n演示一下：\n```html\n<body>\n    <div id=\"nav\">\n        <a href=\"/page1\">page1</a>\n        <a href=\"/page2\">page2</a>\n        <a href=\"/page3\">page3</a>\n        <a href=\"/page4\">page4</a>\n        <a href=\"/page5\">page5</a>\n        <button id=\"btn\">page2</button>\n    </div>\n    <div id=\"container\"></div>\n    <script>\n        let router = new HistoryRouter();\n        let container = document.getElementById('container');\n\n        //注册首页回调函数\n        router.registerIndex(() => container.innerHTML = '我是首页');\n\n        //注册其他视图回到函数\n        router.register('/page1', () => container.innerHTML = '我是page1');\n        router.register('/page2', () => container.innerHTML = '我是page2');\n        router.register('/page3', () => container.innerHTML = '我是page3');\n        router.register('/page4', () => {\n            throw new Error('抛出一个异常')\n        });\n\n        document.getElementById('btn').onclick = () => router.assign('/page2')\n\n\n        //注册未找到对应path值时的回调\n        router.registerNotFound(() => container.innerHTML = '页面未找到');\n        //注册出现异常时的回调\n        router.registerError((e) => container.innerHTML = '页面异常，错误消息：<br>' + e.message);\n        //加载页面\n        router.load();\n    </script>\n</body>\n```\n:::\n\n## hash、history 如何抉择（二者优缺点）\n\n1. hash 模式相比于 history 模式的优点：\n    - 无需服务端配合处理非单页的url地址；\n    - 兼容性更好，可以兼容到IE8；\n2. hash 模式相比于 history 模式的缺点：\n    - 更丑；\n    - 会导致锚点功能失效；\n    - 相同 hash 值不会触发动作将记录加入到历史栈中，而 pushState 则可以。\n\n综上所述，当我们不需要兼容老版本IE浏览器，并且可以控制服务端覆盖所有情况的候选资源时，我们可以愉快的使用 history 模式了。反之，很遗憾，只能使用丑陋的 hash 模式~\n\n\n\n## 参考链接\n\n本文参考链接[「前端进阶」彻底弄懂前端路由-云中桥](https://juejin.im/post/5d2d19ccf265da1b7f29b05f)\n"},{"title":"浏览器工作原理","url":"/Roundtables/Question-Bank/browser/browser-mechanism.html","content":"---\ntitle: 浏览器工作原理\ntags: [多进程, 多线程, 渲染进程, cookie, session, Storage]\ncategories: browser\n---\n\n# 浏览器工作原理\n\n## CPU、进程、线程 的关系\n- CPU（工厂）：计算机的核心是CPU，承担所有计算任务。\n- 进程（车间）：进程是CPU资源分配和独立运行的最小单位。进程之间相互独立，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n    - CPU使用时间片轮转进度算法来实现同时运行多进程。\n    - 不同进程之间也可以通信，不过代价较大。\n- 线程（工人）：线程是CPU调度的最小单位。一个进程中可以有多个线程，多个线程共享进程资源。\n    - 单线程与多线程，都是指在一个进程内的单和多。\n\n## 浏览器是多进程的\n\n- 计算机中的每个应用程序都是一个进程，应用程序可分为多个子模块，这些子模块就对应多个子进程。\n- 浏览器应用程序就是一个大进程，而每个tab页都是一个子进程，所以浏览器是多进程的。\n\n### 浏览器多进程分类\n- 主进程：浏览器的主进程（负责协调、主控），只有一个；\n- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建；\n- GPU进程：用于3D绘制，最多一个；\n- `渲染进程（浏览器内核）`：\n    - 每个tab页面是一个渲染进程，互不影响。\n    - 这个渲染进程也是多线程的，包含5大类线程。\n\n## 渲染进程是多线程的\n\n每一个tab页面可以看作是「渲染进程」进程，然后这个进程是多线程的，它有几大类线程：\n- `GUI渲染线程`\n    - 负责渲染页面，布局和绘制\n    - 页面需要重绘和回流时，该线程就会执行\n    - 与js引擎线程互斥，防止渲染结果不可预期\n- `JS引擎线程`\n    - 负责处理解析和执行javascript脚本程序\n    - 只有一个JS引擎线程（单线程）\n    - 与GUI渲染线程互斥，防止渲染结果不可预期\n- `事件触发线程`\n    - 用来控制事件循环（鼠标点击、setTimeout、ajax等）\n    - 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n- `定时器线程`\n    - setInterval与setTimeout所在的线程\n    - 定时任务并不是由JS引擎计时的，是由定时器线程来计时的\n    - 计时完毕后，通知事件触发线程\n- `异步http请求线程`\n    - 浏览器有一个单独的线程用于处理AJAX请求\n    - 当请求完成时，若有回调函数，通知事件触发线程\n\n### 两个问题\n\n#### 为什么 javascript 是单线程的\n- 创建 js 语言时，多线程架构的硬件支持并不好。\n- 因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。\n- 作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。\n- 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n\n#### 为什么 GUI渲染线程 与 JS引擎线程 互斥\n由于 js 可以操作 DOM，如果同时修改元素属性并同时渲染界面(即 JS线程和GUI线程同时运行)，会导致渲染线程前后获得的元素可能不一致。因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和JS引擎线程为互斥关系，当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。\n\n这部分建议与[任务队列 与 Event Loop](/Question-Bank/execution/event-loop.md)一同食用。\n\n## 浏览器存储\n\n### Cookie 和 Session\n- Cookie 和 Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是`为了解决HTTP无状态`的问题的。\n- Cookie是保存在客户端浏览器的一小段的文本信息，`每个domain最多只能有20条Cookie`，每个Cookie`长度不能超过4KB`，否则会被截掉。考虑到安全应当使用Session而不是cookie。\n- Session保存在服务器上。Session的运行依赖Session Id，而Session Id是存在Cookie中的，也就是说，如果浏览器禁用了Cookie，同时Session也会失效（但是可以通过其它方式实现，比如在url中传递session_id）。如果Cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道Cookie的意义，他只要原样转发Cookie就可以达到目的了。考虑到减轻服务器性能方面，应当使用cookie而不是session。\n- 注：\n    - cookie的键/值对中的值不允许出现分号、逗号和空白符，因此在设置cookie前要用encodeURIComponent()编码，读取时再用decodeURIComponent()解码；\n    - cookie默认的有效期是浏览器会话期间，作用域是整个浏览器而不仅仅局限于窗口或标签页；\n    - cookie默认是不能跨域访问的，但对于主域相同子域不同的两个页面，document.domain设置为相同的父域名，即可实现不同子域名之间的跨域通信。\n\n### Cookie 与 Web Storage\nH5的Web Storage提供了两个拥有一致API的对象：\n- window.localStorage：用来在本地存储永久数据的；\n- window.sessionStorage：用来存储会话数据的（也就是tab不关闭时的数据）；\n- 这两个对象存储的都是 name/value 。而且与Cookie不同，Web存储的大小比Cookie的大多了（`最少5MB`），而且通过这个策略存储的数据是`永远不会传输至server`的。\n- 纵使Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外Cookie不可以跨域调用。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\n- 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像Cookie需要前端开发者自己封装setCookie，getCookie。\n\n"},{"title":"简述输入URL到页面显示全过程","url":"/Roundtables/Question-Bank/browser/from-url-input.html","content":"# 简述输入URL到页面显示全过程\n\n1. 浏览器会开启一个内核线程来处理请求，首先进行`DNS解析`（浏览器是否已经有缓存，没有就去本机查host映射表，再没有就去请求本地DNS域名服务器启动DNS查询），获得请求对应的`IP地址`；\n\n2. 浏览器与IP地址指向的远程web服务器通过`tcp三次握手建立一个tcp/ip连接`；\n\n3. 浏览器会通过已经建立的连接，判断是否命中`强缓存`，如果需要`协商缓存`，则发送GET请求，远程服务器找到对应资源并用http响应，判断是协商缓存304还是重新返回数据200；\n\n4. 浏览器总之会获得所需资源；\n\n5. 浏览器解析html template为DOM tree，再根据CSS生产CSS rule tree，最后合成Render tree调用GUI完成图层合并和渲染。\n\n"},{"title":"from memory cache 与 from disk cache","url":"/Roundtables/Question-Bank/browser/memory-or-disk-cache.html","content":"### from memory cache 与 from disk cache\n\n> 谈谈network中的缓存细节：from memory cache 与 from disk cache\n\n----\n\n##### 一、浏览器Network的Size栏\n\n在浏览器开发者工具的Network的Size栏会出现的三种情况：\n- from memory cache\n- from disk cache\n- 资源本身大小（比如：13.6K）\n\n##### 二、3级缓存原理\n1、先查找内存，如果内存中存在，从内存中加载；\n2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；\n3、如果硬盘中未查找到，那就进行网络请求；\n4、加载到的资源缓存到硬盘和内存；\n\n##### 三、HTTP状态码及区别\n\n- 200 form memory cache\n    不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。\n\n- 200 from disk cache\n    不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。\n\n- 304 Not Modified\n    访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。\n\n状态 | 类型 | 说明\n-|-|-\n200 | form memory cache | 不请求网络资源，资源在内存当中，一般脚本、字体、图片会存在内存当中\n200 | form disk ceche | 不请求网络资源，在磁盘当中，一般非脚本会存在内存当中，如css等\n200 | 资源大小数值 | 从服务器下载最新资源\n304 | 报文大小 | 请求服务端发现资源没更新，使用本地资源\n    \n> 一般样式表会缓存在磁盘中，不会缓存到内存中，因为css样式加载一次即可渲染出页面。但是脚本可能会随时执行，如果把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的IO开销比较大，有可能会导致浏览器失去响应。\n\n##### 四、几种状态的执行顺序\n现加载一种资源（例如：图片）：\n访问-> 200 -> 退出浏览器\n再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)\n\n[原文链接](https://www.jianshu.com/p/8332da83955d)\n\n"},{"title":"提升页面性能的方法（5点）","url":"/Roundtables/Question-Bank/browser/performance.html","content":"---\ntitle: 提升页面性能的方法（5点）\ntags: [gzip, defer, async, 强缓存, 协商缓存, prefetch, preload, DNS预解析, CDN]\ncategories: performance\n---\n\n# 提升页面性能的方法（5点）\n\n## 资源压缩合并\n\n- 开启gzip压缩（一般是由nginx、apache、tomcat等web服务器开启，且需要浏览器支持，开启后的请求都是基于gzip压缩格式的，效率高达70%左右），详见（`前端必备nginx知识`）；\n- 减少HTTP请求；\n\n\n## 善用浏览器缓存（强缓存、协商缓存）\n\n### 缓存命中流程\n浏览器缓存包含两种类型，即`强缓存（200 from cache，也叫本地缓存）`和`协商缓存（304）`，两种命中缓存过程如下：\n- 浏览器在第一次请求发生后，再次请求时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；\n- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否命中协商缓存；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容\n\n### 缓存具体原理\n\n![](./images/cache-1-01.png)\n\n#### 一、强缓存：浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求\n- Expires Expires: Thu, 21 Jan 2017 23:00:00 GMT   （http1.0）。如果发送请求的时间在expires之前，那么本地缓存始终有效。\n- Cache-Control: max-age=600(注: 十分钟)/ no-cache/ no-store/ public/ private（http1.1）\n    - max-age用来控制强缓存，是一个相对值，相对于第一次请求的时间点的过期时间，如果当前请求时间在过期时间之前，就能命中强缓存;\n    - no-cache：不使用强缓存。需要使用协商缓存，先与服务器确认返回的响应是否被更改\n    - no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n    - public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。\n    - private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。\n\n**注意**：如果`cache-control（http1.1规范）`与`expires（http1.0规范）`同时存在的话，`cache-control的优先级高于expires`。expires使用的时间是服务器时间，由于服务端与客户端很可能不同步，因此http1.1后不推荐再使用expire，而cache-control的max-age是客户端时间，所以没有这个问题。\n\n#### 二、协商缓存：浏览器向服务端发起http请求，服务端告诉浏览器文件未改变，让浏览器使用本地缓存\n\n协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。\n\n这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。\n\n- `Last-Modified / If-Modified-Since（http1.0）`，二者的值都是GMT格式的时间字符串，具体过程：\n    - 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的字段，这个字段表示这个资源在服务器上的最后修改时间；\n    - 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的字段，这个字段的值就是上一次请求时返回的Last-Modified的值；\n    - 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变。\n    - 浏览器收到304的响应后，就会从缓存中加载资源；\n    - 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n- `Etag / If-None-Match（http1.1）`，这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化，这个值就会改变：\n    - 其判断过程与Last-Modified/If-Modified-Since类似，`与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化`。\n    - **注意**：If-Modified-Since 与 If-None-Match 是**浏览器发向服务器端**的字段。\n- *既生Last-Modified何生Etag?*，HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：\n    - 1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\n    - 2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是秒（s）级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n    - 3、某些服务器不能精确的得到文件的最后修改时间。\n    - 这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。\n    - 如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，没有优先级，但服务端会优先检查E-tag。\n    - 最后，如果服务器输出了 ETag，没有必要再输出 Last-Modified。有ETag就够了。\n\n### 强缓存如何重新加载浏览器缓存里面已经缓存过的资源？\n\n> 使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？\n\n通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了。\n\n![](./images/cache-1-02.png)\n \n- **注意**：对于协商缓存，使用Ctrl + F5 或 cmd + R 强制刷新可以使得缓存无效。\n- **注意**：对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）。\n\n\n\n## 非核心代码异步加载（script：async、defer）\n针对于 `<script>标签加载js代码资源` 而进行优化。\n\n### 异步加载代码的方式\n- 监听onload事件，动态脚本加载 document.createElement(‘script’)\n- setTimeout延迟加载js代码\n- async异步执行\n- defer延迟执行\n\n### async和defer的区别\n```html\n<script src=\"./async.js\" charset=\"utf-8\" async></script>\n<script src=\"./defer.js\" charset=\"utf-8\" defer></script>\n```\n\n1. 没有 async 或 defer：\n    ```html\n    <script src=\"script.js\"></script> \n    ```\n    浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签下面的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n3.\t只有 async 属性：\n    ```html\n    <script async src=\"script.js\"></script> \n    ```\n    - 有 async，该 js代码资源与html的解析是`并行加载`的，即异步download；\n    - async异步下载完毕后就会立即执行，`执行过程是阻塞html解析的`；\n    - `不确保执行顺序`，如果是多个，执行顺序和加载顺序无关。\n2.\t只有 defer 属性：\n    ```html\n    <script defer src=\"myscript.js\"></script> \n    ```\n    - 有 defer，该 js代码资源与html的解析是`并行加载`的，即异步download；\n    - defer虽然(可能)先加载，但却是在HTML解析完之后，在DOMContentLoaded事件流触发之前，才会`延迟执行`。\n    - `确保执行顺序`，如果是多个，按照加载的顺序依次执行。\n\n![](./images/defer&async.png)\n\n\n#### 扩展：onload和DOMContentLoaded比较：\n- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)；\n- onload事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。\n\n\n## 静态资源预加载（link：preload、prefetch）\n针对于 `<link>标签加载静态资源` 而进行优化。\n\n### preload\n给`<link>`标签，指定 rel=preload 能够让你在你的HTML页面中`<head>`元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在页面加载完成后立刻需要的。\n\n**场景**：试想我们网站使用了一种特殊字体，我们在css里面定义了字体的url。那么直到浏览器开始解析CSS了才会识别出来需要加载这个资源。如果我们提前让浏览器下载好这个资源呢？那么执行CSS的时候就可以直接用了。就像这样：\n```html\n<link rel=\"preload\" href=\"fonts/cicle_fina-webfont.woff\" as=\"font\" type=\"font/woff\" crossorigin=\"anonymous\">\n```\n- rel=\"preolad\"声明这是一个preload；\n- href指明资源的位置；\n- as指明资源类型（这是为了让浏览器精确设置优先级，设置正确的CSP、Accept头部）；\n- crossorigin 指明使用的跨域设置；\n- 添加preload声明之后，浏览器初次加载的资源变多了，但preload并不会阻塞onload事件的触发；\n- 响应式预加载：link标签还可以接收一个media属性，进行简单的媒体查询。例如这样：\n    ```html\n    <link rel=\"preload\" href=\"bg-image-narrow.png\" as=\"image\" media=\"(max-width: 600px)\">\n    <link rel=\"preload\" href=\"bg-image-wide.png\" as=\"image\" media=\"(min-width: 601px)\">\n    ````\n\n### prefetch\n给/`<link>`标签，指定 rel=prefetch 是对浏览器的暗示，暗示将来可能需要某些资源，但由浏览器代理决定是否加载以及什么时候加载这些资源。\n\n**场景**：用户正在登录页面，登录成功之后会跳转到首页。我是否可以在登录页面就去请求首页的资源呢？就像这样：\n```html\n<link rel=\"prefetch\" href=\"main.js\">\n```\n\n### preload和prefetch的区别\n> So，什么时候用preload什么时候用prefetch?\n\nprefetch跟preload不同在于：`用户从A页面进入B页面，preload的内容会失效，而prefetch的内容可以在B页面使用`。\n\n![](./images/preload&prefetch.png)\n\n## 使用CDN\n\n本部分可直接传送门到[nginx静态资源相关知识](/Question-Bank/work-practices/deploy.md#四、nginx静态资源相关知识)\n\n## DNS预解析\n在head中添加如下link标签并指定 `rel=\"dns-prefetch\"`便可以开启浏览器的dns预解析：\n```html\n<link rel=\"dns-prefetch\" href=\"//host_name_to_prefetch.com\">\n```\n- 在http协议下，高级浏览器中a标签的dns预解析是默认打开的；\n- 但在https协议下，很多浏览器中a标签的dns预解析是默认关闭的，通过如下meta标签可以`强制打开a标签的dns预解析`。\n    ```html\n    <meta http-equiv=\"x-dns-prefetch-control\" content=\"on\">\n    ```\n\n\n\n\n"},{"title":"从多线程到Event Loop全面梳理","url":"/Roundtables/Question-Bank/browser/process-eventloop.html","content":"### 从多线程到Event Loop全面梳理\n\n## 浏览器内核（渲染进程）\n渲染进程包含以下线程\n- GUI渲染线程\n>负责渲染页面，布局和绘制;<br />\n页面需要重绘和回流时，该线程就会执行;<br />\n与js引擎线程互斥，防止渲染结果不可预期;\n\n- JS引擎线程\n>负责处理解析和执行javascript脚本程序<br />\n只有一个JS引擎线程（单线程）<br />\n与GUI渲染线程互斥，防止渲染结果不可预期\n\n- 事件触发线程\n>用来控制事件循环（鼠标点击、setTimeout、ajax等）<br />\n当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n\n- 定时触发器线程\n>setInterval与setTimeout所在的线程<br />\n定时任务并不是由JS引擎计时的，是由定时触发线程来计时的<br />\n计时完毕后，通知事件触发线程\n\n- 异步http请求线程\n>浏览器有一个单独的线程用于处理AJAX请求<br />\n当请求完成时，若有回调函数，通知事件触发线程\n\n## 从 Event Loop 看 JS 的运行机制\n- JS 分为同步任务和异步任务\n- 同步任务都在JS引擎线程上执行，形成一个执行栈\n- 事件触发线程管理一个任务队列，异步任务触发条件达成，将回调事件放到任务队列中\n- 执行栈中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行\n\n![](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n## 宏任务、微任务\n> 什么是宏任务\n\n<strong>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）， 每一个宏任务会从头到尾执行完毕，不会执行其他。<br/>\n主代码块，setTimeout，setInterval等，都属于宏任务\n</strong>\n\n- 举个例子\n``` js\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n![](https://user-gold-cdn.xitu.io/2019/8/20/16caca3e44d7d357?imageslim)\n页面背景会在瞬间变成灰色，以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。\n\n- 第二个例子\n``` js\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n![](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ed44e6b16?imageslim)\n页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<strong>宏任务</strong>，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色。\n> 什么是微任务\n\n<strong>微任务可以理解成在当前宏任务执行后立即执行的任务。<br />当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。<br />Promise，process.nextTick等，属于微任务。</strong>\n- 第一个例子\n``` js\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n```\n![](https://user-gold-cdn.xitu.io/2019/8/20/16cad85d2378ccb5?imageslim)\n页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染\n- 第二个例子\n``` js\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print : 1 3 2\n```\n上面代码共包含两个 setTimeout ，也就是说除主代码块外，共有两个宏任务，\n其中第一个宏任务执行中，输出 1 ，并且创建了微任务队列，所以在下一个宏任务队列执行前，\n先执行微任务，在微任务执行中，输出 3 ，微任务执行后，执行下一次宏任务，执行中输出 2\n\n## 总结\n- 执行一个宏任务（栈中没有就从事件队列中获取）\n- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n参考链接：[从多线程到Event Loop全面梳理](https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-11)\n"},{"title":"浏览器渲染机制","url":"/Roundtables/Question-Bank/browser/render.html","content":"---\ntitle: 浏览器渲染机制\ntags: [DOCTYPE, 同源策略, CORS, JSONP]\ncategories: http\n---\n\n# 浏览器渲染机制\n\n## DOCTYPE\n\n### 定义及作用\n- `DTD`(document type definition，`文档类型定义`)是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会使用DTD来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式。\n- `DOCTYPE是用来声明DTD的`，即`声明文档类型`。\n- 主要的用途有：对文档的合法性进行验证；决定浏览器的呈现模式。\n\n### 常用的 DOCTYPE 声明\n\nHTML 5：\n```html\n<!DOCTYPE html>\n```\n\nHTML 4.01 Strict：\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\nHTML 4.01 Transitional：\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n### 严格模式有什么主要限制\n- 变量必须声明才能使用；\n- arguments参数不会自动反映函数参数的变化；\n- 不能使用arguments.caller或.callee；\n- 禁止this指向全局对象；\n- 不能使用前缀0表示八进制数；\n\n### 不同浏览器内核\n- IE：trident内核\n- Firefox：gecko内核\n- Safari：webkit内核\n- Chrome：Blink（基于webkit）内核\n\n## 浏览器渲染过程（6步）\nFirefox、Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。尽管Webkit与Gecko使用略微不同的术语，这个过程还是基本相同的：\n\n![渲染过程](./images/render.png)\n\n1. `DOM tree`：浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n2. `CSS规则树`：将CSS解析成 CSS Rule Tree 。\n3. `Render tree`：根据DOM树和CSSOM来构造 Render Tree。注意：Render Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。\n4. `Layout（Reflow）`：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。这一步操作称之为layout/reflow，顾名思义就是计算出每个节点在屏幕中的尺寸和位置。\n5. `Paint`：再下来这一步就是绘制，即遍历render树，绘制页面像素信息。\n6. `Composite 并显示`：最终，浏览器将各层的信息发送给GPU，进而将各层合成（composite）并显示在屏幕上。\n\n**注意**：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会`尽可能早的将内容呈现到屏幕上`，并不会等到所有的html都解析完成之后再去构建和布局render树。它是`解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容`。\n\n## 重排reflow 与 重绘repaint\n\n### 1、reflow（重排/回流）：\n\n#### 定义\n各个DOM元素都有自己的盒子模型，这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到应该的位置上。当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，那么这个回退的过程叫 reflow。\n- reflow 会从`<html>`这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。\n- reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。\n\n#### 触发reflow的情况\n1. 页面初始化渲染时；\n2. dom结构改变：操作dom节点结构时、移动dom位置时；\n3. `resize窗口`时有可能；\n4. 改变字体大小时；\n5. render tree变化：修改某些影响布局的css样式时（比如增减padding）；\n6. `最复杂的一种：获取某些属性时`。很多浏览器会对回流做优化，会等到数量足够时做一次`批处理`回流，但是，除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样`使得浏览器批处理优化无效`，包括：\n    - offset(Top/Left/Width/Height)\n    - scroll(Top/Left/Width/Height)\n    - cilent(Top/Left/Width/Height)\n    - width，height\n    - 调用了getComputedStyle()或者IE的currentStyle([js如何设置获取盒模型对应的宽和高](/Question-Bank/css/box-sizing&margin-collapse&BFC.md#js如何设置获取盒模型对应的宽和高))\n\n### 2、repaint（重绘）：\n\n#### 定义\n改变某个元素的背景色、文字颜色、边框颜色等等但不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。这个过程就叫做repaint。\n- 重排一定伴随着重绘，重绘却可以单独出现。\n- 注意：\n    - (1) `display:none 的节点不会被加入Render Tree`，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。\n    - (2) `display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化`。\n    - (3) 有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。\n\n#### 减少 reflow & repaint\n`重排和重绘是不可避免的`，我们只能说将它们对性能的影响减到最小，既然我们知道什么情况会触发它们，那就从这些方面入手：\n\n1. 让需要改变的元素进行`“离线处理”`，处理完后一起更新；\n2. 避免循环操作dom，创建一个`documentFragment`或div，在它上面应用所有DOM操作，最后再把它添加到window.document，触发一次重排和重绘\n（[使用documentfragment](/Lets-Read/one/read-3-1.md#使用-documentfragment)）；\n3. `使用display: none`，触发两次重排和重绘（由于display: none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排）；\n4. `将需要多次重排的元素的position属性设为absolute或fixed`（设为float没有完全脱离文档流，这个很微妙），这样元素就脱离了文档流，它的变化不会影响到其他元素的布局，不会导致一个完整重排；\n5. 减少逐项更改样式，最好`一次性更改style`，或者将样式定义为class并一次性更新；\n6. `避免多次读取offset等属性。无法避免则将它们缓存到变量`；\n7. `不要用table布局`，table中某个元素一旦触发重排就会导致table里所有的其它元素重排。在适合用table的场合，可以设置table-layout为auto或fixed，这样可以让table一行一行的渲染，这种做法也是为了限制重排的影响范围（一般我们可以通过ul li的布局替代之）。\n\n总之，在以后的开发中我们要尽量避免大量、频繁的操作DOM元素，因为DOM操作的代价实在是太昂贵了（这也是Virtual DOM应运而生的原因）。在书写HTML时要避免不必要的层级，书写CSS时避免嵌套过深、规则过于复杂，尤其是后代选择器，匹配选择器也会耗费更多的CPU。\n\n\n\n\n"},{"title":"关于axios的使用","url":"/Roundtables/Question-Bank/communication/axios.html","content":"# 关于axios的使用\n\n## http请求拦截器\n提供interceptors，在请求或响应被 then 或 catch 处理前拦截它们：\n```js\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  }, function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n});\n\n// 添加响应拦截器\naxios.interceptors.response.use(function (response) {\n    // 对响应数据做点什么\n    return response;\n  }, function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n});\n```\n\n"},{"title":"CORS 简介","url":"/Roundtables/Question-Bank/communication/cors.html","content":"---\ntitle: CORS 跨域资源共享\ndate: 2019-12-25 18:48:17\ntags: [HTTP, 浏览器, 跨域, 预检请求]\n---\n\n> 本文主要说明 跨域资源共享CORS 的原理及相关配置，主要涉及的知识点有： 简单请求、非简单请求、预检请求（preflight）。\n\n<!-- more -->\n\n## CORS 简介\n\nCORS（Cross-origin resource sharing）跨域资源共享：需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n\n整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n\n## 简单请求与非简单请求\n\n浏览器将CORS请求分成两类：**简单请求**、**非简单请求**。浏览器对这两种请求的处理是**不一样**的。\n\n同时满足以下两个条件就是简单请求：\n- 请求方法是以下三种方法之一：HEAD、GET、POST\n- HTTP的 header信息 不超出以下几种字段：\n    - Accept\n    - Accept-Language\n    - Content-Language\n    - Last-Event-ID\n    - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n凡是不同时满足上面两个条件，就属于非简单请求。\n\n## 简单请求的请求响应流程\n\n浏览器发现这次跨域请求是简单请求，就自动在header信息之中，添加一个Origin字段，并直接发出这个CORS请求。\n```\nGET /cors HTTP/1.1\nOrigin: http://www.esop.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\nOrigin字段用来说明，本次请求来自哪个源（协议、域名、端口)。服务器根据这个值，决定是否同意这次请求。\n\n- 如果Origin指定的源，`不在许可范围内`，服务器会返回一个正常的HTTP回应，但响应header中不包含`Access-Control-Allow-Origin`字段。浏览器发现，响应头信息没有Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XHR的onerror回调函数捕获。*注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。*\n- 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段：\n    ```\n    Access-Control-Allow-Origin: http://www.esop.com\n    Access-Control-Allow-Credentials: true\n    Access-Control-Expose-Headers: FooBar\n    Content-Type: text/html; charset=utf-8\n    ```\n    - **Access-Control-Allow-Origin**：必须。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求；\n    - **Access-Control-Allow-Credentials**：选填。布尔值，表示是否允许发送Cookie。**默认情况下，Cookie不包括在CORS请求之中。**设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可；\n        - CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定` Access-Control-Allow-Credentials: true`；\n        - 另一方面，开发者需要再XHR对象中开启 `withCredentials: true`；\n        - 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\n        - 如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。\n        - `注意一点！！！`如果要发送Cookie（Access-Control-Allow-Credentials: true），`Access-Control-Allow-Origin就不能设为星号(通配符)`，必须指定明确的、与请求网页一致的域名，否则请求失败。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie（为什么有这个规则：因为Cookie还是遵循同源策略的，每个Origin的Cookie是不能被其他Origin获取到的，也就是不允许Access-Control-Allow-Origin 的值为“*”）。\n        - 另外再啰嗦一句：如果在开发中后端同时设置了Access-Control-Allow-Credentials:true 与 Access-Control-Allow-Origin: *，但依然能正常请求和响应，不是因为上面的注意事项是错的，而是前端启用了 chrome 的 disable-web-security 的设置。而开发完成部署上线后，前后端是同源的不会跨域，所以这样设置也不会导致失败（因为没意义了）。\n    - Access-Control-Expose-Headers：选填。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。\n\n## 非简单请求的请求响应流程（需要预检请求preflight）\n\n- 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\n- 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n\n### 发送一个预检请求\n假设一个请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的header信息。\n```\nOPTIONS /cors HTTP/1.1\nOrigin: http://www.esop.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n- \"预检\"请求用的请求方法是**OPTIONS**，表示这个请求是用来询问的。\n- 请求header信息里面，关键字段是Origin，表示请求来自哪个源。\n- Access-Control-Request-Method：必填的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT\n- Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会**额外发送的header信息字段**，上例是X-Custom-Header。\n\n### 预检请求的响应\n\n- `允许响应`：服务器收到\"预检\"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n    ```\n    HTTP/1.1 200 OK\n    Date: Mon, 01 Dec 2008 01:15:39 GMT\n    Server: Apache/2.0.61 (Unix)\n    Access-Control-Allow-Origin: http://www.esop.com\n    Access-Control-Allow-Methods: GET, POST, PUT\n    Access-Control-Allow-Headers: X-Custom-Header\n    Access-Control-Max-Age: 1728000\n    Content-Type: text/html; charset=utf-8\n    Content-Encoding: gzip\n    Content-Length: 0\n    Keep-Alive: timeout=2, max=100\n    Connection: Keep-Alive\n    Content-Type: text/plain\n    ```\n    - 响应中，关键的是`Access-Control-Allow-Origin`字段，表示 http://www.esop.com 可以请求数据。该字段也可以设为星号，表示同意任意跨域请求。\n    - Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求；\n    - Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段；\n    - Access-Control-Allow-Credentials：该字段与简单请求时的含义相同；\n    - Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。\n\n- `不响应`：浏览器否定了\"预检\"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息（比如`Access-Control-Allow-Origin`）字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XHR对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\n    ```\n    XMLHttpRequest cannot load http://api.tiger.com.\n    Origin http://www.esop.com is not allowed by Access-Control-Allow-Origin.\n    ```\n\n### 通过预检请求后的请求\n\n一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n\n### 不想发预检请求可以么？\n\n- 想要避免发送OPTION请求，只能是发简单请求，但实际的业务中，比如我们的Content-Type绝大多数是`application/json`，此外我们做业务模块权限，请求头里用`Authorization`字段传递token身份令牌，而且我们的请求方法也不一定只是get、post、head，因此不满足简单请求的条件；\n- 但是，可以通过`设置预检请求结果缓存时间来减少发起OPTIONS请求的次数`:在响应header中设置 Access-Control-Max-Age:（number）。数值代表preflight request 的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息）可以被缓存多久，单位是秒。如 Access-Control-Max-Age: 600 代表将预检请求的结果缓存10分钟。\n\n\n## CORS与JSONP的比较\n\n- CORS与JSONP的使用目的相同，但是比JSONP更强大。\n- JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。\n"},{"title":"跨域通信与同源策略","url":"/Roundtables/Question-Bank/communication/cross-domain.html","content":"---\ntitle: 跨域通信与同源策略\ntags: [跨域, 同源策略, CORS, JSONP]\ncategories: http\n---\n\n# 跨域通信与同源策略\n\n## 什么是同源策略及限制？\n- 只要`协议、域名、端口`有任何一个不同，都被当作是不同的源，即属于不同的域。不是同一个源的文档，不能获取和操作另一个源的文档。\n- 注意：http与https也视作不同协议，www.A.com与news.A.com属于子域不同，域名与其对应IP也算不同域名，这都是跨域。\n- 限制主要表现在：Cookie、localStorage和IndexDB无法读取；Dom无法获得；Ajax请求不能发送。\n\n## 前后端通信方式\n- Ajax：同源下的通信方式\n- WebSocket：不受同源策略的限制\n- CORS：支持同源也支持不同源通信，也是当前最常用的跨域通信策略\n- fetch：Ajax的替代方案，语法简洁语义化，基于标准Promise实现，链式调用，支持async/await\n    ```js\n    fetch('/some/url', {\n        method: 'GET'\n    }).then(function(res) {\n        // do something\n    }).catch(function(err) {\n        // error 处理，等价于then的第二个参数，但更直观好用\n    })\n    ```\n\n### 如何创建Ajax？\n\n考察点：XHR对象的工作流程、兼容性处理、事件的触发条件、事件的触发顺序\n\n ![创建Ajax](./images/cross-domain-1-01.png)\n\n## 常用跨域策略（8种）\n现在常用主流方式是 CORS 及 使用代理，当然 JSONP 也是经典的方法。\n### 1、CORS（跨域资源共享）\n- 支持跨域ajax的通信标准。原理是`浏览器在识别ajax发送了跨域请求的时候，会将其拦截并在http头中加一个origin字段，允许跨域通信`。\n- 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n\n详情跳转传送门：[CORS 跨域资源共享](/Roundtable/Question-Bank/communication/cors)\n\n### 2、服务端代理\n- 通过nginx反向代理或者nodejs代理请求，原理就是`服务端是不受浏览器的同源策略限制的`，因此可通过服务端先请求好资源，再从服务端拿来用。\n- 在开发环境下可以使用webpack 的 `http-proxy-middleware`中间件，在`devServer配置proxy: config.dev.proxyTable`实现代理跨域。\n\n### 3、JSONP\n- JSONP：`利用script标签的异步加载来实现`。所有网站的js的地址和网站域名是不一致的，跨源了但是不影响js的加载。\n- JSONP的要点是：**允许客户端传一个callback参数给服务器，然后服务器返回数据时会用这个`callback参数作为函数名，包裹住JSON数据`，返回客户端，客户端执行返回函数**。\n- 凡是拥有“src”属性的标签都拥有跨域的能力，如`<script>,<img>,<iframe>`等。\n- Jsonp只能发`get请求`。\n\n![jsonp示例](./images/jsonp.png)\n\n### 4、Hash\n利用的原理是“`hash的变动不会触发页面刷新`”。\n具体做法：\n1. 主页面A中嵌入iframeB，两个来自不同域；\n2. 在主页面A中，将想要传递给B的字段，作为hash，将它与B的url连接起来，然后将B的src设置为连接后的url；\n3. 在iframeB中，就可以通过获取自己url的hash值，从而得到主页面传递的值。在iframeB中，通过监听window.onhashchange事件来获取A页面传来的字段。\n\n![hash跨域示例](./images/hash.png)\n\n### 5、postMessage\nHTML5规范中的新方法`window.postMessage()`可以用于安全跨域通信。\n\n![postMessage跨域示例](./images/postMessage.png)\n\n### 6、WebSocket\n- HTTP 协议有一个缺陷，即通信只能由客户端发起。这对于服务器有连续状态变化的场景，就只能使用低效的“轮询”。\n- WebSocket是一种服务器推送技术，支持双向通信，可向客户端推送信息，实时性更强。`没有同源限制，即允许跨域`。协议标识符是`ws`（如果加密，则为wss）。\n\n![WebSocket跨域示例](./images/webSocket.png)\n\n### 7、document.domain\n- 适用于：主域相同子域不同的页面。\n- 方法：将这两个页面的document.domain设置为相同的父域名，即可实现不同子域名之间的跨域通信\n\n### 8、window.name\nwindow对象有个name属性，该属性有个特征：即在一个窗口的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的。\n\n"},{"title":"文件下载实现","url":"/Roundtables/Question-Bank/communication/download.html","content":"# 文件下载实现\n\n## 案例：分块下载\n分块下载的原理简述：\n\n#### 1. 是否支持范围请求：\n- 如果 `响应头response headers`中，有 `Accept-Ranges:bytes` 标识，则代表当前资源是支持范围请求的。\n\n#### 2. 获取与发送范围：\n- 在HTTP/1.1中定义了一个`Range的请求头`来指定请求的实体的范围，即`Range: bytes=0-1xxx`，它的范围取值是在 `0 - 总Length` 之间。\n- 通过指定 Range: bytes=0-1 发送请求后，返回的响应为 HTTP/1.1 206 Partial Content ，有一个`Content-Range响应头`，`Content-range: bytes 0-1/1484477`，即 `Range请求头类型 范围值 / 总Length`。\n\n#### 3. 检查资源是否变化：\n- 在终端发起续传请求时，很有可能，URL对应的文件内容在服务端已经发生变化。因此需要检查文件是否变化；\n- 检查资源变化最简单的方式是通过判断响应头的`ETag`的值，`ETag用于标识当前文件的唯一性`。在Response Headers中返回ETag。\n\n#### 4. 下载实现：\n- 就是先判断服务器是否支持分块，分块Size设置是否小于文件大小，如果小于则根据分块Size计算请求头中的Range的范围值去请求切割的块。当所有分块都请求成功之后将其合并保存成文件。\n\n#### 5. 断点续下：\n- 如果要实现断点续下，就需要记录当前请求点，如果下载中断，需要丢弃当前未完成的分片，然后从记录点开始请求数据，并且将数据追加到文件中就行了。\n\n::: details 简单实现\n```js\nconst fetch = require(\"node-fetch\");\nconst fs = require('fs'); // 引入fs模块\n\nfunction readJSON(p) { return JSON.parse(fs.readFileSync(p)); };//读取json\nfunction writeJSON(p, d) { fs.writeFileSync(p, JSON.stringify(d)); };//保存json\n//读取响应头\nfunction getResHeaders(u) {\n    return new Promise(function (resolve, reject) {\n        fetch(u, {\n            method: \"GET\", //请求方式\n            // mode: 'cors',\n            headers: { //请求头\n                \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\",\n                \"Cache-Control\": \"no-cache\",\n                Connection: \"keep-alive\",\n                Pragma: \"no-cache\",\n                Range: \"bytes=0-1\"\n            }\n        }).then(r => {\n            let h = {};\n            r.headers.forEach(function (v, i, a) {\n                h[i.toLowerCase()] = v;\n            })\n            return resolve(h);\n        }).catch(reject);\n    });\n}\n//下载块\nfunction downloadBlock(u, o) {\n    let option = {\n        'Content-Type': 'application/octet-stream',\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n        Pragma: \"no-cache\"\n    };\n    if (typeof o == \"string\") {\n        option[\"Range\"] = \"bytes=\" + o;\n    } else if (typeof o == \"object\") {\n        option = Object.assign(option, o);\n    }\n    return fetch(u, {\n        method: 'GET',\n        headers: option,\n    }).then(res => res.buffer());\n}\n//切割大小\nfunction cutSize(contentLength, blockSize) {\n    //向后取整\n    let blockLen = Math.ceil(contentLength / blockSize);\n    let blist = [];\n    for (let i = 0, start, end; i < blockLen; i++) {\n        start = i * blockSize;\n        end = (i + 1) * blockSize - 1;\n        end = end > contentLength ? contentLength : end;\n        blist.push({ start: start, end: end });\n    }\n    return blist;\n}\n(async function () {\n    // let url = \"http://cdn.npm.taobao.org/dist/node/v10.14.2/node-v10.14.2-x64.msi\";\n    let url = \"https://dldir1.qq.com/qqfile/qq/QQ9.0.8/24209/QQ9.0.8.24209.exe\";\n    // let url = \"https://www.python.org/ftp/python/3.7.2/python-3.7.2-amd64.exe\";\n    let fileName = url.split(\"/\").reverse()[0].split(\"?\")[0];\n    //获取请求头信息\n    let h = await getResHeaders(url);\n    let contentRange = h[\"content-range\"];\n    //分块大小\n    let blockSize = 1024 * 1024 * 4;//b\n    let etag = h.etag || null;\n    //记录文件当前下载状态的文件\n    let logFileName = fileName + \".info\";//这个可自定义\n    let logContent;\n    //如果日志文件存在\n    if (fs.existsSync(logFileName)) {\n        //读取数据\n        logContent = readJSON(logFileName);\n        //比较etag来判断文件是否发生变动\n        if (etag != logContent.etag) {\n            logContent = null;\n        }\n    }\n    //判断是否支持分段下载\n    if (contentRange) {\n        if (!logContent) {\n            //获取文件大小\n            let contentLength = Number(contentRange.split(\"/\").reverse()[0]);\n            //判断是否后需要分块下载\n            if (contentLength >= blockSize) {\n                let contentType = h[\"content-type\"];\n                //计算分块\n                let blist = cutSize(contentLength, blockSize);\n                //日志记录内容根据需要添加\n                logContent = {\n                    url: url,\n                    etag: etag,\n                    fileName: fileName,\n                    contentLength: contentLength,\n                    contentType: contentType,\n                    blocks: blist,\n                    pointer: 0\n                };\n                //创建记录文件\n                writeJSON(logFileName, logContent);\n            } else {\n                contentRange = false;\n            }\n        }\n        if (logContent) {\n            //遍历并下载\n            for (let i = logContent.pointer; i < logContent.blocks.length; i++) {\n                let block = logContent.blocks[i];\n                let b = await downloadBlock(url, {\n                    etag: logContent.etag,\n                    'Content-Type': logContent.contentType,\n                    \"Range\": \"bytes=\" + block.start + \"-\" + block.end\n                });\n                //追加内容\n                fs.appendFileSync(logContent.fileName, b);\n                //记录日志\n                logContent.pointer++;\n                console.log(logContent.fileName, logContent.pointer / logContent.blocks.length * 100 + \"%\");\n                writeJSON(logFileName, logContent);\n            }\n            //如果需要删除日志文件的话\n            // fs.unlink(logFileName, function(err){});\n        }\n    } else {\n        contentRange = false;\n    }\n    //使用 contentRange = false 来标识 直接下载\n    if (contentRange == false) {\n        //直接下载\n        let fileBuffer = await downloadBlock(url, {});\n        //保存文件\n        fs.writeFile(fileName, fileBuffer, function (err) {\n            if (err) throw err;\n            console.log('Saved.');\n        });\n    }\n})();\n```\n:::\n\n## 参考链接\n\n- [NodeJS实现简单的HTTP文件断点续传下载功能](https://www.jianshu.com/p/934d3e8d371e?tdsourcetag=s_pctim_aiomsg)\n"},{"title":"HTTP 协议","url":"/Roundtables/Question-Bank/communication/http.html","content":"---\ntitle: HTTP 协议\ntags: [http报文, http方法, 状态码, 长连接, 管线化]\ncategories: http\n---\n\n# HTTP 协议\n\n特点：简单快速，灵活，无连接，**无状态**\n\n## HTTP 协议报文组成\n\n### 1. 请求报文组成\n- 请求行：http方法、页面url地址、协议/版本；\n- 请求头：key-value；\n- 空行：分隔符CRLF；\n- 请求体；\n\n![请求报文](./images/http-1-01.png)\n\n### 2. 响应报文组成\n- 响应行：协议/版本、状态码；\n- 响应头：key-value；\n- 空行：分隔符CRLF；\n- 响应体；\n\n![响应报文](./images/http-1-02.png)\n\n## HTTP 方法\n- GET：获取资源\n- POST：传输资源\n- PUT：更新资源\n- DELETE：删除资源\n- HEAD：获取报文首部（报文头）\n\n### GET与POST的区别（关注前5点）\n1. **GET在浏览器回退时是不会重复提交的，而POST会再次提交请求**；\n2. **GET请求会被浏览器主动缓存，而POST不会，除非手动设置**；\n3. **GET请求参数会被完整保留在浏览器历史记录中，而POST中的参数不会被保留**；\n3. **GET参数通过URL传递，POST放在Request body中**；\n5. **GET请求在URL中传参是有长度限制的(一般为2kb)，而POST没有限制**；\n6. **get会产生一个tcp数据包，而post产生两个，先发headers响应100 continue，再发data响应200**；\n6. GET产生的URL地址可以被收藏，而POST不可以；\n7. GET参数直接放在URL中，不能传递敏感信息；\n8. GET只能进行url编码，而POST支持多种编码方式。\n\n## HTTP 状态码及常用端口\n\n### 状态码\n- 1xx：指示信息\n- 2xx：成功\n\t- 200 OK：客户端请求成功\n    - 204 No content：表示请求成功，但响应报文不含实体的主体部分\n\t- 206 Partial Content：客户端发送带Range头的Get请求，服务器会按照Range截取对应数据返回，通常用于video标签或audio标签请求一个大的视音频文件时，返回range部分\n- 3xx：重定向\n\t- 301 Moved Permanently：永久重定向，所请求的页面已经永久转移至新url\n\t- 302 Found：临时性重定向，所请求的页面已经临时转移至新的url\n\t- 304 Not Modified：客户端存在缓存并且此缓存未被更改可继续使用\n- 4xx：客户端错误\n\t- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解\n    - 401 unauthorized：表示发送的请求缺少身份认证信息\n\t- 403 Forbidden：对被请求页面的访问被禁止\n\t- 404 Not Found：请求资源不存在\n- 5xx：服务器错误\n\t- 500 Internal Server Error：服务器错误\n\t- 503 Server Unavailable：服务器不可用，临时过载宕机，导致请求未完成\n\n#### ajax302重定向跨域问题\n\n**ajax发起的接口请求** 和 **浏览器直接发起的页面访问请求** 有一定区别：\n- 浏览器可以通过返回的http状态进行相应的操作，如访问一个页面，此页面3xx重定向时，浏览器可以**获取到重定向后的url，然后把地址栏的url替换，完成重定向动作**。\n- ajax的目的就是无刷新的，所以对于服务器端进行了3xx重定向时，ajax会获取到重定向状态值3xx和重定向url，然后再此发送一个新请求去请求重定向url。\n\n因此，如果这个后端接口重定向给的url是另外一个域名的地址，那么此时就会出现**跨域问题**。\n\n**解决方式是**：ajax在第一次得到相应处理后，`主动通过js`做一次`location.href跳转`。**目的是让浏览器去请求重定向的接口而不是ajax**。\n\n\n### 常用端口\n- http 80\n- https 443\n- DNS 53\n- FTP 20 21\n- SMTP 25\n- POP3 110\n\n## 长连接（持久连接或连接重用）\n\n### 概念\n- `http1.1`版本才支持的传输模式；\n- HTTP协议采用“请求-应答”模式，分为`普通模式`和`keep-alive`模式这两种模式;\n- 当使用`普通模式`时，每个请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开（`HTTP协议为无连接的协议`）。\n- 当使用`Keep-alive`模式时（又称`持久连接或连接重用`），keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，keep-alive功能`避免了重新建立连接`。\n- 注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效。\n\n### 从两个层面定义\n#### 先看tcp/ip层面的定义：\n- 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）\n- 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接\n#### 在http层面的定义：\n- `http1.0中，默认使用的是短连接`，也就是说，浏览器每进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接\n- `http1.1起，默认使用长连接`，使用长连接会有这一行`Connection: keep-alive`，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接\n\n### 什么是管线化\n- 持久连接时，某个连接上消息的传递类似于：`请求1-》响应1-》请求2-》响应2-》请求3-》响应3`；\n- 持久连接时，管线化是指某个连接上的消息传递类似于：`请求1-》请求2-》请求3-》响应1-》响应2-》响应3`(即打包一次发送多个请求，一次返回多个响应)；\n- 管线化是在持久连接的情况下完成的，仅http1.1支持；\n- 只有GET和HEAD请求可以进行管线化；\n- 管线化不会影响响应到来的顺序；\n- 很多代理程序对管线化支持并不好，因此Chrome和FF默认并未开启管线化支持。初次创建连接时不应启动管线机制，因为对方服务器可能不支持。\n\n## HTTP 2.0\nhttp2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）。\n### http2.0与http1.1的显著不同点：\n- http1.1是**一对一**的：`一个tcp/ip请求只能请求一个资源`，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来;\n- http2.0是**一对多**的：`一个tcp/ip请求可以请求多个资源`，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。\n\n所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）。\n\n### http2.0特性\n- `多路复用`（即一个tcp/ip连接可以请求多个资源）；\n- `首部压缩`（http头部压缩，减少体积）；\n- `服务器端推送server push`（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）；\n- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）；\n- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求）。\n\n## https\n- https其实就是身披SSL协议这层外壳的http。https并非是应用层的一种新协议，只是https通信接口部分用 SSL(Secure Socket Layer) 和TLS(Transport Layer Security)协议代替而已。因此https又叫 `HTTP over SSL`, HTTP over TLS。\n- https是http的安全版本，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了;\n- 简单来看，https与http的**区别**就是：`在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析`。\n- 一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）。\n\n\n\n\n"},{"title":"网络基础","url":"/Roundtables/Question-Bank/communication/internet-base.html","content":"---\ntitle: 网络基础\ntags: [五层协议模型, DNS, tcp, 三次握手]\ncategories: http\n---\n\n# 网络基础\n\n## 五层因特网协议栈\n从客户端发出http请求到服务器接收，中间会经过一系列的流程：`从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。服务端的接收就是反过来的步骤。`\n\n1. 应用层(dns,http)：DNS解析成IP并发送http请求；\n2. 传输层(tcp,udp)：建立tcp连接（三次握手）；\n3. 网络层(IP,ARP)：IP寻址；\n4. 数据链路层(PPP)：封装成帧；\n5. 物理层(利用物理介质传输比特流)：物理传输（然后传输的时候通过双绞线，电磁波等各种介质）。\n\n其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。\nOSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层\n\n## DNS查询流程\n如果浏览器url输入的是域名，需要进行dns解析成IP，大致流程：\n1. 浏览器有缓存，直接使用浏览器缓存；否则使用本机缓存；再没有的话就是用host；\n2. 如果本机没有，就向本地dns域名服务器查询（*递归*），本地dns域名服务器再（*迭代*）从根域到二级到主机域名一层层查询到对应的IP，最后（*递归*）返回给本机。\n\n注意：dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化。\n\n## tcp/ip\n\n### tcp、udp的工作原理\n- http的本质就是tcp/ip请求，tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。\n- tcp与udp都属于传输层协议，用来确认传输是否可靠：\n    - tcp是传输控制协议，是`可靠传输`，保证传输的数据一定不丢；\n    - udp是用户数据报协议，更快但`不可靠`，可能会丢失数据。\n\n### 三次握手与四次挥手\n（抽象`三次握手`，序列号是SYN，确认码是ACK）：\n- 1）客户端：hello，你是server么？（客户端发送序列号X；服务端接收序列号X）；\n- 2）服务端：hello，我是server，你是client么（服务端发送序列号Y，确认码X+1；客户端接收序列号Y，确认码X+1）；\n- 3）客户端：yes，我是client（客户端发送确认码Y+1，服务端接收确认码Y+1）。\n建立连接成功后，接下来就正式传输数据.\n然后，待到断开连接时，需要进行`四次挥手`（因为是全双工的，所以需要四次挥手，抽象四次挥手）：\n- 1）主动方：我已经关闭了向你那边的主动通道了，只能被动接收了；\n- 2）被动方：收到通道关闭的信息；\n- 3）被动方：那我也告诉你，我这边向你的主动通道也关闭了；\n- 4）主动方：最后收到数据，之后双方无法通信；\n\n### tcp/ip的并发限制\n浏览器对`同一域名下并发的tcp连接是有限制的（2-10个不等）`，而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求，所以针对这个瓶颈，又出现了很多的资源优化方案，但随着http2.0发展，这些都没什么用了。\n\n### get和post的区别\nget和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别:\n- `get会产生一个tcp数据包，post两个`：\n    - get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）；\n    - post请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）。\n- 这里的区别是specification（规范）层面，而不是implementation（对规范的实现）。\n\n\n\n"},{"title":"关于Json","url":"/Roundtables/Question-Bank/communication/json.html","content":"# 关于Json\n\n- Json是Js的对象表示法，是存储和交换文本信息的语法，类似XML，采用键值对的方式来阻止。\n- 与XML相比，Json的长度更短小，读写速度更快，而且Json可使用Js的内置方法直接解析，非常方便。\n\t\n## Json常用方法\n\n- `eval()`: 可计算某个字符串，并执行其中的javascript表达式或要执行的语句。\n    - 此方法很危险，不推荐使用，不仅解析字符串，还会执行Js里的方法。\n- `JSON.parse()`: json字符串 => json对象。\n- `JSON.stringify()`: json对象 => json字符串。\n"},{"title":"文件上传实现","url":"/Roundtables/Question-Bank/communication/upload.html","content":"# 文件上传实现\n\n## 案例一：传统form标签借助iframe实现无刷新上传\n#### 1. 刷新问题：\n  - 由于form表单的提交会导致页面重定向，当我们点击选择文件，然后点击提交按钮后，当前页面重定向到了action所指定的页面；\n  - 再加上目前很多处理文件上传的action都是基于微服务架构的RESTful接口，你会发现上传完成后，当前页面被刷新变成了action接口返回的数据！\n#### 2. iframe实现无刷新：\n  - *实际上，你可以将form的target指定为_blank，这样上传完成后的返回数据会打开新的页面显示，但这不符合现代浏览器交互*。\n  - 在form旁边写一个iframe标签，指定id和name，然后**将form的`target`属性设置为这个`iframe的id`**，这样做的`目的`是**将form表单的提交目标指向这个iframe**，\n  - 当提交表单之后，接口返回值便会显示在iframe里面，我们把iframe隐藏起来，iframe加载成功后会派发onload事件；\n  - 因此，只需要为onload事件添加回调函数，读取iframe里面的内容，便可以得到当前上传后的接口返回值。\n```html\n<!-- 案例一：form标签实现无刷新上传文件 -->\n<form\n    method=\"POST\"\n    enctype=\"multipart/form-data\"\n    action=\"https://your.domain.com/upload\"\n    target=\"upload-iframe\">\n    <!-- input 必须设置 name 属性，否则数据无法发送；h5的multiple属性实现多文件选择 -->\n    <input type=\"file\" name=\"f1\"  value=\"请选择文件\" multiple />\n    <button type=\"submit\">提交</button>\n</form>\n<iframe style=\"display:none\" onload=\"onLoad()\" id=\"upload-iframe\" name=\"upload\">\n</iframe>\n<script>\nfunction onLoad() {\n    var iframe = document.getElementById(\"upload-iframe\");\n\n    // 解析content，分析上传接口返回值\n    var content = iframe.contentWindow.document.body.innerText;\n\n    // 接口数据转换为 JSON 对象\n    var obj = JSON.parse(content);\n    if(obj && obj.fileUrl.length){\n        alert('上传成功');\n    }\n}\n</script>\n```\n\n## 案例二：不写标签实现文件上传\n模拟input标签和点击事件：\n```js\nvar input = document.createElement(\"input\"); // 模拟一个input标签\ninput.type = \"file\";\ndocument.querySelector('body').appendChild(input); // 为了兼容性考虑\ninput.click(); // 代码执行到这里，本地文件选择框便会打开\nsetTimeout(() => {\n  input.remove()\n}, 1000)\n// 浏览器出于安全的考虑，选择本地文件必须由用户行为触发\n// 因此我们定义的函数也必须在用户事件（如click回调函数）里去调用\n// input标签在每次选择了文件之后都会触发onchange事件\ninput.onchange = function () {\n    var file = input.files[0]; // 如果只实现单文件上传，获取files下标为0的对象，file包括name、size、type等属性\n    var fd = new FormData(); // FormData完全就是form标签的对象形式，方便用编程的方式去操作form了\n\n    // // 多文件上传需要遍历添加到 fromdata 对象\n    // for (var i = 0; i < fileList.length; i++) {\n    //     fd.append('f1', fileList[i]); //支持多文件上传\n    // }\n\n    fd.append(\"file\", file); // file参数是后台读取的请求key值\n    fd.append(\"fileName\", file.name);\n    fd.append(\"other\", \"666666\"); // 实际业务的其他请求参数\n\n    var xhr = new XMLHttpRequest();\n    var action = \"http://localhost:8080/upload.do\"; //上传服务的接口地址\n    xhr.open(\"POST\", action); // 必须是 post method\n    xhr.send(fd); // 发送表单数据\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            var resultObj = JSON.parse(xhr.responseText);\n            //处理返回的数据......\n        }\n    }\n}\n```\n\n## 案例三：大文件分片上传\n`Blob`表示原始数据，也就是二进制数据，提供了对数据截取的方法`slice`，而`File`继承了`Blob`的功能：\n- 核心是利用 `Blob.prototype.slice`方法（和数组的`slice`方法相似），调用的`slice`方法可以返回原文件的某个切片；\n- 借助 `http 的可并发性`，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间；\n- 由于是并发，还需要给每个切片记录顺序；\n- 服务端需要考虑`何时合并切片`（即切片什么时候传输完成），可以通过`前端增加一个请求，主动通知服务端进行切片的合并`；\n- 服务端还需要考虑`如何合并切片`，可以使用 nodejs 的 `读写流`（readStream/writeStream），将所有切片的流传输到最终文件的流里，删除切片文件。\n\n::: details 参考代码\n```html\n<div>\n  <input type=\"file\" @change=\"handleFileChange\" />\n  <button @click=\"handleUpload\">上传</button>\n</div>\n<script>\n  const SIZE = 10 * 1024 * 1024; // 10Mb 切片大小\n\n  function handleFileChange(e) {\n    const [file] = e.target.files;\n    if (!file) return;\n\n    this.container.file = file;\n  };\n\n  function async handleUpload() {\n    if (!this.container.file) return;\n\n    const fileChunkList = this.createFileChunk(this.container.file);\n\n    // 在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标\n    // 这样后端可以知道当前切片是第几个切片，用于之后的合并切片\n    this.data = fileChunkList.map(({ file }，index) => ({\n      chunk: file,\n      hash: this.container.file.name + \"-\" + index // 文件名 + 数组下标\n    }));\n\n    await this.uploadChunks();\n  }\n\n  // 生成文件切片\n  function createFileChunk(file, size = SIZE) {\n  const fileChunkList = [];\n    let cur = 0;\n    while (cur < file.size) {\n      fileChunkList.push({ file: file.slice(cur, cur + size) });\n      cur += size;\n    }\n\n    return fileChunkList;\n  };\n\n  // 并发上传切片\n  function async uploadChunks() {\n    const requestList = this.data\n      .map(({ chunk，hash }) => {\n        const formData = new FormData();\n        formData.append(\"chunk\", chunk);\n        formData.append(\"hash\", hash);\n        formData.append(\"filename\", this.container.file.name);\n        return { formData };\n      })\n      .map(async ({ formData }) =>\n        this.request({\n          url: \"http://localhost:3000\",\n          data: formData\n        })\n      );\n\n    await Promise.all(requestList); // 并发切片\n\n    await this.mergeRequest(); // 合并切片\n  };\n\n  // 主动通知合并\n  function async mergeRequest() {\n    await this.request({\n      url: \"http://localhost:3000/merge\",\n      headers: {\n        \"content-type\": \"application/json\"\n      },\n      data: JSON.stringify({\n        filename: this.container.file.name\n      })\n    });\n  };\n</script>\n```\n:::\n\n\n\n## 案例四：大文件断点续传\n基于大文件上传的案例：\n#### 1. 生成hash：\n  - 之前使用`文件名 + 切片下标`作为`切片hash`，这样做文件名一旦修改就失去了效果，而事实上`只要文件内容不变，hash 就不应该变化`，所以正确的做法是根据文件内容生成 hash（使用库 spark-md5）；\n  - 考虑到如果上传一个超大文件，`读取文件内容计算 hash 是非常耗费时间`的，并且会引起 `UI 的阻塞`，导致页面假死状态，所以可以使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互；\n  - （此部分代码参考 略）在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程；\n#### 2. 文件秒传：\n  - 所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功；\n  - 文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可。\n#### 3. 断点（暂停）：\n  - 原理是使用 `XMLHttpRequest` 的 `abort`方法，可以取消一个 xhr 请求的发送。需要将上传每个切片的 xhr 对象保存起来，上传成功时，将对应的 xhr 从 requestList 中删除。即`requestList 中只保存正在上传切片的 xhr`。\n  - 之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片。\n#### 4. 续传（恢复上传）：\n  - 服务端需要存储所有上传的切片，每次前端上传前可以调用一个接口`const { shouldUpload, uploadedList } = await this.verifyUpload()`，告知当前文件是否已经上传完成，已完成则是秒传，未完成时还需要获取当前已上传的切片列表，前端再跳过这些已经上传切片，并继续传剩下的切片，这样就实现了“续传”的效果；\n\n## 案例五：文件上传进度\n- `XMLHttpRequest` 原生支持上传进度的监听，只需要监听 `xhr.upload.onprogress` 即可。\n\n## 案例六：拖拽上传\n\nhtml5的出现，让拖拽上传交互成为可能：\n- 定义一个允许拖放文件的区域`div.drop-box`；\n- 取消`drop`事件的默认行为`e.preventDefault()`，不然浏览器会直接打开文件；\n- 为拖拽区域绑定事件，鼠标在拖拽区域上 `dragover`，鼠标离开拖拽区域`dragleave`，在拖拽区域上释放文件`drop`；\n- `drop`事件内获得文件信息`e.dataTransfer.files`。\n\n::: details 拖拽上传\n```html\n<div class=\"drop-box\" id=\"drop-box\">\n  拖动文件到这里,开始上传\n</div>\n<button type=\"button\" id=\"btn-submit\">上 传</button>\n<script>\n    var box = document.getElementById('drop-box');\n    \n    // 禁用浏览器的拖放默认行为，否则会直接打开文件\n    document.addEventListener('drop', function(e) {\n        e.preventDefault();\n    });\n   \n    // 设置拖拽事件\n    function openDropEvent() {\n        box.addEventListener(\"dragover\", function(e) {\n            box.classList.add('over');\n            e.preventDefault();\n        });\n         box.addEventListener(\"dragleave\", function (e) {\n            box.classList.remove('over');\n            e.preventDefault();\n        });\n\n        box.addEventListener(\"drop\", function (e) {\n            e.preventDefault(); // 取消浏览器默认拖拽效果\n\n            var fileList = e.dataTransfer.files; //获取拖拽中的文件对象\n            var len=fileList.length;//用来获取文件的长度（其实是获得文件数量）\n            \n            //检测是否是拖拽文件到页面的操作\n            if (!len) {\n                box.classList.remove('over');\n                return;\n            }\n\n            box.classList.add('over');\n\n            window.willUploadFileList=fileList;\n\n        }, false);\n    }\n\n    openDropEvent();\n\n    function submitUpload() {\n        var fileList = window.willUploadFileList||[];\n        if(!fileList.length){\n            alert('请选择文件');\n            return;\n        }\n\n        var fd = new FormData();   //构造FormData对象\n\n        for(var i = 0; i < fileList.length; i++) {\n            fd.append('f1', fileList[i]); // 支持多文件上传\n        }\n\n        var xhr = new XMLHttpRequest(); // 创建对象\n        xhr.open('POST', 'http://localhost:8100/', true);\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState == 4) {\n                var obj = JSON.parse(xhr.responseText);   // 返回值\n                if(obj.fileUrl.length){\n                    alert('上传成功');\n                }\n            }\n        }\n        xhr.send(fd); // 发送\n    }\n\n    //绑定提交事件\n    document.getElementById('btn-submit').addEventListener('click', submitUpload);\n</script>\n```\n:::\n\n## 案例七：剪贴板上传\n写文编辑器是支持粘贴上传图片的：\n- 页面内增加一个可编辑的编辑区域`div.editor-box`，开启`contenteditable`；\n- 为`div.editor-box`绑定`paste事件`；\n- 处理`paste事件`，从`event.clipboardData || window.clipboardData`获得数据；\n- 将数据转换为文件`items[i].getAsFile()`；\n- 实现在编辑区域的光标处插入内容`insertNodeToEditor方法`。\n::: details 剪贴板上传\n```html\n<div class=\"editor-box\" id=\"editor-box\" contenteditable=\"true\" >\n    可以直接粘贴图片到这里直接上传\n</div>\n<script>\n  // 光标处插入 dom 节点\n  function  insertNodeToEditor(editor,ele) {\n      //插入dom 节点\n      var range;//记录光标位置对象\n      var node = window.getSelection().anchorNode;\n      // 这里判断是做是否有光标判断，因为弹出框默认是没有的\n      if (node != null) {\n          range = window.getSelection().getRangeAt(0);// 获取光标起始位置\n          range.insertNode(ele);// 在光标位置插入该对象\n      } else {\n          editor.append(ele);\n      }\n  }\n  \n  var box = document.getElementById('editor-box');\n  //绑定paste事件\n  box.addEventListener('paste', function (event) {\n      var data = (event.clipboardData || window.clipboardData);\n\n      var items = data.items;\n      var fileList = [];//存储文件数据\n      if (items && items.length) {\n          // 检索剪切板items\n          for (var i = 0; i < items.length; i++) {\n              fileList.push(items[i].getAsFile());\n          }\n      }\n\n      window.willUploadFileList = fileList;\n      event.preventDefault();//阻止默认行为\n\n      submitUpload();\n  }); \n\n  function submitUpload() {\n      var fileList = window.willUploadFileList||[];\n      var fd = new FormData();\n      for(var i = 0; i < fileList.length; i++) {\n          fd.append('f1', fileList[i]);\n      }\n      var xhr = new XMLHttpRequest();\n      xhr.open('POST', 'http://localhost:8100/', true);\n      xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n              var obj = JSON.parse(xhr.responseText);   //返回值\n\n              if(obj.fileUrl.length){\n                  var img = document.createElement('img');\n                  img.src= obj.fileUrl[0];\n                  img.style.width='100px';\n                  insertNodeToEditor(box,img);\n              }\n          }\n      }\n\n      xhr.send(fd);//发送\n  }\n</script>\n```\n:::\n\n\n## 参考链接\n\n- [纯js实现上传文件小工具](https://juejin.im/post/5e6b282e5188254955487e46)\n- [字节跳动面试官：请你实现一个大文件上传和断点续传](https://juejin.im/post/5dff8a26e51d4558105420ed#heading-13)\n- [写给新手前端的各种文件上传攻略，从小图片到大文件断点续传](https://juejin.im/post/5da14778f265da5bb628e590#heading-17)\n\n"},{"title":"盒模型 & 外边距重叠 & BFC","url":"/Roundtables/Question-Bank/css/box-sizing&margin-collapse&BFC.html","content":"---\ntitle: 盒模型 & 外边距重叠 & BFC\ntags: [css, 布局, 盒模型, 外边距重叠, BFC]\ncategories: css\n---\n\n# 盒模型 & 外边距重叠 & BFC\n\n## 盒模型基本概念：标准模型 + IE模型\n\n1. box-sizing: `content-box`（`默认值`，`标准盒模型`）：\n ![content-box](./images/content-box.png)\n    - 浏览器默认值为【标准盒模型】。 width 与 height 只包括内容的宽和高， 不包括边框，内边距，外边距。\n    - 这意味着：内边距, 边框和外边距都在这个盒子的外部。\n\n2. box-sizing: `border-box` （`IE盒模型`，也叫Quirks`怪异模型`）：\n  ![border-box](./images/border-box.png)\n    - width 与 height 包括内边距与边框，不包括外边距。这是IE Quirks mode使用的盒模型 。\n    - 这意味着，当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。这个时候内边距和边框将会包括在盒子中。\n\n## JS如何设置获取盒模型对应的宽和高\n1. dom.style.width/height 只能取到内联样式的宽高，取不到样式表和外联样式写的宽高；\n2. dom.currentStyle.width/height 拿到最终渲染后的dom的实际宽高，但只有IE支持；\n3. `window.getComputedStyle(dom)`.width/height拿到最终渲染后的dom的实际宽高，兼容多浏览器；\n4. `dom.getBoundingClientRect()`.widh/height/top/left/bottom/right 取到dom渲染后相对于viewport边界的宽高和绝对位置。\n\n![](./images/layout-3-col-01.png)\n\n## 外边距重叠 margin-collapse\n\n### 根据盒模型解释边距重叠margin-collapse\n\n外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。\n- 水平margin永远不会重合；\n- 设置了overflow属性(visible除外)的元素和它的子元素之间的margin不会重叠；\n- 设置了绝对定位（position:absolute）的盒模型，垂直margin不会被重叠，和子元素之间也不重叠；\n- 设置了display:inline-block的元素，垂直margin不会重叠，和子元素之间也不重叠；\n- 根元素(如html)与body的margin不会重叠。\n\n### 边距重叠三种情况\n\n1. `父子元素边距重叠`，父div的margin-top:30px，子div的margin-top: 10px，取最大值原则，二者重叠后的margin-top: 30px\n2. `兄弟元素边距重叠`，上div的margin-bottom: 30px，下div的margin-top: 10px，取最大值原则，上下div的margin间隙为30px\n3. `空元素的边距重叠`，一个空div既有margin-top: 10px，也有margin-bottom: 30px，取最大值原则，那么空div的margin上下重合为margin 30px\n\n### 边距重叠的计算规则\n1. 两个相邻的外边距`都是正数时`，折叠结果是它们两者之间`较大的值`。\n2. 两个相邻的外边距`都是负数时`，折叠结果是两者`绝对值的较大值`。\n3. 两个外边距`一正一负时`，折叠结果是两者的`相加的和`。\n\n## BFC(块级格式化上下文)——边距重叠解决方案\n\n### FC（格式上下文）\n- `FC即格式上下文，它定义框内部元素的渲染规则`。不同类型的框参与的FC类型不同，块级框对应BFC，行内框对应IFC。相比BFC规则来说，IFC可能更加抽象，但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则。\n- **注意**：并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则。\n\n### BFC是什么：\n- 简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。\n- 具有BFC的元素`可以看作是隔离了的独立容器`，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性，例如可以包含浮动元素，比如`清除浮动的方法（如 overflow方法）就是触发了浮动元素的父元素为 BFC ，使得它可以包含浮动元素，从而防止出现高度塌陷的问题`。\n\n### BFC原理：\n1. 元素的垂直方向的边距margin会发生重叠；\n2. `BFC区域不会与浮动元素的box重叠`；\n3. `BFC是一个隔离的独立容器，内部与外部的元素是不会相互影响的`；\n4. 内部box在垂直方向，一个接一个的放置；\n5. `计算BFC高度的时候，浮动元素也会参与计算（不会浮动坍塌）`；\n\n### 如何创建BFC：\n1. 浮动元素，float 除 none 以外的值；\n2. 绝对定位元素，position 为 absolute 或 fixed；\n3. display 为以下其中之一的值 （inline-blocks，flex，inline-flex，table，table-cells，table-captions...)；\n4. overflow 除了 visible 以外的值（hidden，auto，scroll）；\n\n### BFC的使用场景(3种)：\n\n#### 场景1：两个或多个块级盒子的垂直相邻边界会重合\n\n**场景**：上下兄弟元素在垂直方向发生外边距重叠，如图1：\n![图1](./images/BFC-1-01.png)\n\n**解决**：两个或多个块级盒子的垂直相邻边界会重合，则上述2的上下边距都会与1和3发生重叠，想要避免边距重叠问题，就要引入BFC：当给2增加一个父元素，设置overflow:hidden从而创建BFC以后就可以解决这个问题，`原理是：BFC的内部元素不会影响以外的元素`。\n![图2](./images/BFC-1-02.png)\n![图3](./images/BFC-1-03.png)\n\n#### 场景2：文档流会在超出左侧浮动区块的区域向左填充\n\n**场景**：向左填充浮动区块以外的区域(灰色部分)，如图1：\n![图1](./images/BFC-2-01.png)\n\n**解决**：`原理是：BFC区域不会与浮动元素的box重叠`。\n![图2](./images/BFC-2-02.png)\n![图3](./images/BFC-2-03.png)\n\n#### 场景3：浮动元素不会参与父元素高度计算（高度塌陷）\n\n**场景**：当子元素是浮动元素时，其不参与父元素的高度计算，如图1：\n![图1](./images/BFC-3-01.png)\n\n**解决**：`原理是：BFC元素的子元素即使是浮动的其也会参与高度计算（清除浮动的原理）`。\n![图2](./images/BFC-3-02.png)\n![图3](./images/BFC-3-03.png)\n\n"},{"title":"CSS 基础属性","url":"/Roundtables/Question-Bank/css/css-base.html","content":"---\ntitle: CSS 基础属性\ntags: [css, 布局, 文档流, 浮动]\ncategories: css\n---\n\n# CSS 基础属性\n\n## CSS 选择器\n- id选择器（ # myid）\n- 类选择器（.myclassname）\n- 标签选择器（div, h1, p）\n- 相邻选择器（h1 + p）\n- 子选择器（ul > li）\n- 后代选择器（li a）\n- 通配符选择器（ * ）\n- 属性选择器（a[rel = \"external\"]）\n- 伪类选择器（a: hover, li:nth-child）\n\n### 优先级如何计算？\n- 内联样式 > ID选择器 > 伪类 > 属性选择器 > 类选择器 > 标签选择器 > 通用选择器（*）\n- 优先级就近原则，同权重情况下样式定义最近者为准，载入样式以最后载入的定位为准。\n- !important 规则例外, 该样式声明会覆盖CSS中任何其他的声明,最高权重。\n\n## CSS3新增伪类\n- p:first-of-type：选择属于其父元素的首个p元素的每个p元素。\n- p:last-of-type：选择属于其父元素的最后p元素的每个p元素。\n- p:only-of-type：选择属于其父元素唯一的p元素的每个p元素。\n- p:only-child：选择属于其父元素的唯一子元素的每个p元素。\n- p:nth-child(2)：选择属于其父元素的第二个子元素的每个p元素。\n    - p:nth-child(even)：偶数行\n    - p:nth-child(odd)：奇数行\n    - p:nth-child(2n)：偶数行\n    - p:nth-child(2n+1)：奇数行\n    - p:nth-child(-n+3)：n为1、2、3的元素（-n+3>0的元素）\n- :enabled :disabled：控制表单控件的禁用状态。\n- :checked：单选框或复选框被选中。\n\n### 伪类与伪元素的区别\n伪类和伪元素的根本区别在于：`它们是否创造了新的元素`。\n- 从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。\n- 使用语法二者也有不同：在CSS1和CSS2中，伪元素和伪类一样，都是用:开头。\n- 但在CSS3中，伪元素以::开头，用以和伪类进行区分。IE8不支持::。因此如果要兼容IE8，只能用:。\n\n## CSS3有哪些常用新特性\n- 圆角（border-radius）\n- 阴影（box-shadow）\n- 文字阴影（text-shadow）\n- 线性渐变（gradient）\n- 变形（transform）\n- 多背景rgba\n- 新增选择器\n- 媒体查询\n\n## 关于CSS3中的transform\n- transform的含义是：改变，使…变形；转换；\n- transform的属性包括：rotate() / skew() / scale() / translate(,) ，分别还有x、y之分，比如：rotatex() 和 rotatey()。\n\n#### transform:rotate()： 含义：旋转；其中“deg”是“度”的意思，如“10deg”表示“10度”下同。\n```css\n.demo_transform {\n\t-webkit-transform: rotate(10deg);\n    -moz-transform: rotate(10deg);\n}\n```\n#### transform:skew()： 含义：倾斜；\n```css\n.demo_transform {\n\t-webkit-transform: skew(20deg);\n    -moz-transform: skew(20deg);\n}\n```\n#### transform:scale()： 含义：比例；“1.5”表示以1.5的比例放大，如果要放大2倍，须写成“2.0”，缩小则为负“-”。\n```css\n.demo_transform {\n\t-webkit-transform: scale(1.5);\n    -moz-transform: scale(1.5);\n}\n```\n#### transform:translate()： 含义：变动，位移；如下表示向右位移120像素，如果向上位移，把后面的“0”改个值就行，向左向下位移则为负“-”。\n```css\n.demo_transform {\n\t-webkit-transform: translate(120px,0);\n    -moz-transform: translate(120px,0);\n}\n```\n\n\n\n"},{"title":"样式布局中的奇技淫巧","url":"/Roundtables/Question-Bank/css/css-tricks.html","content":"# 样式布局中的奇技淫巧\n\n\n## 1像素border实现\n不能直接用border-bottom来实现，因为在移动端有dpr的概念：比如ip6上dpr是2，物理像素是设备像素的两倍，那么在PC上是1像素的线条，在手机上就是2像素。\n\n可以使用**伪类缩放**：原理就是利用伪类相对于元素是绝对定位，然后根据`媒体查询dpr来缩放`其大小\n```css\n@media (webkit-min-device-pixel-ratio:2){}\n```\n\n## @2x和@3x图片\n同样通过媒体查询设备dpr来对应引入2x和3x图片。\n\n## SVG图片（图标字体文件）\n在移动端开发中，通常会把一些色彩单一的图片做成svg图片。我们不会直接使用这些svg图片，我们会用一些工具将其转化为图表字体文件，就能在css中引用这些图表字体文件即可。\n\n传送门：[工具IconMoon](https://icomoon.io/)\n\n## 去除连续span分块间空白字符\n- 方法1：通过在**父层dom上设置font-size为0**，在子dom上单独设置其font-size的方法；\n- 方法2：直接在html中将**连续的span紧挨着**就可以了；\n- 方法3：使用**letter-spacing**属性设置间距；\n\n## 文本太长显示…\n\n```scss\n.target {\n    while-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n```\n\n\n## 在图片高度未知时适应屏幕宽度形成一个宽高相等的容器\n- w3c规定，当给padding-top或者padding-bottom设置100%时，会依据其width设置百分比。\n- 从而保证了垂直方向padding值与width是一样的。从而形成一个宽高相等的容器。\n- *同理，padding-left与padding-right100%也会按照height设置百分比*\n```scss\n.wrapper {\n    height: 0;\n    width: 200px;\n    padding-bottom: 100%;\n}\n```\n\n## 经典布局：Css Sticky footers\n`Sticky footers`：\n    - 如果页面内容不够长的时候，页脚块粘贴在视窗底部；\n    - 如果内容足够长时，页脚块会被内容向下推送。\n\n相对复杂但兼容性最好的方案：\n    - 最外层wrapper设最小100%高度撑开屏幕；\n    - 内部的main主要内容设padding-bottom为页脚块留出位置；\n    - 与wrapper平级的close页脚块设相对定位向上偏移即可；\n```scss\n.wrapper {\n    min-height: 100%;\n    .main {\n        margin-top: 64px;\n        padding-bottom: 64px;\n    }\n}\n.close {\n    position: relative;\n    margin-top: -64px;\n    width: 32px;\n    height: 32px;\n    clear: both;\n}\n```\n\n## 两栏布局flex布局实现（固定宽度和自适应宽度）\n- wrapper 外层宽度100%，设置over-flow隐藏；\n- left 固定宽度为80px，为了兼容性需要width：80px；\n- right 的flex为1自适应；\n```scss\n.wrapper {\n    display: flex;\n    width: 100%;\n    overflow: hidden;\n    .left {\n        flex: 0 0 80px;\n        width: 80px;\n    }\n    .right {\n        flex: 1; // 等价于 1 1 0\n    }\n}\n```\n\n## 左右列表联动思路\n\n左右列表联动实现：\n1. 先实现右侧滑动左侧列表标题对应高亮\n    - 关键是计算右侧列表每一块区间的高度，存入数组listHeight中;\n    - 拿到better-scroll实时滚动所派发的y值，将其保存到scrollY中；\n    - 在计算属性中通过scrollY所在listHeight区间判断，映射到左侧列表；\n    - 最后通过绑定class完成左侧列表current样式的变更（currentIndex===index）。\n2. 实现左侧标题点击，右侧列表滚动到对应位置：scrollToElement。\n\n## 横向滚动实现\n需要满足picList的宽度超出picWrapper的固定宽度。在初始化better-scroll的时候，需要传两个参数：\n- 一个是**允许水平滚动**scrollX: true；\n- 第二个eventPassthrough: 'vertical' **是允许在这个区块内，忽略整个页面上垂直方向的滚动，而只应用自己的横向滚动**。\n\n## 超链接访问过后，hover样式就不出现是为什么？如何解决？\n被点击访问过的超链接不再具有hover和active样式，解决方式是改变css属性的排列顺序，按照link，visited，hover，active的顺序设置（L-V-H-A）(驴哈)。\n\n## rgba()与opacity()的透明效果有什么不同？\n- opacity()作用于元素，以及元素内的所有内容；\n- rgba()只作用于元素的颜色或者背景色，且子元素不会继承其透明效果。\n\n## display: none与visibility:hidden有什么不同？\ndisplay：none是dom元素没渲染，而visibility：hidden只是视觉上隐藏，有dom元素。\n\n具体可参考浏览器渲染部分的解释。\n\n## src和href的区别是什么？\n简言之，`src`用于`替换当前元素`；`href`用于在当前文档和引用资源之间`建立联系`。\n\n- `src`指向的内容**会嵌入到文档中当前标签所在的位置**。常用的有：img、script、iframe。当浏览器解析到该元素时，会暂停浏览器的渲染，直到该资源加载完毕。这也是将js脚本放在底部而不是头部的原因。\n- `href`是用来建立当前元素和文档之间的链接。常用的有：link、a。浏览器会识别该文档为css文档，**并行下载该文档，并且不会停止对当前文档的处理**。这也是建议使用`link`，而不采用`@import`加载css的原因。\n\n#### CSS中link与@import的区别是？\n- `link`是html标签，无兼容问题，而`@import`是CSS提供的，只有IE5以上才能识别；\n- `link`随着页面同时加载，`@import`引用的css会等到页面被加载完之后再加载；\n- `link`方式的样式权重高于`@import`样式的权重\n\n\n\n## onmouse事件\n\n#### onmouseover与onmousemove的区别？\n- `onmouseover`只在刚进入区域时触发；\n- `onmousemove`除了刚进入区域触发外，在区域内移动鼠标也会触发。\n- 从时间上来看`onmouseover`的事件触发是早于`onmousemove`的。\n#### mouseout与mouseleave有什么区别？\n二者都是鼠标离开指定元素时触发的鼠标事件，不同点是：\n- `mouseout`在离开指定元素区域及其子元素区域均触发；\n- `mouseleave`只在鼠标离开指定元素区域时触发。\n\n#### 原生JS实现节点拖拽\n给需要拖拽的节点绑定`mousedown`、`mousemove`、`mouseup`事件：\n1. `mousedown`事件触发后，开始拖拽；\n2. `mousemove`时，需要通过event.clientX及clienY获取拖拽的位置，并实时更新位置；\n3. `mouseup`时，拖拽结束。\n4. 需要注意浏览器边界的计算问题。\n\n\n\n## FOUC（文档样式短暂失效）\nFOUC（文档样式短暂失效），指的是当样式表晚于html结构加载，在页面dom加载完成到css样式导入完成之间会有一小段时间页面上的内容是没有样式的。当加载css文件时，页面停止之前的渲染，在此css文件下载和解析后，将重新渲染页面，也就出现了短暂的花屏闪烁现象。\n\n这通常是因为如下三点原因造成的：\n1. 使用@import方法导入样式表；\n2. 将样式表放在页面底部；\n3. 有多个样式表，放在html结构的不同位置；\n\n解决方法是：在head标签之间`通过link`或者script元素引入样式文件。\n\n\n## CSS3动画特性\nCSS3动画相关的几个属性是：`transition`过渡, `transform`变换, `animation`动画。\n- `transition`关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。\n- `animation`作用于元素本身而不是样式属性，可以使用**关键帧**的概念，应该说可以实现更自由的动画效果。\n至于实现动画效果用哪一种，要看应用场景，但很多情况下`transition`更简单实用些。\n\n#### transition\n`transition：all 0 ease 0（默认值）`：\n- transition-property：属性名，取值有all/none/property(比如width、height、opacity...)\n- transition-duration：持续时间，以秒或者毫秒计\n- transition-timing-function：linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n); 过渡效果。\n- transition-delay：延迟开始时间，以秒或者毫秒计\n\n#### transform\ntransform：scale | skew | rotate | translate | 某个方向属性及3d属性如translateX(x)、translate3d(x,y,z)。\n\n此外还有matrix矩阵 和perspective(n) 3d透视视图这种不常用的取值。\n\n#### animation\n`animation : none 0 ease 0 1 normal  (默认值)`：\n- animation-name：规定需要绑定到选择器的 keyframe 名称，如下示例自定义的myAni\n- animation-duration：持续时间，以秒或毫秒计\n- animation-timing-function：linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n); 速度效果曲线。\n- animation-delay：延迟开始时间，以秒或者毫秒计\n- animation-iteration-count：动画播放次数\n- animation-direction：normal|alternate；是否应该轮流反向播放动画\n```css\n@keyframe myAni {\n    0% {\n        background: red;\n    }\n    50% {\n        background: blue;\n    }\n    100% {\n        background: black;\n    }\n}\n@keyframe myAni2 {\n    from { background: red; }\n    to { background: black; }\n}\n```\n\n"},{"title":"移动端响应式适配方案","url":"/Roundtables/Question-Bank/css/flexible.html","content":"## 移动端响应式适配方案\n\n## 手淘团队 lib-flexible方案\n在Flexible中，只对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1。\n\nFlexible本质上就是通过JS来动态改写meta标签来实现响应式适配的。把视觉稿中的px转换成rem（rem是相对于根元素html的font-size来计算盒模型大小的）。\n\n一些基本概念：\n- meta标签：`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">`\n- CSS单位rem：`rem`就是相对于`根元素<html>`的font-size来做计算。而flexible方案中使用rem单位，是能轻易的根据`<html>`的font-size计算出元素的盒模型大小。\n- 物理像素(physical pixel)：又被称为设备像素，是显示设备中一个最微小的物理部件。\n- 设备独立像素(density-independent pixel)：也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)。\n- 设备像素比(device pixel ratio)：简称为`dpr`，其定义了物理像素和设备独立像素的对应关系。公式：`设备像素比 ＝ 物理像素 / 设备独立像素`\n- 在js中，可以通过`window.devicePixelRatio`获取到当前设备的dpr。\n- 在CSS中，可以通过`-webkit-device-pixel-ratio`，`-webkit-min-device-pixel-ratio`和 `-webkit-max-device-pixel-ratio`进行**媒体查询**，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。\n\n注意：*与rem相对的，`em`是相对于`父级元素font-size`来计算大小的，em会继承父级元素的字体大小，浏览器默认字体高为16px，默认1em=16px*。\n"},{"title":"多种方式实现三栏布局","url":"/Roundtables/Question-Bank/css/layout-3-col.html","content":"---\ntitle: 多种方式实现三栏布局\ntags: [css, 布局, 浮动, 绝对定位, flex, table]\ncategories: css\n---\n\n# 多种方式实现三栏布局\n\n> 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应.\n\n## 高度已知时，有哪些方式\n\n#### （1）浮动：\n- 缺点：脱离文档流，需要清除浮动，清除不好会导致很多问题；\n- 优点：兼容性比较好\n#### （2）绝对定位\n- 缺点：脱离文档流，导致子元素也必须脱离文档流，因此可使用性较差\n- 优点：快捷，不容易出问题\n#### （3）flex弹性\n- 优点：CSS3中出现，解决了上述两种布局的问题，是较为完美的布局，移动端基本都是flex布局\n#### （4）table表格\n- 优点：兼容性非常好\n- 缺点：比较麻烦；当其中一块的高度超出时，其他同级块的高度也要跟随其变高(非预期的)\n#### （5）grid网格\n- 优点：比较新出的布局方式，CSS支持的栅格布局，无需再用框架模拟栅格；完成复杂布局的代码量非常少\n\n![](./images/layout-3-col-01.png)\n\n## 高度未知时，哪些方式还适用\n\n只有`flex弹性布局`与`table表格布局`是在高度超出后其他块的高度也跟随变高，所以适用；\n\n其他布局方案在不改变的情况下是不再适用的：\n- 浮动布局是因为中间自适应块的内容在向左浮动的时候，遇到左浮动的块儿被挡住了，当高度超出左边浮动块儿时，就浮动到左边。想要阻止浮动到左边，需要创建BFC；\n- 绝对定位无内容撑开时，按照设定min-height；有内容撑开超出最小高度时被内容撑开；\n- grid网格布局可设定grid-template-rows: auto使网格高度都跟随内容撑高\n\n![](./images/layout-3-col-02.png)\n\n## 代码附录：\n\n![](./images/layout-3-col-03.png)\n\n"},{"title":"元素居中方法总结","url":"/Roundtables/Question-Bank/css/layout-block-center.html","content":"---\ntitle: 元素居中方法总结\ntags: [css, 布局, 元素居中]\ncategories: css\n---\n\n# 元素居中方法总结\n\n## johninch\n\n### 垂直居中\n1. 对单行文本居中：\n```css\n{\n    height: 100px;\n    line-height: 100px; /* 值等于元素高度的值 */\n}\n```\n2. 模拟div表格居中：\n```css\ndiv{\n    display: table-cell; /* 让元素以表格的单元格形式渲染 */\n    vertical-align: middle; /* 使元素垂直对齐 */\n}\n```\n3. 绝对定位元素居中:\n```css\n.element {\n    width: 400px;\n    height: 400px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-top: -200px;    /* 高度的一半 */\n    margin-left: -200px;    /* 宽度的一半 */\n}\n/* 上面的方法需要已知元素的宽高，更好的方法是利用CSS3中的transform，对任意宽高都适用： */\n.element {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);    /* 50%为自身尺寸的一半 */\n}\n```\n4. flex居中：\n```css\n.div {\n    display: flex;\n    align-items: center;\n}\n```\n\n### 水平居中\n1. 居中一个行内元素\n> 只需要把行内元素包裹在一个属性display为block的父层元素中，并且把父层元素添加如下属性便可以实现居中的效果：\n```css\ntext-align: center;\n```\n\n2. 居中一个块级元素\n> 给div设置一个宽度，然后添加margin:0 auto属性才会有效：\n```css\ndiv {\n    width:200px;\n    margin:0 auto;\n}\n```\n\n3. 绝对定位元素居中:\n```css\n.element {\n    width: 400px;\n    height: 400px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    margin-top: -200px;    /* 高度的一半 */\n    margin-left: -200px;    /* 宽度的一半 */\n}\n/* 上面的方法需要已知元素的宽高，更好的方法是利用CSS3中的transform，对任意宽高都适用： */\n.element {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);    /* 50%为自身尺寸的一半 */\n}\n```\n\n4、居中浮动元素\n> 实现居中的关键就在于 margin设置与 position:relative。\n```css\n.div {\n    float：left\n    width: 400px ;\n    height: 400px;\n    position: relative;\n    left: 50%;\n    top: 50%;\n    margin: -200px 0 0 -200px;\n}\n```\n5、flex水平居中\n```css\n.div {\n    display: flex;\n    justify-content: center;\n}\n```\n\n## mtd\n````html\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n````\n1.flex实现\n````css\n.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n````\n2.table-cell布局实现\n````css\n.parent {\n    display: table-cell;\n    vertical-align: middle;\n}\n.child {\n    margin: 0 auto;\n}\n````\n3.定位+transform\n````css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n}\n````\n\n## johninch\n"},{"title":"CSS 中的定位机制","url":"/Roundtables/Question-Bank/css/layout-method.html","content":"---\ntitle: CSS 中的定位机制\ntags: [css, 布局, float, 浮动, position, 绝对定位, display, 块级元素, 行内元素]\ncategories: css\n---\n\n# CSS 中的定位机制\n\nCSS 有三种基本的定位机制：`普通流`、`浮动`和`绝对定位`。\n\n**注意**：float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。但重点是：**float仍会占据位置（`也就是说没有完全脱离文档流`），而absolute/fixed会覆盖文档流中的其他元素**。\n\n## 浮动\n浮动布局是CSS中规定的第二种定位机制。通过设置float属性，能够实现横向多列布局。\n\n### 浮动原理\n浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档流（但是又没有完全脱离文档流），当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，会出现包含框不会自动伸高来闭合浮动元素（“**高度塌陷**”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。\n\n### 清除浮动\n\n#### 第一类方法（推荐）\n通过在浮动元素的末尾添加一个空元素，设置 clear：both属性。after伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素；\n1. `after伪选择符`，就可以在父容器的尾部自动创建一个子元素。\n    ```css\n    div:after {\n    content: \".\";\n    height: 0;\n    visibility: hidden;\n    display: block;\n    clear: both;\n    }\n    ```\n2. `工程上常用的.clearfix`一般是这样描述的：\n    ```css\n    .cf:before,\n    .cf:after {\n        content: \"\";\n        display: block;\n        clear: both;\n    }\n    /* For IE 6/7 (trigger hasLayout) */\n    .cf { zoom: 1; }\n    ```\n    - `content: \" \"`：是在父容器的结尾处放一个空白字符；\n    - `display: block; clear: both;`：是确保这个空白字符是非浮动的独立区块。\n    - :after选择符IE 6不支持，所以我们添加一条IE 6的独有命令\"zoom:1;\"就行了。这条命令的作用是激活父元素的\"hasLayout\"属性，让父元素拥有自己的布局。IE 6会读取这条命令，而其他浏览器则会直接忽略它。\n\n#### 第二类方法（不推荐）\n通过设置父元素 overflow 或者display：table 属性来闭合浮动，这里的原理涉及到BFC（[如何创建bfc](/Question-Bank/css/box-sizing&margin-collapse&BFC.md#如何创建bfc：)）\n1. 添加额外标签，在浮动元素末尾添加一个新标签：\n    ```html\n    <div style=”clear:both;”></div> // 清除float:left 和 float:right的影响\n    ```\n2. 父元素也设置浮动\n    - 优点：不存在结构和语义化问题，代码量极少。\n    - 缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用。\n\n3. 父元素设置overflow属性\n    通过设置父元素overflow为hidden或者auto；在IE6中还需要触发hasLayout，例如zoom：1；\n    - 优点：不存在结构和语义化问题，代码量极少。\n    - 缺点：overflow:hidden；内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；不要使用overflow:auto；多层嵌套后，firefox与IE 可能会出现显示错误。\n\n\n## 关于display\n- inline(默认值)：内部元素的宽高+padding会撑开其宽高，主动给其设置宽高是无效的。inline不单独占一行，其他元素紧跟其后。\n- block：实际宽高是本身宽高+padding，但block是可以设置宽高的。独占一行。\n- inline-block：inline-block既具有block的宽高特性又具有inline的同行元素特性。\n- none：`display: none`**不渲染**，不会保留元素本该显示的空间（`即不在 render tree中`），但是`visibility: hidden`还是**渲染了**，会保留空间（在render tree中），只是视觉上看不到而已。\n\n### 行内元素和块级元素\n\n#### 行内元素特点：（margin 在垂直方向上不生效；设置 padding 本身生效，但是没有把父级元素撑开；）\n- 和其他元素都在一行上；\n- 元素的高度、宽度、行高及顶部和底部边距不可设置；\n- 元素的宽度就是它包含的文字或图片的宽度，不可改变。 \n- **典型行内元素**：span、a、label、input、textarea、select、 img、br、strong和em就是典型的行内元素（inline）。\n\n#### 块级元素特点\n- 每个块级元素都从新的一行开始，并且其后的元素也另起一行。\n- 元素的高度、宽度、行高以及顶和底边距都可设置。\n- 元素宽度在不设置的情况下，和父元素的宽度一致，除非设定一个宽度。\n- **典型块级元素**：div、p、h1、form、ul 和 li 就是典型的块级元素（block）。\n\n\n## position\npostion属性属于CSS流的第三种定位规则，position常用值有 position : absolute | fixed | relative 。\n\n### 绝对定位（absolute与fixed）：\n绝对定位元素的display为块级\n- absolute：\n    - 在无已定位祖先元素时，以根节点`<html>`为基准偏移；\n    - 在有已定位祖先元素时，`相对于最近一级的、不是static定位的父元素`来定位。\n- fixed：\n    - 无论有无已定位祖先元素，都以浏览器`可视窗口为基准`偏移。所以有滚动条时，位置是相对于窗口固定的，浮于标准文档流上方（z-index方向）。\n\n### 相对定位：\n- relative：\n    - `相对于自身原有位置进行偏移`，仍处于标准文档流之中。保有原来的display属性。\n    - **注意**：`relative元素如果设置偏移后，它原来占据的文档流中的位置仍然会保留，不会被其他块浮动过来填补掉。并且，它的偏移也不会把别的块从文档流中原来的位置挤开，如果有重叠的地方它会重叠在其它文档流元素之上`。\n    - **注意**：top|right|bottom|left的细节：“定位父元素border内边到该元素margin外边的距离”。\n\n\n\n\n\n\n\n"},{"title":"DOM事件基本概念","url":"/Roundtables/Question-Bank/dom/dom-event.html","content":"---\ntitle: DOM事件基本概念\ntags: [DOM, 布局, 浮动, 绝对定位, flex, table]\ncategories: DOM\n---\n\n# DOM事件基本概念\n\n## 基本概念：DOM事件的级别\n- DOM0：element.onclick = function() {}\n- DOM2：element.addEventListener(‘click’, function(){}, false)\n- DOM3：element.addEventListener(‘keyup’,function(){}, false)\n\n## DOM事件模型：捕获和冒泡\n- `DOM事件流：事件流描述的是从页面中接收事件的顺序`。\n- `DOM2级`事件规定的事件流包括 3个阶段：`事件捕获阶段`，`处于目标阶段`和`事件冒泡阶段`。事件捕获为捕获事件提供了机会，然后是实际的目标接收到事件，最后的冒泡阶段对事件作出响应。\n- 描述DOM事件捕获的具体流程:\n    > window =》document =》html =》body =》… =》目标元素\n    >>（document.documentElement返回文档对象（document）的根元素，如 `<html>` 元素）\n\n### 捕获与冒泡演示\n- 均在事件捕获阶段触发，因此点击el元素后控制台输出为：\n![](./images/dom-1-01.png)\n\n![](./images/dom-1-02.png)\n\n- 将其中比如document元素改为冒泡模式：\n![](./images/dom-1-03.png)\n\n![](./images/dom-1-04.png)\n\n> 因此，这对应了DOM2级事件流三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。\n\n## Event对象的常见应用\n- event.preventDefault() 阻止默认事件\n- event.stopPropagation() 阻止事件冒泡\n- event.stopImmediatePropagation() 事件响应优先级（在当前响应函数中使用该方法可以阻止其他响应函数）；\n- `event.currentTarget 事件代理中绑定事件的元素`\n- `event.target 返回触发事件的目标元素`\n\n## 自定义事件与自定义触发事件\n ```js\nvar eve = new Event('test'); // new CustomEvent('test)\n\nel.addEventListener('test', function() {\n    console.log('test dispatch');\n})\n\nsetTimeout(function() {\n    el.dispatchEvent(eve);\n}, 1000)\n ```\n- 自定义事件名是test，触发通过el.dispatchEvent(eve);\n- 通过Event只能指定事件名，不能增加数据参数;\n- CustomEvent相比于Event唯一的区别是，还可以增加数据参数;\n\n## 事件代理是怎么运作的\n- 事件代理利用两个js事件特性：事件冒泡、目标元素。\n- 使用事件代理的话我们可以把事件处理器添加到一个祖先元素上，等待事件从它的子级元素里冒泡上来，并且可以很方便地判断出这个事件是从哪个元素开始的。\n```js\nvar ulNode = document.getElementById(\"ul\");\n\nulNode.addEventListener('click', function(e) {\n  if (e.target && e.target.tagName.toLowrCase() === 'li') {\n    //需要执行的代码\n  }\n}, false);\n```\n\n"},{"title":"异步编程（4）：async、await","url":"/Roundtables/Question-Bank/execution/asynchronous-async&await.html","content":"---\ntitle: 异步编程（4）：async、await\ntags: [async&await]\ncategories: execution\n---\n\n# 异步编程（4）：async、await\n\n# async/await 用法整理\n\n它最受欢迎的地方：**能让异步代码写起来像同步代码，并且方便控制顺序。**\n\n## 1、async/await 概念解释\n\n- async\n    > async的用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行，async 函数返回的是一个promise 对象。\n\n- await\n   > await的含义为等待。意思就是代码需要等待await后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。这正是同步的效果。\n\n## 2、async函数是Generator函数的语法糖，并对Generator进行了改进。\n\nasync函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n\n### async的改进\n\nasync彻底告别了执行器和生成器，实现更加直观简洁的代码，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。\n                              \nasync函数对 Generator 函数的改进，体现在以下四点：\n\n1. `内置执行器`。Generator 函数的执行必须依靠执行器，而 async 函数自带执行器，无需手动执行 next() 方法。\n2. `更好的语义`。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n3. `更广的适用性`。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。\n4. `返回值是 Promise`。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。\n\n## 3、async/await 与 promise 相比的优势\n\n1. **同步代码编写方式**:\n    - 用同步的思维来解决异步问题的方案。\n    - Promise使用then函数进行链式调用，一直点点点，是一种从左向右的横向写法；\n    - async/await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯。\n\n2. **多个参数传递**:\n    - Promise的then函数只能传递一个参数，虽然可以通过包装成对象来传递多个参数，但是会导致传递冗余信息，比较麻烦；\n    - async/await没有这个限制，可以当做普通的局部变量来处理，用let或者const定义的块级变量想怎么用就怎么用，完全没有限制；\n\n3. **同步代码和异步代码可以一起编写**:\n    - 使用Promise的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰；\n    - async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别，当然，异步过程需要包装成一个Promise对象放在await关键字后面；\n\n4. **基于协程**:\n    - Promise是根据函数式编程的范式，对异步过程进行了一层封装；\n    - async/await基于协程的机制，是真正的“`保存上下文，控制权切换……控制权恢复，取回上下文`”这种机制，是对异步过程更精确的一种描述；\n\n5. ✨**这点并不是优势也不算劣势（只能串行）**:\n    它不能取代 Promise，尤其是我们可以很方便地`用Promise.all()来实现并发`，而`async/await只能实现串行`。\n\n## 4、async关键字的特性\n\n1. **非阻塞，无等待：**\n    - async函数里面如果有异步过程会等待，但是```async函数本身会马上返回```，不会阻塞当前线程;\n    - 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；\n    - 在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句，这和普通返回Promise对象的函数并无二致；\n\n2. **async函数返回类型为Promise对象：**\n    这是和普通函数本质上不同的地方，也是使用时重点注意的地方；\n    - （1）return newPromise()；这个符合async函数本意；\n    - （2）return data；这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data)；还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data => { })函数才可以拿到这个data；\n    - （3）如果没有返回值，相当于返回了Promise.resolve(undefined)；\n\n3. **async统一catch，await不处理异步error：**\n    async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误，await是不管异步过程的reject(error)消息的；\n\n4. 表明程序里面可能有异步过程：\n    - async关键字表明程序里面可能有异步过程，里面可以有await关键字；\n    - 当然全部是同步代码也没关系，但是这样async关键字就显得多余了；\n\n\n```js\nasync function testAsync() {\n    return \"hello async\";\n}\n\nconst result = testAsync(); // 返回一个Promise对象\nconsole.log(result);\n// async函数返回的是一个Promise对象，async函数（包括函数语句、函数表达式、Lambda表\n// 达式）会返回一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通\n// 过Promise.resolve() 封装成 Promise 对象；\n\n\n// async函数返回的是一个Promise对象，所以在最外层不能用await获取其返回值的情况，\n// 应该使用原始的方式：then()链来处理这个Promise对象\ntestAsync().then(v => {\n    console.log(v);    // 输出 hello async\n});\n```\n\n## 4、await关键字的特性\n\n1. **await只能在async函数内部使用：**\n    不能放在普通函数里面，否则会报错；\n\n2. **await后面也可以跟同步代码：**\n    不过系统会自动将其转化成一个Promsie对象，比如：\n    ```js\n    const a = await 'hello world'\n\n    // 相当于\n    const a = await Promise.resolve('hello world');\n\n    // 跟同步代码是一样的，还不如省事点，直接去掉await关键字\n    const a = 'hello world';\n    ```\n3. ✨**await对于失败消息的处理：**\n    await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择：\n    1. 让await后面的Promise对象自己catch；\n    2. 也可以让外面的async函数返回的Promise对象统一catch；\n    3. 像同步代码一样，放在一个try...catch结构中；\n    ```js\n    // 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字\n    async componentDidMount() {\n        // 将异步和同步的代码放在一个try..catch中，异常都能抓到\n        try {\n            let array = null;\n            let data = await asyncFunction();  // 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象\n            if (array.length > 0) {  // 这里会抛出异常，下面的catch也能抓到\n                array.push(data);\n            }\n        } catch (error) {\n            alert(JSON.stringify(error))\n        }\n    }\n    ```\n## 使用场景实践\n\n::: details 使用场景实践\n### （1）像写同步代码那样，定义异步流程\n\n```js\n// 异步过程封装\nfunction sleep(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve('sleep for ' + ms + ' ms');\n        }, ms);\n    });\n}\n\n// 定义异步流程，就像写同步代码那样\nasync function asyncFunction() {\n    console.time('asyncFunction total executing:');\n    const sleep1 = await sleep(2000);\n    console.log('sleep1: ' + sleep1);\n    const [sleep2, sleep3, sleep4]= await Promise.all([sleep(2000), sleep(1000), sleep(1500)]);\n    console.log('sleep2: ' + sleep2);\n    console.log('sleep3: ' + sleep3);\n    console.log('sleep4: ' + sleep4);\n    const sleepRace = await Promise.race([sleep(3000), sleep(1000), sleep(1000)]);\n    console.log('sleep race: ' + sleepRace);\n    console.timeEnd('asyncFunction total executing:');\n    \n    return 'asyncFunction done.'  // 这个可以不返回，这里只是做个标记，为了显示流程\n}\n\n// 像普通函数调用async函数，在then函数中获取整个流程的返回信息，\n// 在catch函数统一处理出错信息\nasyncFunction().then(data => {\n    // asyncFunction return 的内容在这里获取: 'asyncFunction done.'\n    console.log(data);\n}).catch(error => {\n    // asyncFunction 的错误统一在这里抓取\n    console.log(error);\n});\n\n// 这个代表asyncFunction函数后的代码，\n// 显示asyncFunction本身会立即返回，不会阻塞主线程\nconsole.log('after asyncFunction code executing....');\n\n```\n\n```js\n// 执行结果\nafter asyncFunction code executing....\nsleep1: sleep for 2000 ms\nsleep2: sleep for 2000 ms\nsleep3: sleep for 1000 ms\nsleep4: sleep for 1500 ms\nsleep race: sleep for 1000 ms\nasyncFunction total executing:: 5006.276123046875ms\nasyncFunction done.\n\n// console输出：\nPromise {<pending>}\n    __proto__: Promise\n    [[PromiseStatus]]: \"resolved\"\n    [[PromiseValue]]: \"asyncFunction done.\"\nVM12229:5 sleep1: sleep for 2000 ms\nVM12229:7 sleep2: sleep for 2000 ms\nVM12229:8 sleep3: sleep for 1000 ms\nVM12229:9 sleep4: sleep for 1500 ms\nVM12229:11 sleep race: sleep for 1000 ms\nVM12229:12 asyncFunction total executing:: 5004.796875ms\n```\n代码分析：\n- after asyncFunction code executing....代码位置在async函数asyncFunction()调用之后，反而先输出，这说明async函数asyncFunction()调用之后会马上返回，不会阻塞主线程；\n- sleep1: sleep for 2000 ms这是第一个await之后的第一个异步过程，最先执行，也最先完成，说明后面的代码，不论是同步和异步，都在等他执行完毕；\n- sleep2 ~ sleep4这是第二个await之后的Promise.all()异步过程，这是“比慢模式”，三个sleep都完成后，再运行下面的代码，耗时最长的是2000ms；\n- sleep race: sleep for 1000 ms这是第三个await之后的Promise.race()异步过程，这是“比快模式”，耗时最短sleep都完成后，就运行下面的代码，耗时最短的是1000ms；\n- asyncFunction total executing:: 5006.276123046875ms这是最后的统计总共运行时间代码，三个await之后的异步过程之和：\n    > 1000（独立的） + 2000（Promise.all） + 1000（Promise.race） = 5000ms\n- 这个和统计出来的5006.276123046875ms非常接近，说明上面的异步过程，和同步代码执行过程一致，协程真的是在等待异步过程执行完毕；\n- asyncFunction done.这个是async函数返回的信息，在执行时的then函数中获得，说明整个流程完毕之后参数传递的过程；\n\n### （2）顺序执行，结果作为下一次输入\n\n```js\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n\n```\n\n```js\n// Promise方式调用\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n```\n\n```js\n// async/await方式调用\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n### （3）中间参数需要保留\n\n```js\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(m, n) {\n    console.log(`step2 with ${m} and ${n}`);\n    return takeLongTime(m + n);\n}\n\nfunction step3(k, m, n) {\n    console.log(`step3 with ${k}, ${m} and ${n}`);\n    return takeLongTime(k + m + n);\n}\n```\n\n```js\n// Promise方式调用\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => {\n            return step2(time1, time2)\n                .then(time3 => [time1, time2, time3]);\n        })\n        .then(times => {\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        })\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n\n// step1 with 300\n// step2 with 300 and 500\n// step3 with 300, 500 and 1000\n// result is 2000\n// doIt: 2913.488037109375ms\n```\n> 注意：这里为什么不能直接这样写promise式调用，因为中间参数 time2、time3都没有办法保存\n```js\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time1, time2))\n        .then(time3 => step3(time1, time2, time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n```\n\n```js\n// async/await方式调用\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n\n// step1 with 300\n// step2 with 300 and 500\n// step3 with 300, 500 and 1000\n// result is 2000\n// doIt: 2913.488037109375ms\n```\n:::\n\n参考链接：\n\n[async/await的基础用法](https://www.jianshu.com/p/73b070eebf50)\n\n[async/await 原理及执行顺序分析](https://juejin.im/post/5dc28ea66fb9a04a881d1ac0)\n"},{"title":"异步编程（1）：回调函数","url":"/Roundtables/Question-Bank/execution/asynchronous-cb.html","content":"---\ntitle: 异步编程（1）：回调函数\ntags: [回调函数, 发布订阅, 回调地狱]\ncategories: execution\n---\n\n# 异步编程（1）：回调函数\n\n## 什么叫「异步」\n- “异步”，就是一个任务分成两段，先执行第一段，转而执行其他任务，等做完后再回来执行剩下的第二段。这种不连续的执行，就叫异步。\n- “同步”，连续的执行的任务就是同步。由于连续执行，不能插入其他任务，类似操作系统从硬盘读取文件所花费的时间，就只能等待，效率很低。\n\n异步编程的语法目标，就是 `“让它更像同步编程”`。\n\n## 回调函数→事件发布/订阅\n\n- Q：什么是回调函数？\n- A：js异步编程的实现就是回调函数。回调函数就是把任务的第二段单独写在一个callback函数中，等到重新执行该任务时直接调用这个callback函数。\n\n- Q：回调函数有什么问题？\n- A：回调函数本身没有问题，问题在于多层回调嵌套所导致的`“回调地狱”`。代码不是纵向发展而是横向发展的，杂乱不好管理。\n\n- Q：解决途径？\n- A：事件**发布订阅**就是为了解决回调嵌套问题的。传送门[EventEmitter实现](/Question-Bank/nodejs/eventEmitter.html)\n\n\n\n"},{"title":"异步编程（3）：Generator函数","url":"/Roundtables/Question-Bank/execution/asynchronous-gen.html","content":"---\ntitle: 异步编程（3）：Generator函数\ntags: [Generator]\ncategories: execution\n---\n\n## 异步编程（3）：Generator函数\n\n### 定义\n\n- Generator 函数是一个状态机，封装了多个内部状态。执行Generator函数会返回一个[遍历器对象](http://es6.ruanyifeng.com/#docs/iterator)，可以依次遍历Generator函数的每一个状态，\n但是只有调用`next`方法才能遍历到下一个状态，所以其实提供了一种暂停执行函数，`yield`表达式就是暂停标志。\n\n```javascript\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n\nhw.next() // { value: 'hello', done: false }\nhw.next() // { value: 'world', done: false }\nhw.next() // { value: 'ending', done: true }\nhw.next() // { value: undefined, done: true }\n```\n\n可以看出，`Generator函数被调用时并不会执行`，而是返回了一个`遍历器对象`，只有调用`next`方法、内部指针指向该语句时才执行，每次调用next方法，就回返回一个对象包含`value`和`done`两个属性，`value`属性表示内部状态的值，是yield表达式后面表达式返回的值；`done`属性是个布尔值，表示是否遍历结束。\n\n### Generator执行原理\n\n#### 协程原理\n\n- Generator函数可以`暂停和恢复执行`，这就是**协程的原理**：一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种`可以并行执行、交换执行权的线程（或函数），就称为协程`。\n- 一句话概括：`保存上下文，控制权切换……控制权恢复，取回上下文`。\n- 协程的有两大优势： `没有线程切换开销，具有极高的执行效率`、`不需要多线程的锁机制`：\n\n#### 协程与线程的关系\n- 协程是一种比线程更加轻量级的存在。\n- 普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务。\n- 一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。\n\n::: details 关于协程\n- 进程 > 线程 > 协程\n\n- 协程的第一大优势是 `没有线程切换开销，具有极高的执行效率`：因为子程序切换不是线程切换，而是由程序自身控制，因此没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；\n\n- 协程的第二大优势是 `不需要多线程的锁机制`：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多；\n\n- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行，需要注意的是：在一个子程序中中断，去执行其他子程序，这并不是函数调用，有点类似于CPU的中断；\n    > 用汽车和公路举个例子：js公路只是单行道（主线程），但是有很多车道（辅助线程）都可以汇入车流（异步任务完成后回调进入主线程的任务队列）；generator把js公路变成了多车道（协程实现），但是同一时间只有一个车道上的车能开（依然单线程），不过可以自由变道（移交控制权）；\n\n- 线程包含于进程，协程包含于线程，只要内存足够，一个线程中可以有任意多个协程，但某一个时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源；\n\n- 就实际使用理解来说，协程允许我们写同步代码的逻辑，却做着异步的事，避免了回调嵌套，使得代码逻辑清晰；\n\n- 何时挂起，唤醒协程：协程是为了使用异步的优势，异步操作是为了避免IO操作阻塞线程，那么协程挂起的时刻应该是当前协程发起异步操作的时候，而唤醒应该在其他协程退出，并且他的异步操作完成时；\n\n- 单线程内开启协程，一旦遇到io，从应用程序级别（而非操作系统）控制切换对比操作系统控制线程的切换，用户在单线程内控制协程的切换，优点如下：\n1）协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；\n2）单线程内就可以实现并发的效果，最大限度地利用cpu；\n\n- 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。\n:::\n\n#### 执行流程\n它的运行流程大致如下：\n```html\n1. 协程A开始执行\n2. 协程A执行到某个阶段，进入暂停，执行权转移到协程B\n3. 协程B执行完成或暂停，将执行权交还A\n4. 协程A恢复执行\n```\n协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n\n### Generator的执行器\n\n#### 执行器概念\n- 执行生成器代码的函数，就称为执行器,`co` 模块就是一个著名的执行器。\n- Generator 是一个异步操作的容器。它是需要手动执行的，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。两种方法可以做到这一点：\n    1. 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。\n    2. Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权\n    \n#### 实现基于 Promise 对象的简单自动执行器\n\n下面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。\n```javascript\nfunction run(gen) {\n  var g = gen(); // 返回状态机\n  \n  function next(data) {\n    var result = g.next(data);\n    if (result.done) {\n        return result.value;\n    } else {\n        result.value.then(() => {\n          next(data)\n        })\n    }\n  }\n  \n  next()\n}\n```\n\n这样使用：\n```js\nfunction* foo() {\n    let res1 = yield fetch('https://xxx') //返回promise对象\n    console.log('res1', res1)\n\n    let res2 = yield fetch('https://xxx') //返回promise对象\n    console.log('res2', res2)\n}\n\nrun(foo);\n```\n\n参考链接：[async/await 原理及执行顺序分析](https://juejin.im/post/5dc28ea66fb9a04a881d1ac0)\n\n\n\n\n"},{"title":"异步编程（2）：Promise对象","url":"/Roundtables/Question-Bank/execution/asynchronous-promise.html","content":"---\ntitle: 异步编程（2）：Promise对象\ntags: [Promise]\ncategories: execution\n---\n\n# 异步编程（2）：Promise对象\n\n## 定义及使用\n- Promise就是‘承诺’在某个逻辑时间点执行异步操作。有三种状态：pending(进行中)、fulfilled (已完成)、rejected(已失败)。\n- Promise状态改变只有两种情况：pending => fulfilled (初始态到成功态)、pending => reject (初始态到失败态度)\n\nnew Promise()实例需要传一个function，包含两个参数，类型都是function，分别是resolve函数和reject函数。Promise实例状态为成功时会调用`resolve方法`；状态为失败时调用`reject方法`。\n\n## 特点\n\n- 即只有异步操作的结果可以决定当前是哪一种状态，任何外界操作都无法改变这个状态；\n- 状态一经改变就凝固了，不会再变，之后任何时候都可以得到这结果，即使添加更多的回调函数也会立即得到这结果。\n\n- promise一旦建立就无法取消，并会立即执行；\n- 如果不设置回调函数，promise内部抛出的错误外边无法获取到；\n- promise处于pending状态时，不知道promise执行的具体进度（刚开始执行还是快要执行结束）\n\n## 核心方法\n1. `Promise.prototype.then()`：\n    - 作用是为 Promise 实例添加状态改变时的回调函数。then()接受两个参数，第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\n    - then方法返回的是一个**新的Promise实例**（注意，不是原来那个Promise实例）。因此可以实现Promise的链式调用，即then方法后面再调用另一个then方法。链式调用的特点是无论第一个then是成功还是失败，都将它的返回值作为下一次成功回调函数的参数。（注意：如果只完成链式调用，其本质上只需将this返回出去即可。这里实现的是链式Promise调用，所以每次then都会返回一个新的promise）。\n\n2. `Promise.prototype.catch()`\n    - Promise.prototype.catch()方法是.then(null, rejection)的别名，指定错误发生时的回调函数。\n\n3. Promise.all()\n    - Promise.all用于将多个Promise实例包装成新的Promise实例p。接收的参数数组[p1, p2, p3]均为Promise实例，如果不是就转换成Promise实例。\n    - 只有数组中所有实例状态都变为Fulfilled，总的实例p的状态才会变为Fulfilled；\n    只要数组中有一个实例状态被Rejected，总的实例p的状态就变为Rejected。\n4. Promise.race()\n    - 与all()相对应的方法。Promise.race用于将多个Promise实例包装成一个新的实例。\n    只要有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的实例返回值，就传递给p的回调函数。\n5. Promise.resolve()\n    - 将现有对象转换为Promise对象。如果Promise.resolve方法的参数不是具有then方法的对象，则返回一个新的Promise，其状态为Resolved。\n6. Promise.reject()\n    - Promise.reject(reason)也会返回一个新的Promise实例，状态为Rejected。Promise.reject方法的参数reason会被传递给实例的回调函数。\n\n## 实现 Promise.finally\n\n> finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，使用方法如下\n```js\nPromise\n    .then(res => {...})\n    .catch(err => {...})\n    .finally(() => {...})\n```\n> finally不接收任何参数；finally本质上是then的特例。\n\n```js\nPromise.prototype.finally = function(callback) {\n    let P = this.constructor\n\n    return this.then(\n        value => P.resolve(callback()).then(() => value),\n        reason => P.resolve(callback()).then(() => {\n            throw reason;\n        })\n    )\n}\n```\n\n## Promise本质\n- Promise的概念并不是ES6新出的，而是ES6统一了用法，写进了语言标准，原生提供了Promise对象。\n- Promise的写法只是回调函数的改进，使用then()之后，异步任务的两段执行看得更清楚，除此之外`并无新意`。撇开优点，Promise的最大问题就是代码冗余，原来的任务被Promise包装一下，不管什么操作，一眼看上去都是一堆then()，原本的语意变得很不清楚。\n\n\n\n"},{"title":"运行JS","url":"/Roundtables/Question-Bank/execution/context.html","content":"---\ntitle: 运行JS\ntags: [预处理阶段, 执行上下文, 变量对象和活动对象, 作用域链, this指向]\ncategories: execution\n---\n\n# 运行JS\n\n运行JS的过程，主要包括【预处理阶段】和【执行阶段】：\n\n- 预处理阶段：预处理阶段会做一些事情，确保JS可以正确执行，比如分号补全，变量和函数的声明提升等（由于自动分号补全机制的问题，可能会导致出错，所以虽然有这个预处理阶段，但还是提倡要写分号）；\n- 执行阶段：执行阶段要涉及【执行上下文、变量对象和活动对象、作用域链、this机制】等知识点。\n\n## 作用域（执行上下文，执行环境）\n\n### 作用域概念\n- JS中的执行上下文，又称为作用域，或执行环境。\n- JS没有块级作用域，而是通过函数来划分作用域的。只有全局作用域和函数作用域。\n\n### 作用域的作用\n每个函数的执行都会创建其对应的函数作用域，作用是：`作用域决定了内部变量的生命周期(即何时被释放)，以及哪一部分代码可以访问其中的变量`。\n\n### 作用域的工作流程\n1. 浏览器在首次载入脚本时，会创建全局执行上下文（`全局作用域`），并压入**执行栈**栈顶（`全局执行上下文是永远不会被弹出的`）；\n2. 然后每进入其它作用域（即`函数作用域`）就创建对应的执行上下文并把它压入执行栈的顶部，一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的执行栈。\n3. 这样依次执行（最终都会回到全局执行上下文）。\n4. 当前执行上下文执行完毕时，被弹出执行栈，然后如果其没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器*自动回收*。\n\n::: details 例题：函数与变量提升\n这题就像脑筋急转弯：\n```js\nfunction Foo() {\n    getName = function() {\n        console.log(1)\n    }\n    return this\n}\n\nFoo.getName = function() {\n    console.log(2)\n}\n\nFoo.prototype.getName = function() {\n    console.log(3)\n}\n\nvar getName = function() {\n    console.log(4)\n}\n\nfunction getName() {\n    console.log(5)\n}\n\n// 请写出如下输出结果：\nFoo.getName()               // (1)\ngetName()                   // (2)\nFoo().getName()             // (3)\ngetName()                   // (4)\nnew Foo.getName()           // (5)\nnew Foo().getName()         // (6)\nnew new Foo().getName()     // (7)\n```\n要解出这道题，关键要搞懂两个知识点：函数变量提升 与 运算优先级。\n首先，输出4与5的两处是有变量提升的，提升后如下：\n```js\n// 提升到顶部\nvar getName;\nfunction getName() {\n    console.log(5)\n}\n\nfunction Foo() {\n    getName = function() {\n        console.log(1)\n    }\n    return this\n}\n\nFoo.getName = function() {\n    console.log(2)\n}\n\nFoo.prototype.getName = function() {\n    console.log(3)\n}\n\n// 声明提升到顶部，但函数体还在原处\ngetName = function() {\n    console.log(4)\n}\n\n// 声明与函数体整体提升到顶部\n// function getName() {\n//     console.log(5)\n// }\n```\n因此，(1)到(4)输出如下：\n```js\nFoo.getName()               // (1)：输出2，直接调用Foo的静态方法\ngetName()                   // (2)：输出4，由于赋值为4的函数体在最后执行，给getName最终赋值为4\nFoo().getName()             // (3)：输出1，调用函数Foo，返回this，其中打印1的getName前面无var，这不是局部函数，而是对全局函数变量getName的重写赋值，所以这里输出的是全局的this。getName，输出1\ngetName()                   // (4)：输出1，由于前一步中对全局getName变量重新赋值为1，因此这里还是打印1\n```\n再考虑第二个关键知识点，运算符优先级：**`()` > `.` > `带参数New` > `无参数New`**，因此(5)到(7)输出如下：\n```js\nnew Foo.getName()           // (5)：输出2，因为.的优先级大于new，先得出2，new 2，最终输出2\nnew Foo().getName()         // (6)：输出3，因为()的优先级大于. ，因此new Foo()先实例化得到foo，再计算foo.getName()，则会从原型上找到方法，输出3\nnew new Foo().getName()     // (7)：输出3，因为第二个new是带参数的new操作符，所以new Foo()先实例化得到foo，原式等价于new foo.getName()，先计算.操作符得到3，new 3，得到最终3\n```\n至此，最终结果为：\n```js\n// 请写出如下输出结果：\nFoo.getName()               // (1)：2\ngetName()                   // (2)：4\nFoo().getName()             // (3)：1\ngetName()                   // (4)：1\nnew Foo.getName()           // (5)：2\nnew Foo().getName()         // (6)：3\nnew new Foo().getName()     // (7)：3\n```\n:::\n### 怎样理解“父作用域”\n**注意**：函数的父级作用域是指函数定义的时候的父级作用域，不是指执行时候的父级作用域。\n- 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全局环境;\n- 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;\n\n## 作用域的重要属性（3个：变量对象VO，作用域链，this）：\n\n### VO与AO\n`变量对象VO`（Variable object，VO）是执行上下文的属性，`活动对象AO`（activation object）是当函数被调用者激活时创建的。\n可以理解为：\n- 在函数作用域中：VO === AO\n- 在全局作用域中：VO === this === global\n\n总的来说，VO中会存放一些变量信息（如声明的变量，函数，arguments参数等等）\n\n### 作用域链有什么作用\n- 当代码在一个环境中执行时，会创建关于变量对象的一个作用域链(scope chain)。\n- 作用域链的用途，是`保证对执行环境有权访问的所有变量和函数的有序访问`。\n    - 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。\n    - 如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象(这个对象在全局环境中是不存在的)。\n    - 作用域链中的下一个变量对象来自包含(外部父)环境，而再下一个变量对象则来自下一个包含环境。\n    - 这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。\n- **解析标识符**的过程，是沿着作用域链一级一级地搜索标识符。搜索过程始终从作用域链的前端开始， 然后逐级地向上查找，直至找到标识符为止，如果在全局作用域依然没有找到，则报错。\n\n### this指向问题\nthis是在运行时基于函数的执行环境绑定的，是由其调用方式决定的。\n\n#### 绑定规则\n1. `默认绑定`：绑定到全局对象window或global，在严格模式下绑定到undefined。\n2. `隐式绑定`：由上下文对象调用，绑定到那个上下文对象（`谁调用，指向谁`）。\n3. `主动绑定`：由call或者apply(或者bind)调用，绑定到指定的对象。\n4. 由new调用：绑定到新创建的实例对象。\n\n#### 例子及回退机制\n1. 默认绑定\n```js\nfunction display(){\n console.log(this); // 'this' 将指向全局变量\n}\n\ndisplay();\n```\n解析：这是一个普通的函数调用。在这种情况下，\ndisplay() 方法中的 this 在非严格模式下指向 window 或 global 对象。\n在严格模式下，this 指向 undefined。\n\n2. 隐式绑定\n```js\nvar obj = {\n name: 'Saurabh',\n display: function(){\n   console.log(this.name); // 'this' 指向 obj\n  }\n};\n\nobj.display(); // Saurabh \n```\n以上就是常规调用规则：谁调用，指向谁。\n\n但是，当将这个函数引用赋值给其他变量，并使用这个新函数引用去调用该函数时，我们在 display() 中获得了不同的this值。\n```js\nvar name = \"uh oh! global\";\nvar outerDisplay = obj.display;\nouterDisplay(); // uh oh! global\n```\n当调用 outerDisplay() 时，我们没有指定一个具体的上下文对象。这是一个没有所有者对象的纯函数调用。在这种情况下，display() 内部的 this 值回退到默认绑定。现在这个 this 指向全局对象，在严格模式下，它指向 undefined。\n\n::: warning 回退机制：隐式绑定 => 默认绑定\n在将隐式绑定的函数**以回调的形式传递给**另一个`自定义函数`、`第三方库函数`或者像 `setTimeout 这样的内置JavaScript函数`时，都适用于上述情况，**回退到默认绑定规则**，例如：\n```js\nvar name = \"uh oh! global\";\n\nvar obj = {\n name: 'Saurabh',\n display: function(){\n   console.log(this.name); // 'this' 指向 obj\n  }\n};\n\nsetTimeout( obj.display, 1000 ); // uh oh! global\n```\n分析：当调用 setTimeout 时，JavaScript 在内部将 obj.display 赋给 setTimeout的回调参数 callback。这种**赋值操作会导致 display() 函数丢失其上下文**。当此函数最终在 setTimeout 函数里面被调用时，display()内部的 this 的值会退回至默认绑定。\n:::\n\n3. 主动绑定\n```js\nvar name = \"uh oh! global\";\nvar obj = {\n    ...\n};\n\nobj.display = obj.display.bind(obj); \nvar outerDisplay = obj.display;\n\nouterDisplay(); // Saurabh\n```\n分析：将 this 的值通过 bind() 方法绑定到对象上。即使我们将 obj.display 直接作为 callback 参数传递给函数，display() 内部的 this 也会正确地指向 obj。\n\n\n#### 忘记使用new\n如果你不是使用new来调用构造函数，那其实你就是在使用一个实函数。因此this就不会是你预期的值。this指向的就是window，而你将会创建全局变量（不过如果使用的是strict模式，那你还是会得到警告（this===undefined））。\n```js\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\n// 此处忘记使用 new 了\nvar p = Point(7, 5);\n\nconsole.log(p === undefined) // true\n// 此时创建了全局变量\nconsole.log(x); // 7\nconsole.log(y); // 5\n```\n\n#### 例题1\n```js\nvar name = 'tiger'\n\nvar handle = function() {\n    var name = 'fintech'\n    return `${name}-${this.name}`\n}\n\nvar departments = {\n    name: 'trade',\n    getName: function() {\n        return `${name}-${this.name}`\n    },\n    esop: {\n        name: 'fe',\n        getName: function() {\n            return `${name}-${this.name}`\n        },\n    },\n    other: {\n        name: 'dev',\n        getName: function() {\n            return `${name}-${this.name}`\n        },\n    }\n}\n\nvar getName = departments.getName;\n\nconsole.log(handle()) // fintech-tiger\nconsole.log(getName()) // tiger-tiger\nconsole.log(departments.getName()) // tiger-trade，注意隐式绑定回退到默认\nconsole.log(departments.esop.getName()) // tiger-fe\nconsole.log(departments.other.getName()) // tiger-tiger\n```\n\n## 闭包\n\n### 什么是闭包\n是指有权访问另外一个函数作用域中的变量的函数。解决的问题是在局部作用域中的变量无法被外部访问，这时就可以通过在局部作用域（即这个函数）中创建另一个函数来访问原来这个函数中的变量。\n\n### 创建闭包的常见方式（2种）\n1. 在一个函数内部创建另外一个函数（通常通过return返回这个函数）；\n2. 通过参数传递将一个函数传入另一个函数中；\n\n### 闭包的缺点\n1. 滥用闭包会造成内存的大量消耗；消耗内存是因为：\n    - 正常情况，一个函数在调用开始执行时，创建其执行上下文及相应的作用域链，在函数执行结束后释放函数执行上下文及相应作用域链所占的空间。\n    - 但是由于闭包函数可以访问外层函数中的变量，所以外层函数在执行结束后，其作用域活动对象并不会被释放（注意，外层函数执行结束后执行环境和对应的作用域链就会被销毁，但活动对象不能被销毁），而是被闭包函数的作用域链所引用，直到闭包函数被销毁后，外层函数的作用域活动对象才会被销毁。这也正是闭包要占用内存的原因。\n2. 使用闭包还有其他的副作用，可以说是bug，也可以说不是：这个副作用是闭包函数只能取到外层函数变量的最终值。这个问题可以通过立即执行函数解决。\n\n## 模拟块级作用域\nJS没有块级作用域，在其他类C的语言中，由花括号封闭的代码块都有自己的作用域，花括号的代码块执行完毕后，内部定义的变量随即被销毁。而JS中，花括号的外部依然能访问到花括号内部的变量，这会导致一些问题的出现。这就有了模拟块级作用域的方式：立即执行函数表达式IIFE（或者叫自执行匿名函数）。\n以下两种方式都是IIFE的有效写法，其本质就是匿名函数的调用。\n```js\n(function() { /* code */ } ());\n(function() { /* code */ })();\n```\n- 用圆括号()将匿名函数包裹，js的解释器就会把圆括号()中的内容当做表达式来解释，而后面的第二个圆括号()是执行函数调用的，它写在匿名函数圆括号外部和内部都可以达到同样的目的。\n- IIFE可以用来解决闭包只能取到最终值的问题：\n```js\nfunction foo() {\n    var res = new Array();\n    for (var i = 0; i < 5; i++) {\n        res[i] = function() {\n            return i;\n        };\n    }\n\n    return res;\n}\n\nfoo() // 5 5 5 5 5\n```\n**闭包函数，只能取到i的最终值**：\n- 函数在预解释阶段，都被当成字符串存入堆内存，在真正执行时，才会被拿出来执行。\n- 数组中存储的，其实只是指向这个堆内存的指针，i并没有传进去，执行的时候i才被传进去。\n- 每次循环中的函数都会在父层执行环境中寻找i，他们都保有这个变量 i的引用。\n- 在预解释阶段执行结束（即循环结束），变量i的值自增为5，才到达函数执行阶段，此时每个函数返回的都是这个最终值5。\n\n```js\nfunction foo() {\n    var res = new Array();\n    for (var i = 0; i < 5; i++) {\n        res[i] = (function(index) {\n            return index;\n        })(i)\n    }\n\n    return res;\n}\n\nfoo() // 0 1 2 3 4\n```\n\n**通过IIFE解决闭包bug**：\n- 用立即执行匿名函数包裹起原先的闭包函数，并在第二个()中传入i值，这里的i就是外部执行环境中的i；\n- 由于`函数参数`是`按值传递`的，所以就会将变量 i 的当前值复制给形参index。\n- 闭包引用的变量不会因为垃圾回收机制销毁，所以内部的匿名函数可以返回对应的index值。\n\n\n## 垃圾回收机制\nJS有垃圾处理器，所以无需开发者手动回收内存，而是由`垃圾处理器自动处理`。垃圾处理器对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）。\n### 常用的两种垃圾回收规则\n【标记清除】、引用计数\n`js引擎基础垃圾回收机制是标记清除`。\n- 标记清除：遍历所有可访问的对象并回收已不可访问的对象。\n- 引用计数：记录对象被引用的次数，引用时+1，减持时-1，下次垃圾回收器会回收次数为0的对象的内存（容易出循环引用的bug造成内存泄漏）。\n\n### 垃圾回收的时候有个难以避免的问题\n垃圾回收时**停止响应其他操作**。JS的停止响应时间在100ms以上，对于游戏动画影响很大。\n\n#### 优化：【分代回收】\n避免垃圾回收造成长时间停止响应。区分“临时”与“持久”对象，多回收临时对象，少回收持久对象，减少每次需遍历的对象，从而缩短每次的垃圾回收耗时。Node V8引擎就是采用【分代回收】的，与Java一样。\n\n### 什么会导致内存泄漏\n内存泄漏指任何对象在你不再拥有或不再需要它之后仍然存在。【`循环引用`】和【`闭包`】会导致内存泄漏。只要闭包函数不被销毁，此对象就无法被垃圾回收。\n\n"},{"title":"任务队列 与 Event Loop","url":"/Roundtables/Question-Bank/execution/event-loop.html","content":"---\ntitle: 任务队列 与 Event Loop\ntags: [任务队列, 事件循环, Macro Task, Micro Task]\ncategories: execution\n---\n\n# 任务队列 与 Event Loop\n\n## 如何理解JS的单线程\n传送门[两个问题](/Question-Bank/browser/browser-mechanism.md#两个问题)\n\n## 什么是Event Loop（事件循环）\n- js分为两种任务，一种是`同步任务`（synchronous），另一种是`异步任务`（asynchronous）。\n- 同步任务都在`JS引擎线程`上执行，形成一个`执行栈`；\n- js通过「任务队列」来实现异步回调，`事件触发线程`管理一个`任务队列`（task queue）；\n- 异步任务触发条件达成，会由`定时器线程`或`异步http请求线程`将`回调事件`放到任务队列中；\n- 执行栈中所有同步任务执行完毕，此时**JS引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中**，开始执行。这个过程不断重复。\n\n### 从事件循环的角度简述：setTimeout/setInterval和XHR/fetch到底做了什么事\n- 不管是`setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时，本身是同步任务，而其中的回调函数才是异步任务。\n- 当代码执行到`setTimeout/setInterval`时，实际上是`JS引擎线程`通知`定时器线程`，间隔一个时间后，会触发一个回调事件，而定时器线程在接收到这个消息后，会在等待的时间后，**将回调事件放入到由事件触发线程所管理的事件队列中**。\n- 当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件，而异步http请求线程在接收到这个消息后，会在请求成功后，**将回调事件放入到由事件触发线程所管理的事件队列中**。\n- 当我们的同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给JS引擎线程执行。\n\n### 宏任务 与 微任务\n- Call Stack（主线程调用栈）的执行单位是 Task。Task 分两类 `Macro Task（宏任务）` 和 `Micro Task（微任务）`。\n- 宏任务：每次执行栈执行的代码当做是一个宏任务，无论是同步任务还是从任务队列中拿取的异步回调。\n- 微任务：可以理解成在当前宏任务执行结束时，立即执行的任务，这些微任务是在当前宏任务执行期间所产生的。\n\n#### 常见宏任务\n- setTimeout\n- setInterval \n- setImmediate（nodejs环境）\n- UI rendering（比如一些改变页面css的js代码任务）\n#### 常见微任务\n- Promise\n- process.nextTick（nodejs环境）\n\n#### JS引擎线程(宏任务微任务) 与 GUI渲染线程 的互斥执行顺序\n\n::: tip 顺序\n宏任务-->(可能由当前宏任务所产生的微任务)-->渲染-->宏任务-->(可能由当前宏任务所产生的微任务)-->渲染-->...\n:::\n\n::: details 栗子们\n1. 例子1\n```js\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n- 现象：页面背景会在瞬间变成灰色。\n- 解释：因为以上代码属于`同一次宏任务`，全部执行完再一次性渲染。\n\n2. 例子2\n```js\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n- 现象：页面背景先变为蓝色，然后瞬间变为黑色。\n- 解释：因为以上代码属于`两次宏任务`，第一次宏任务执行完就会先渲染一次，再执行下一次宏任务，然后第二次渲染。\n\n3. 例子3\n```js\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n\n// print 1 3 2\n```\n- 现象：控制台输出1 3 2，页面背景直接变为黑色。\n- 解释：因为以上代码属于`一次宏任务，且有微任务`，blue、log(1)、promise.resolve、log(3)本身都是同步任务，属于一次宏任务，执行完后，紧接着要执行异步的promise.then这个微任务，输出2且执行black，最后才执行渲染。\n\n4. 例子4\n```js\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print 1 3 2\n```\n- 现象：控制台输出1 3 2。\n- 解释：因为以上代码属于`两个宏任务，且第一个宏任务产生了微任务`，所以执行顺序是 宏任务->微任务->宏任务，分别输出1 3 2。\n:::\n\n### Promise.then为什么早于setTimeout执行\n```js\n// 例子1\nsetTimeout(() => console.log('a'), 0);\n\nlet p = new Promise(resolve => {\n    console.log('b');\n    resolve();\n})\n\np.then(() => console.log('c'));\np.then(() => console.log('d'));\n\nconsole.log('e');\n\n// b e c d a\n```\n\n**解释**：首先 `new Promise`和console.log都是同步任务，是在执行栈同步执行的，所以输出b e，且在创建实例p时，就resolve()了，因此宏任务产生了与其对应的微任务（p.then），在此次宏任务执行完时会立即执行微任务输出c d，最后执行第二个宏任务settimeout的回调，输出a。\n\n```js\n// 例子2\n(function test() {\n    setTimeout(() => console.log(4), 0);\n    new Promise(resolve => {\n        console.log(1);\n        for (var i = 0; i < 10000; i++) {\n            i === 9999 && resolve();\n        }\n        console.log(2);\n    }).then(() => {\n        console.log(5);\n    })\n    console.log(3)\n})()\n\n// 1 2 3 5 4\n```\n**解释**：与例子1类似，注意for循环与2、3输出都是同步任务，虽然for循环先执行到resolve，但then是异步任务，是在第一次宏任务执行完后才执行的微任务，所以是1235，最后是第二个宏任务定时器回调。\n\n\n#### setTimeout(fn, 0)的含义\n\n指定某个任务在主线程最早可得的空闲时间执行，也就是说，`尽可能早得执行`。它在\"任务队列\"的尾部添加一个事件，因此要等到同步任务和\"任务队列\"现有的事件都处理完，才会得到执行。0不是0秒，之前最小是10毫秒，现在最小是4毫秒。\n\n> 对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。\n\n###\n\n参考链接：\n[从多线程到Event Loop全面梳理](https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-11)\n\n"},{"title":"JS的解释器过程","url":"/Roundtables/Question-Bank/execution/interpreter.html","content":"---\ntitle: JS的解释器过程\ntags: [编译器, 解释器, AST, 抽象语法树]\ncategories: execution\n---\n\n# JS的解释器过程\n\n## 编译器与解释器\n\n### 能够将代码转化成AST的工具叫做「编译器」\n\n简单来说，当一段代码经过编译器的词法分析、语法分析等阶段之后，会生成一个树状结构的“抽象语法树（AST）”，该语法树的每一个节点都对应着代码当中不同含义的片段。\n\n比如将如下代码转换成AST：\n```js\nconst a = 1\nconsole.log(a)\n```\n::: details 对应AST结构\n```json\n{\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 26,\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"start\": 0,\n      \"end\": 11,\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"start\": 6,\n          \"end\": 11,\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"start\": 6,\n            \"end\": 7,\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"start\": 10,\n            \"end\": 11,\n            \"value\": 1,\n            \"raw\": \"1\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    },\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 12,\n      \"end\": 26,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 12,\n        \"end\": 26,\n        \"callee\": {\n          \"type\": \"MemberExpression\",\n          \"start\": 12,\n          \"end\": 23,\n          \"object\": {\n            \"type\": \"Identifier\",\n            \"start\": 12,\n            \"end\": 19,\n            \"name\": \"console\"\n          },\n          \"property\": {\n            \"type\": \"Identifier\",\n            \"start\": 20,\n            \"end\": 23,\n            \"name\": \"log\"\n          },\n          \"computed\": false\n        },\n        \"arguments\": [\n          {\n            \"type\": \"Identifier\",\n            \"start\": 24,\n            \"end\": 25,\n            \"name\": \"a\"\n          }\n        ]\n      }\n    }\n  ],\n  \"sourceType\": \"module\"\n}\n```\n:::\n\n- 常见的JS编译器有`babylon`，acorn等等，传送门网站自行体验[AST explorer](https://astexplorer.net/)。\n- 可以看到，**编译出来的AST详细记录了代码中所有语义代码的类型、起始位置等信息**。这段代码除了根节点Program外，主体包含了两个节点VariableDeclaration和ExpressionStatement，而这些节点里面又包含了不同的子节点。\n- 正是由于AST详细记录了代码的语义化信息，所以Babel，Webpack，Sass，Less等工具可以针对代码进行非常智能的处理。\n\n\n### 能够将AST翻译成目标语言并运行的工具叫做「解释器」\n\nJS 是解释性语言，所以它无需提前编译，而是由【解释器】实时运行的：\n1. 读取代码，进行**词法分析**（Lexical analysis），然后将代码分解成`词元`（token）；\n2. 对词元进行**语法分析**（parsing），然后将代码整理成`语法树`（syntax tree）；\n3. 使用**翻译器**（translator），将代码转为`字节码`（bytecode）；\n4. 使用**字节码解释器**（bytecode interpreter），将字节码转为`机器码`。最终计算机执行的就是机器码。\n\n- 现代浏览器为提高运行速度，一般采用`即时编译（实时解释）`，即字节码只在运行到那行时才编译那一行，并且将编译结果缓存。\n- 更先进的比如Chrome的`V8，省略了第三步翻译成字节码，直接转为机器码`，进一步提升了速度。\n- 也正是由于上述优化，当前的JS引擎，很难说是到底是一个编译器还是一个解释器。\n\n### 函数表达式与函数声明的区别\n- 函数声明会有`声明提升`，解析器会先读取函数声明，使其在代码真正执行前可用;\n- 函数表达式必须等到解析器执行到其所在行才会真正解析执行。\n\n### 实现一个js解释器\n\n[前端与编译原理——用JS写一个JS解释器](https://segmentfault.com/a/1190000017241258)\n"},{"title":"深入javascript运行机制--部分","url":"/Roundtables/Question-Bank/execution/深入javascript运行机制--部分.html","content":"# 深入javascript运行机制--部分\n\n## 执行上下文\n执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。\n### 执行上下文的类型\n执行上下文总共有三种类型\n\n- **全局执行上下文**：只有一个，浏览器中的全局对象就是 window 对象，`this` 指向这个全局对象。\n\n- **函数执行上下文**：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。\n\n- **Eval 函数执行上下文**： 指的是运行在 `eval` 函数中的代码，很少用而且不建议使用。\n### 执行上下文的创建\n执行上下文分两个阶段创建：**1）创建阶段；** **2）执行阶段**\n#### 创建阶段\n创建阶段包含两个组件：词法环境、变量环境\n```\nExecutionContext = {\n  LexicalEnvironment = <ref. to LexicalEnvironment in memory>, // 词法环境\n  VariableEnvironment = <ref. to VariableEnvironment in  memory>, // 变量环境\n}\n```\n##### \n##### 词法环境（Lexical Environment）\n词法环境有三个**组成部分**\n\n- 1、**环境记录**：包括**声明环境记录：**存储变量和函数声明的实际位置，**对象环境记录：**暂时理解为全局对象记录。\n\n- 2、**对外部环境的引用**：可以访问其外部词法环境。\n- 3、**this binding：**全局环境下指向全局对象，模块环境下指向模块对象，函数环境下取决于函数的执行方式（箭头函数除外，它取决与定义时所处的环境）。\n\n词法环境有三种**类型**\n\n- 1、**全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。\n\n- 2、**函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。\n- 3、**模块环境**：可以理解为一个小型全局环境，拥有一个模块对象（本模块）this指向该模块对象。\n##### 变量环境\n变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。\n在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者****仅用于存储**变量（ `var` ）**绑定。\n\n\n#### 执行阶段\n此阶段，完成对所有变量的分配，最后执行代码。\n\n\n\n#### 下面用一个例子分步解析JS执行上下文\n\n\n```javascript\nlet a = 20;  \nconst b = 30;  \nvar c;\nfunction multiply(e, f) {  \n  var g = 20;  \n  return e * f * g;  \n}\nc = multiply(20, 30);\n```\n创建阶段执行上下文如下伪代码所示：\n```javascript\nGlobalExectionContext = {\n  LexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Object\",\n      // Identifier bindings go here\n      a: < uninitialized >,\n      b: < uninitialized >,\n      multiply: < func >\n    }\n    outer: <null>,\n    ThisBinding: <Global Object>\n  },\n  VariableEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Object\",\n      // Identifier bindings go here\n      c: undefined,\n    }\n    outer: <null>,\n    ThisBinding: <Global Object>\n  }\n}\n```\n在执行阶段，变量分配完成：\n```javascript\nGlobalExectionContext = {\n\tLexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Object\",\n      // Identifier bindings go here\n      a: 20,\n      b: 30,\n      multiply: < func >\n    }\n    outer: <null>,\n    ThisBinding: <Global Object>\n  },\n\tVariableEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Object\",\n      // Identifier bindings go here\n      c: undefined,\n    }\n    outer: <null>,\n    ThisBinding: <Global Object>\n  }\n}\n```\n当遇到对函数 `multiply(20，30)` 的调用时，将创建一个新的函数执行上下文来执行函数代码。因此，在创建阶段，函数执行上下文将如下所示：\n```javascript\nFunctionExectionContext = {\n\tLexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Declarative\",\n      // Identifier bindings go here\n      Arguments: {0: 20, 1: 30, length: 2},\n    },\n    outer: <GlobalLexicalEnvironment>,\n    ThisBinding: <Global Object or undefined>,\n  },\n\tVariableEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Declarative\",\n      // Identifier bindings go here\n      g: undefined\n    },\n    outer: <GlobalLexicalEnvironment>,\n    ThisBinding: <Global Object or undefined>\n  }\n}\n```\n在此之后，执行上下文将经过执行阶段，这意味着对函数中变量的赋值已经完成。因此，在执行阶段，函数执行上下文将如下所示：\n```javascript\nFunctionExectionContext = {\n\tLexicalEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Declarative\",\n      // Identifier bindings go here\n      Arguments: {0: 20, 1: 30, length: 2},\n    },\n    outer: <GlobalLexicalEnvironment>,\n    ThisBinding: <Global Object or undefined>,\n  },\n\tVariableEnvironment: {\n    EnvironmentRecord: {\n      Type: \"Declarative\",\n      // Identifier bindings go here\n      g: 20\n    },\n    outer: <GlobalLexicalEnvironment>,\n    ThisBinding: <Global Object or undefined>\n  }\n}\n```\n函数完成后，返回的值存储在c中，因此全局词法环境将被更新。之后，全局代码完成，程序完成。\n#### 笔记\n\n1. 正如您可能注意到的，`let`和`const`定义的变量在创建阶段没有任何关联的值，但是`var`定义的变量被设置为`undefined`。这是因为，在创建阶段，会扫描代码以查找变量和函数声明，而函数声明则整体存储在环境中，变量最初设置为未定义（对于`var`）或保持未初始化（对于`let`和`const`）。这就是为什么可以在声明变量之前访问变量定义的变量（尽管未定义），但是在声明变量之前访问`let`和`const`变量时会得到引用错误。这就是我们所说的提升。\n1. 如果 `Javascript` 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值。\n\n\n\n#### \n\n## 内存\nJS内存空间分为**栈(stack)**、**堆(heap)**、**池(一般也会归类为栈中)**。 其中**栈**存放变量，**堆**存放复杂对象，**池**存放常量，所以也叫常量池。\n⚠️注意：闭包中的变量并不保存中栈内存中，而是保存在`堆内存`中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。\n### 内存回收\nJavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。\n\n- 局部变量和全局变量的销毁\n  - **局部变量**：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。\n  - **全局变量**：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量**避免**使用全局变量。\n- 以Google的V8引擎为例，V8引擎中所有的JS对象都是通过**堆**来进行内存分配的\n  - **初始分配**：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。\n  - **继续申请**：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。\n- V8引擎对堆内存中的JS对象进行**分代管理**\n  - **新生代**：存活周期较短的JS对象，如临时变量、字符串等。\n  - **老生代**：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。\n#### 回收算法：引用计数、标记清除\n##### 标记清除（常用）\n标记清除算法将“不再使用的对象”定义为“**无法到达的对象**”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，**保留**。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收。\n### 内存泄漏\n##### 1、浏览器方法\n\n1. 打开开发者工具，选择 Memory\n1. 在右侧的Select profiling type字段里面勾选 timeline\n1. 点击左上角的录制按钮。\n1. 在页面上进行各种操作，模拟用户的使用情况。\n1. 一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。\n##### 2、命令行方法\n使用 `Node` 提供的 `process.memoryUsage` 方法。\n\n```javascript\nconsole.log(process.memoryUsage());\n// 输出\n{ \n  rss: 27709440,  // resident set size，所有内存占用，包括指令区和堆栈\n  heapTotal: 5685248,   // \"堆\"占用的内存，包括用到的和没用到的\n  heapUsed: 3449392,\t// 用到的堆的部分\n  external: 8772  \t// V8 引擎内部的 C++ 对象占用的内存\n}\n```\n判断内存泄漏，以`heapUsed`字段为准。\n### 相关问题\n#### 1. 从内存来看 null 和 undefined 本质的区别是什么？\n#### 2. ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？\n```javascript\nconst foo = {}; \nfoo = {}; // TypeError: \"foo\" is read-only\nfoo.prop = 123;\nfoo.prop // 123\n```\n#### 3. 哪些情况下容易产生内存泄漏？\n\n1. 滥用全局变量\n1. 滥用闭包\n1. eval作用域\n1. 变量引用了dom，但是dom后来从dom树移除了，该变量忘了解除引用\n#### 4. 下面代码的执行结果是什么？为什么？\n```javascript\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\n```\n```javascript\n// 运行结果：\na.x \t// --> undefined\nb.x \t// --> {n: 2}\n```\n\n- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。\n- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`\n## 参考链接\n[https://github.com/yygmind/blog/issues/12](https://github.com/yygmind/blog/issues/12)\n[https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)\n"},{"title":"git基础","url":"/Roundtables/Question-Bank/git/base.html","content":"# git基础\n\n## git分区\n\n![三大分区](./images/git-area.png)\n\n\n## git基本操作\n\n### git fetch 和git pull 的差别\n\n`git pull = git fetch + git merge`\n\n#### git fetch\n`git fetch`相当于是从远程获取最新到本地，不会自动merge，如下指令：\n```\ngit fetch orgin master //将远程仓库的master分支下载到本地当前branch中\ngit log -p master  ..origin/master //比较本地的master分支和origin/master分支的差别\ngit merge origin/master //进行合并\n```\n也可以用以下指令：\n```\ngit fetch origin master:tmp //从远程仓库master分支获取最新，在本地建立tmp分支  例如git fetch origin esop/withdraw:esop/withdraw-zyc\ngit diff tmp //將當前分支和tmp進行對比\ngit merge tmp //合并tmp分支到当前分支\n```\n\n#### git pull\n`git pull` 相当于是从远程获取最新版本并merge到本地。\n```\ngit pull origin master\n```\n在实际使用中，git fetch更安全一些\n\n传送门：[详解git pull和git fetch的区别](https://blog.csdn.net/weixin_41975655/article/details/82887273)\n\n\n\n"},{"title":"git bisect","url":"/Roundtables/Question-Bank/git/git-bisect.html","content":"# git bisect\ngit bisect：二分查找错误commit的命令。\n```\n$ git log --pretty=oneline // 共 101次提交，最早一次是4d83cf\n$ git bisect start HEAD 4d83cf // $ git bisect start [终点] [起点],确定查找范围，启动查错，则会选择中间的第51次提交\n$ git bisect good //第51次提交，刷新浏览器后表现正常，标记为正确，git会总动修改查错范围为51到head(101次)，选择中间的第76次提交查错\n$ git bisect bad // 第76次提交,刷新浏览器后表现出错，标记为错误，git会总动修改查错范围为51到76次，重复以上过程，直到找到出问题的那次提交为止\nb47892 is the first bad commit\n$ git bisect reset // 退出查错，回到最近一次的代码提交\n```\n\n传送门：[阮大教程 git bisect](http://www.ruanyifeng.com/blog/2018/12/git-bisect.html)\n"},{"title":"git stash用法","url":"/Roundtables/Question-Bank/git/git-stash.html","content":"# git stash用法\n\n## 1、保存在本地\ngit stash会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。\n比如下面的中间状态，通过git stash命令推送一个新的储藏，当前的工作目录就干净了。\n```s\n$ git status\nOn branch master\nChanges to be committed:\n\nnew file:   style.css\n\nChanges not staged for commit:\n\nmodified:   index.html\n\n$ git stash\nSaved working directory and index state WIP on master: 5002d47 our new homepage\nHEAD is now at 5002d47 our new homepage\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n需要说明一点，**stash是本地的，不会通过git push命令上传到git server上**。\n\n实际应用中推荐给每个stash加一个message，用于记录版本，使用git stash save取代git stash命令。示例如下：\n```s\n$ git stash save \"test-cmd-stash\"\nSaved working directory and index state On autoswitch: test-cmd-stash\nHEAD 现在位于 296e8d4 remove unnecessary postion reset in onResume function\n$ git stash list\nstash@{0}: On autoswitch: test-cmd-stash\n```\n\n## 2、重新应用缓存的stash\n可以通过git stash pop命令恢复之前缓存的工作目录，输出如下：\n```s\n$ git status\nOn branch master\nnothing to commit, working tree clean\n$ git stash pop\nOn branch master\nChanges to be committed:\n\n    new file:   style.css\n\nChanges not staged for commit:\n\n    modified:   index.html\n\nDropped refs/stash@{0} (32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a)\n```\n这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。\n\n你也可以使用git stash apply命令，将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝。命令输出如下：\n```s\n$ git stash apply\nOn branch master\nChanges to be committed:\n\n    new file:   style.css\n\nChanges not staged for commit:\n\n    modified:   index.html\n```\n\n## 3、查看现有stash\n可以使用git stash list命令，一个典型的输出如下：\n```s\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n```\n在使用git stash apply命令时可以通过名字指定使用哪个stash，默认使用最近的stash（即stash@{0}）。\n\n## 4、移除stash\n可以使用git stash drop命令，后面可以跟着stash名字。下面是一个示例：\n```s\n$ git stash list\nstash@{0}: WIP on master: 049d078 added the index file\nstash@{1}: WIP on master: c264051 Revert \"added file_size\"\nstash@{2}: WIP on master: 21d80a5 added number to log\n$ git stash drop stash@{0}\nDropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)\n```\n或者使用git stash clear命令，删除所有缓存的stash。\n\n\n## 5、查看指定stash的diff\n可以使用git stash show命令，后面可以跟着stash名字。示例如下：\n```s\n$ git stash show\n index.html | 1 +\n style.css | 3 +++\n 2 files changed, 4 insertions(+)\n```\n在该命令后面添加-p或--patch可以查看特定stash的全部diff，如下：\n```s\n$ git stash show -p\ndiff --git a/style.css b/style.css\nnew file mode 100644\nindex 0000000..d92368b\n--- /dev/null\n+++ b/style.css\n@@ -0,0 +1,3 @@\n+* {\n+  text-decoration: blink;\n+}\ndiff --git a/index.html b/index.html\nindex 9daeafb..ebdcbd2 100644\n--- a/index.html\n+++ b/index.html\n@@ -1 +1,2 @@\n+<link rel=\"stylesheet\" href=\"style.css\"/>\n```\n\n## 6、从stash创建分支\n如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。\n```\n$ git stash branch testchanges\nSwitched to a new branch \"testchanges\"\n# On branch testchanges\n# Changes to be committed:\n#   (use \"git reset HEAD <file>...\" to unstage)\n#\n#      modified:   index.html\n#\n# Changes not staged for commit:\n#   (use \"git add <file>...\" to update what will be committed)\n#\n#      modified:   lib/simplegit.rb\n#\nDropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)\n```\n这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。\n\n\n## 7、暂存未跟踪或忽略的文件\n默认情况下，git stash会缓存下列文件：\n- 添加到暂存区的修改（staged changes）\n- Git跟踪的但并未添加到暂存区的修改（unstaged changes）\n但不会缓存一下文件：\n- 在工作目录中新的文件（untracked files）\n- 被忽略的文件（ignored files）\n\ngit stash命令提供了参数用于缓存上面两种类型的文件。使用-u或者--include-untracked可以stash untracked文件。使用-a或者--all命令可以stash当前目录下的所有修改。\n\n至于git stash的其他命令建议参考Git manual。\n"},{"title":"Node模块机制的实现","url":"/Roundtables/Question-Bank/nodejs/Node模块机制的实现.html","content":"# Node模块机制的实现\n\n## CommonJS规范\n_希望js能运行在任何地方是commonJS规范制定的初衷。_\nCommonJS对模块的定义非常简单，包括：**模块引用、模块定义、模块标识**；\n```javascript\nconst 模块引用 = require('模块标识')\n/** 模块定义 */\nexports.add = (...args) => {\n\t// ...\n}\n```\n符合规范的**模块标识**应该是小驼峰命名的字符串（如：my-module），或者路径。\n## Node模块的实现\n前面了解了**CommonJS**规范，现在再来Node对该规范的实现。\n`node`在实现该规范时做了一些取舍，同时也增加了部分自身需要的特性。我们知道规范的模块中有`exports`、`require`、`module`看起来十分简单，但我们需要了解**node**在实现它们的时候经历了什么：\n### Node如何加载模块？\n在Node中引入模块需要经历三个步骤：路径分析、文件定位、编译执行。\n#### 模块的分类\n模块分为：核心模块（Node自带的）、文件模块（用户写的）\n核心模块：在node源代码编译过程中编译成二进制，node进程启动时直接装载在内存中执行，为何快？\n文件模块：属于动态加载，需要完成上述三个步骤才能完成加载。因此相对较慢。\n#### 缓存优先\n当然了Node与浏览器类似，为了减少二次引入的开销，对引入过的模块都会进行缓存。不同的是，浏览器只缓存文件，Node缓存的是编译和执行后的对象。\n#### 路径分析\n\n\n- 模块标识符分析\n\n模块标识符存在多种形式，对于不同形式查找和定位是有差异的。\n先了解一下模块标识符的分类：核心模块、相对路径的文件模块、绝对路径文件模块、非路径形式的文件模块（这里主要指包）。\n\n- 提前看一下模块加载的优先级吧\n\n缓存 > 核心模块 > 路径形式的文件模块（以 `.` 、`..`和`/`开头的标识符）> 自定义模块（非路径形式文件模块）。\n为何会存在这样的优先级呢，前面两个毋庸置疑，自定义模块最慢是为什么呢？\n\n- 先了解一下自定义模块的路径查找策略：\n\n`module.paths`属性可以追踪模块的查找过程：首先在当前目录下的`node_modules`下查找，然后父目录...直到根目录，因此对于自定义模块路径越深查找越慢。\n#### 文件定位\n在文件定位的过程中包括：文件扩展名分析、目录和包的处理。\n\n- 文件扩展名分析\n\n由于标识符可以不带扩展名，此时`Node`会按照`.js`、`.json`、`.node` 逐个尝试。在尝试的过程中，需要调用fs模块的同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里会引起性能问题。小诀窍1：如果是.json、.node 请带上扩展名。小诀窍2：同步配合缓存，可以大幅缓解Node单线程中阻塞式调用的缺陷。\n\n- 目录分析和包\n\n文件扩展名分析后如果没有找到相应文件，却得到一个目录，此时会将此目录当作包处理：首先查找**package.json**（**CommonJS**包规范定义的包描述文件），并通过`JSON.parse()`解析，取出`main`属性指定的文件名进行定位。当`main`指定的文件名错误，或者根本不存在**package.json**，**Node**会将`index`作为默认文件名然后查找**index.js 、index.json、index.node**。\n当模块路径数组遍历完毕后依然没找到，则会抛出查找失败的异常。\n#### 模块编译\n当定位到具体文件后，Node会创建一个模块对象，然后根据路径载入并编译。\n对于不同文件扩展名，加载方式一不一样：\n\n- .js 文件：通过fs模块同步读取后编译执行；\n- .node文件：这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。\n- ,json 文件：fs同步读取，JSON.parse()解析返回；\n- 其余扩展名：都会被当作 .js 处理。\n\n每编译成功一个模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入性能。\n根据不同文件扩展名，Node会调用不同的读取方式，如.json文件的调用如下：\n\n```javascript\n// Native extensions for .json\nModule._extensions['json'] = function(module, filename) {\n\tvar content = NativeModule.require('fs').readFileSync(filename, 'utf8');\n  try {\n  \tmodule.exports = JSON.parse(content);\n  } catch (err) {\n  \terr.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n```\n其中，Module._extensions会赋值给require的extensions属性，不妨尝试：`console.log(require.extensions);`\n也可以像上面的方式自定义扩展加载方式，v0.10.6后官方不鼓励这么做，而是期望先将其他语言转换为js文件后再加载，这样就避免了将繁琐的编译加载等过程引入到Node的执行过程中。\n##### 1. Javascript模块编译\n回到**CommonJS**规范，我们知道每个文件都存在 `require`、`exports`、`module`三个变量，它们从何而来？Node每个模块中还有`__filename`、`__dirname`，它们又从何而来。\n事实上在编译过程中，**Node**会对获取的**Javascript**文件内容进行头尾包装，如下：\n\n```javascript\n(function (exports, require, mudule, __filename, __dirname) {\n\tvar math = require('math');\n  exports.area = function (radius) {\n  \treturn Math.PI * Math.pow(radius, 2);\n  }\n})\n```\n这样就保证了模块文件之间作用域隔离。包装后的代码通过vm原生模块的`runInThisContext()`方法执行（类似`eval`，只是具有明确的上下文，不污染全局），返回一个具体的**function**对象。\n以上，`require`、`exports`、`module`的流程已经完整，这就是**Node**对**CommonJS**模块规范的实现。\n##### 2. C/C++模块编译\n调用process.dlopen()方法加载执行。在Node的架构中，dlopen()方法在Windows和*nix平台分别有不同的实现，通过libuv兼容层进行封装。\n实际上.node模块不需要编译，只需要加载和执行，执行过程中exports对象与.node模块产生联系。\n### 核心模块\n核心模块分为两类：C/C++写的，JavaScript写的。其中C/C++放在src目录下，JavaScript放在lib目录下。\n#### JavaScript核心模块编译过程\n\n1. 转存为C/C++代码，代码字符串放到c++数组中，Node进程启动时直接加载到内存中。\n1. 编译JavaScript核心模块：\n\n与文件模块的区别在于：获取源代码的方式以及缓存执行保存结果的位置。\nJavascript核心模块源代码通过process.binding('natives')取出，编译成功后存放到NativeModule._cache对象上，文件模块则放在Module._cache对象上：\n\n```javascript\nfunction NativeModule (id) {\n\tthis.filename = id + '.js';\n  this.id = id;\n  this.exports = {};\n  this.loaded = false;\n}\nNativeModule._source = process.binding('natives'); // 源代码缓存\nNativeModule._cache = {}; // 编译结果缓存\n```\n#### C/C++核心模块的编译过程\n以后再说\n#### 核心模块的引入流程\n下面时 os 模块的引入流程：\n![](https://cdn.nlark.com/yuque/__puml/a79ab39945bc20ec6e695f0038eb6f0f.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbjpOT0RFX01PRFVMRShub2RlX29zLCByZWdfZnVuYyk7XG46Z2V0X2J1aWx0aW5fbW9kdWxlKCdub2RlX29zJyk7XG46cHJvY2Vzcy5iaW5kaW5nKCdvcycpO1xuOk5hdGl2ZU1vZHVsZS5yZXF1aXJlKCdvcycpO1xuOnJlcXVpcmUoJ29zJyk7XG5cbkBlbmR1bWwiLCJ0eXBlIjoicHVtbCIsImlkIjoiQllZaksiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sL2E3OWFiMzk5NDViYzIwZWM2ZTY5NWYwMDM4ZWI2ZjBmLnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=)### C/C++扩展模块\n\n![](https://cdn.nlark.com/yuque/__puml/57959b4e059dad9fc89f3ffd191838b7.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbnwgKm5peHxcbjpDL0MrK-a6kOeggTtcbmlmICggKm5peClcblx0fCAqbml4fFxuXHQ6ZysrL2djYztcblx0LT4g57yW6K-R5rqQ56CBO1xuXHQ6LnNv5paH5Lu2O1xuXHQtPiDnlJ_miJAubm9kZeaWh-S7tjtcblx0OuWKoOi9vS5zb-aWh-S7tjtcblx0LT4gZGxvcGVuKCnliqDovb07XG5lbHNlXG5cdHwjQW50aXF1ZVdoaXRlfHdpbmRvd3N8XG5cdDpWQysrO1xuXHQtPiDnvJbor5HmupDnoIE7XG5cdDouZGxs5paH5Lu2O1xuXHQtPiDnlJ_miJAubm9kZeaWh-S7tjtcblx0OuWKoOi9vS5kbGzmlofku7Y7XG5cdC0-IGRsb3Blbigp5Yqg6L29O1xuZW5kaWZcbnwgKm5peHxcbjrlr7zlh7rnu5lKYXZhc2NyaXB0O1xuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJpZCI6ImtuRVA1IiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC81Nzk1OWI0ZTA1OWRhZDlmYzg5ZjNmZmQxOTE4MzhiNy5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9)扩展模块不同平台的编译和加载过程\n关于如何编写扩展模块，以及更多的相关信息，暂不深入了解。\n## 包与NPM\n包是在模块的基础上进一步组织代码。\n### 包结构\n包是一个存档文件，.zip或.tar.gz格式，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下文件：\n\n- package.json：包描述\n- bin: 存放可执行二进制文件的目录\n- lib：存放JavaScript代码\n- doc：文档\n- test：单元测试\n### 包描述文件\n可以查看npm官方文档：[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)\n### 包安装\n#### 全局安装\n全局安装并不代表将包安装为一个全局包，并不意味可以在任意地方引入。实际上 -g 是将一个包安装为全局可用的执行命令。它根据package.json的bin属性配置，将实际脚本链接到与Node可执行文件相同的路径下：\n\n```json\n{\n\t\"bin\": {\n  \t\"express\": \"./bin/exporess\"\n  }\n}\n```\n事实上通过全局安装的包都被统一放到了一个目录下，如何知道这个目录呢？\n\n```javascript\npath.resolve(process.execPath, '..', '..', 'lib', 'node_modules');\n```\n通过上面的代码即可推算出。如果Node的可执行文件在`/usr/local/bin/node`，那么模块目录就是`/usr/local/lib/node_modules`。最后，通过软链接的方式将`bin`属性配置的可执行文件链接到**Node**的可执行目录下。\n#### 本地安装\n本地安装只需要告诉**NPM**包描述文件**package.json**文件在哪就行。具体如下：\n\n```shell\nnpm install <tarball file>\nnpm install <tarball url>\nnpm install <folder>\n```\n#### 其他源安装\n\n```shell\nnpm install react --registry=http://xxx.com\n# 改变默认源\nnpm config set registry http://xxx.com\n```\n### NPM钩子命令\npackage.json中的scripts字段就是让包在安装或者卸载等过程中提供钩子机制，例如\n\n```json\n{\n\t\"scripts\": {\n  \t\"preinstall\": \"preinstall.js\",\n    \"install\": \"install.js\",\n    \"uninstall\": \"uninstall.js\",\n    \"test\": \"test.js\"\n  }\n}\n```\n当我们执行`npm install <package>`时，`preinstall`指向的脚本将会被加载执行，接着执行`install`。`npm uninstall <package>`时，`uninstall`字段指向的脚本可以执行一些清理操作。\n### 发布包\n流程：编写模块 -> 初始化package.json -> 注册npm仓库账号（如果没有的话） -> 上传包。\n一个优秀的包应该：\n\n- 具备良好的测试\n- 具备良好的文档\n- 具备良好的测试覆盖率\n- 具备良好的编码规范\n- 更多条件\n#### 注册仓库账号\n可以取npm官网注册，也可以通过命令行注册\n\n```shell\nnpm adduser\n# 而后按照指引填写即可\n```\n#### 上传包\n\n```shell\nnpm publish <folder>\n```\n#### 包权限管理\n通常一个包只有一个人可以发布。如果需要多人发布，可以使用：\n\n```shell\nnpm owner ls <package name>\nnpm owner add <user> <package name>\nnpm owner rm <user> <package name>\n```\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/263240/1584441084190-4023bcec-dd64-4765-b4f9-48c1465b33ae.png#align=left&display=inline&height=38&name=image.png&originHeight=76&originWidth=384&size=7514&status=done&style=none&width=192)\n#### 分析包\n通过`npm ls` 可以查看当前目录下能否顺利引入想引入的包。这个命令可以分析出当前路径下能通过模块路径找到的所有包，并生成依赖树：\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/263240/1584441385320-e2a5d15d-70ab-4b4d-8c4f-3bad79497c7b.png#align=left&display=inline&height=44&name=image.png&originHeight=87&originWidth=291&size=5408&status=done&style=none&width=145.5)\n### 局域网NPM\n如何搭载且看：稍后更新。。。\n## 前后端共用模块\n前端模块化主要有AMD、CMD、ES6+。相关知识不赘述了。\n如何兼容多种规范，且看：\n\n```javascript\n(function (name, definition) {\n\t// 检查上下文是否为AMD或CMD\n  var hasDefine = typeof define === 'function',\n      // Node？\n      hasExports = typeof module !== 'undefined' && module.exports;\n  if (hasDefine) {\n  \tdefine(definition);\n  } else if (hasExports) {\n    module.exports = definition();\n  } else {\n  \t// 挂到window上\n    this[name] = definition();\n  }\n})('hello', function () {\n\tvar hello = function () {};\n  return hello;\n});\n```\n\n## 相关疑问\n\n- 包描述文件中**dependencies**和**devDependencies**的区别是什么？\n\n**dependencies：**使用当前包所需要依赖的包列表，npm会通过这个属性帮助自动加载依赖包。\n**devDependencies：**一些模块只在开发时需要依赖。配置这个属性可以提示包的后续开发者安装这些依赖。\n所以对于包的使用者而言**devDependencies**列表的依赖是不需要加载的，如果这些也放在**dependencies**里边那么，使用者就会自动安装这些不想关的包。\n\n- 如何编写好`package.json` ？\n\n可以参考一下之名项目，例如：express：[https://github.com/expressjs/express/blob/master/package.json](https://github.com/expressjs/express/blob/master/package.json)\n\n- \n\n"},{"title":"EventEmitter实现","url":"/Roundtables/Question-Bank/nodejs/eventEmitter.html","content":"\n## EventEmitter实现\n\n> 如何实现Event(Bus),这个东西太重要了,几乎所有的模块通信都是基于类似的模式,包括安卓开发中的Event Bus, Node.js中的Event模块(Node中几乎所有的模块都依赖于Event,包括不限于http、stream、buffer、fs等)。\n\n> 我们仿照Node中Event API实现一个简单的Event库,他是发布订阅模式的典型应用.\n\n### 简单版\n\n主要方法有on, emit, once, off。\n- emit(eventName,...arg)方法传入的参数，第一个为事件名，其他参数事件对应的执行函数中的实参，emit方法的功能就是从事件对象中，寻找对应key为eventName的属性，执行该属性所对应的数组里面每一个执行函数。\n- on是node中addListener的别名；\n- off是node中removeListener的别名；\n- on的方法对于某一指定事件添加的监听器可以持续不断的监听相应的事件，而once方法添加的监听器，监听一次后，就会被消除；\n- removeListener指的是移除一个指定事件的某一个监听器，而removeAllListeners指的是移除某一个指定事件的全部监听器；\n- cb也可以叫做监听者函数listener。\n\n```js\nclass EventEmitter {\n    constructor() {\n        this._eventBus = {} // 或 Object.create(null)\n    }\n    on(type, cb) {\n        if (!this._eventBus[type]) {\n            this._eventBus[type] = []\n        }\n        this._eventBus[type].push(cb)\n        // 缺点：这里为了绑定多个监听者，直接使用了数组，没有分情况\n    }\n    emit(type, ...args) {\n        if (this._eventBus[type]) {\n            this._eventBus[type].forEach(cb => cb(...args))\n            // 缺点：这里监听函数cb的触发执行，this指向没有变更\n        }\n    }\n    off(type, cb) {\n        if (this._eventBus[type]) {\n            let position\n            position = this._eventBus[type].findIndex(_cb => _cb === cb)\n\n            if (position > -1) {\n                this._eventBus[type].splice(position, 1)\n            }\n        }\n    }\n    once(type, cb) {\n        this.on(type, (...args) => {\n            cb(...args)\n            this.off(type)\n        })\n    }\n}\n```\n\n```js\nlet event = new EventEmitter()\n\nevent.on('say', function(str) {\n   console.log(str)\n})\n\nevent.emit('say','hello Jony yu')\n//输出hello Jony yu\n```\n\n### 优化版\n\n- 改进1：在仅有1个监听者时，handler（this._eventBus[type]）应该只是一个函数，多个监听者才以数组存储。\n\n- 改进2：触发监听函数我们可以用 apply 与 call 两种方法, 在少数参数时call的性能更好,多个参数时apply性能更好, 当年Node的Event模块就在三个参数以下用call否则用apply。而我们这里为了简便，对于多个监听者使用apply，只有一个监听者时使用call即可。\n\n```js\nclass EventEmitter {\n    constructor() {\n        this._eventBus = {} // 或 Object.create(null)\n    }\n    on(type, cb) {\n        let handler = this._eventBus[type]\n        if (!handler) {\n            this._eventBus[type] = cb\n        } else if (handler && typeof handler === 'function') {\n            // 如果handler是函数说明只有一个监听者\n            this._eventBus[type] = [handler, cb]\n        } else {\n            // 已经有多个监听者,那么直接往数组里push函数即可\n            this._eventBus[type].push(cb)\n        }\n    }\n    emit(type, ...args) {\n        let handler = this._eventBus[type]\n        if (handler && Array.isArray(handler)) {\n            // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n             this._eventBus[type].forEach(cb => {\n                 args.length > 0 ? cb.apply(this, args) : cb.call(this)\n             })\n        } else {\n            // 单个函数直接触发\n            args.length > 0 ? cb.apply(this, args) : cb.call(this)\n        }\n\n        return true\n    }\n    off(type, cb) {\n        let handler = this._eventBus[type]\n        if (handler && typeof handler === 'function') {\n            // 如果是函数,说明只有一个监听者\n            delete this._eventBus[type]\n        } else {\n            // 如果handler是数组,说明被监听多次要找到对应的函数\n            let position\n            position = handler.findIndex(_cb => _cb === cb)\n\n            if (position > -1) {\n                handler.splice(position, 1)\n                // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n                if (handler.length === 1) {\n                    this._events[type] = handler[0];\n                }\n            }\n        }\n    }\n    once(type, cb) {\n        this.on(type, (...args) => {\n            args.length > 0 ? cb.apply(this, args) : cb.call(this)\n            this.off(type)\n        })\n    }\n}\n```\n\n### 进阶版\n\n- 改进1：选择 ***Map*** 作为储存事件的结构, 作为键值对的储存方式Map比一般对象更加适合, 操作起来也更加简洁。\n- 改进2：Node全面拥抱 ES6+ 之后,相应的 call/apply 操作用 ***Reflect*** 新关键字重写了。\n\n```js\nclass EventEmitter {\n    constructor() {\n        this._eventBus = this._eventBus || new Map(); // 储存事件/回调键值对\n    }\n    on(type, cb) {\n        let handler = this._eventBus.get(type)\n        if (!handler) {\n            this._eventBus.set(type, cb)\n        } else if (handler && typeof handler === 'function') {\n            // 如果handler是函数说明只有一个监听者\n            this._eventBus.set(type, [handler, cb])\n        } else {\n            // 已经有多个监听者,那么直接往数组里push函数即可\n            handler.push(cb)\n        }\n    }\n    emit(type, ...args) {\n        let handler = this._eventBus.get(type)\n        if (handler && Array.isArray(handler)) {\n            // 如果是一个数组说明有多个监听者,需要依次此触发里面的函数\n            for(var i=0; i < handler.length; i++) {\n                Reflect.apply(handler[i], this, args)\n            }\n        } else {\n            // 单个函数直接触发\n            Reflect.apply(handler, this, args)\n        }\n\n        return true\n    }\n    off(type, cb) {\n        let handler = this._eventBus.get(type)\n        if (handler && typeof handler === 'function') {\n            // 如果是函数,说明只有一个监听者\n            this._eventBus.delete(type)\n        } else {\n            // 如果handler是数组,说明被监听多次要找到对应的函数\n            let position\n            position = handler.findIndex(_cb => _cb === cb)\n\n            if (position > -1) {\n                handler.splice(position, 1)\n                // 如果清除后只有一个函数,那么取消数组,以函数形式保存\n                if (handler.length === 1) {\n                    this._events.set(type, handler[0]);\n                }\n            }\n        }\n    }\n    once(type, cb) {\n        let handler = this._eventBus.get(type)\n        this.on(type, (...args) => {\n            Reflect.apply(handler, this, args)\n            this.off(type)\n        })\n    }\n}\n```\n\n### 扩展\n\n> node的EventEmitter还包含了很多常用的API\n\n方法名 | 方法描述\n-|-\naddListener(event, listener) | 为指定事件添加一个监听器到监听器数组的尾部。\nprependListener(event,listener) | 与addListener相对，为指定事件添加一个监听器到监听器数组的头部。\non(event, listener) | 其实就是addListener的别名\nonce(event, listener) | 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。\nremoveListener(event, listener) | 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器\noff(event, listener) | removeListener的别名\nremoveAllListeners([event]) | 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。\nsetMaxListeners(n) | 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。\nlisteners(event) | 返回指定事件的监听器数组。\nemit(event, [arg1], [arg2], [...]) | 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。\n\n除此之外，还有2个特殊的，不需要手动添加，node的EventEmitter模块自带的特殊事件：\n\n事件名 | 事件描述\n-|-\nnewListener | 该事件在添加新事件监听器的时候触发\nremoveListener | 从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引\n\n\n### 相关链接\n[循序渐进教你实现一个完整的node的EventEmitter模块](https://github.com/forthealllight/blog/issues/21)\n\n[如何实现一个Event](https://www.cxymsg.com/guide/event.html#%E5%89%8D%E8%A8%80)\n\n[EventEmitter的实现](https://segmentfault.com/a/1190000014206309)\n"},{"title":"类的声明与实例","url":"/Roundtables/Question-Bank/object-oriented/class-declaration.html","content":"---\ntitle: 类的声明与实例\ntags: [类, 实例]\ncategories: class\n---\n\n# 类的声明与实例\n\n## 类的声明方式\n\n### ES5方式，构造函数式\n```js\nfunction M() {\n    this.name = 'name'\n}\n```\n\n### ES6方式，class类\n```js\nclass M2 {\n    constructor() {\n        this.name = 'name';\n    }\n}\n```\n\n### 实例化\n```js\nconsole.log(new M(), new M2)\n// 当不传参数时，()可以省略，无论是构造函数创建还是类创建\n```\n\n## 测试题\n> 要求使用ES5语法声明一个Stock类，符合以下定义：\n\n```js\nconst stock = new Stock('AAPL', '苹果公司');\n \nstock instanceof Stock; // true\nstock.constructor === Stock; // true\nstock.symbol; // 返回初始化时传入的股票代码\nstock.getMarket(); // 返回该股票所属市场code；假设已知美股(US)股票代码为2到8位字母，港股(HK)为5位数字，沪深(A)为6位数字\nstock.setPrice(192.80); // 设置股票最新价格\n```\n\n::: details 点击查看代码\n```js\nfunction Stock(symbol, name) {\n    this.symbol = symbol;\n    this.name = name;\n    this.price = undefined;\n    this.getMarket = function() {\n        var regUS = /^[a-zA-Z]{2,8}$/;\n        var regHK = /^\\d{5}$/;\n        var regA = /^[0-9]{6}$/;\n        if (regUS.test(this.symbol)) {\n            return '美股US'\n        } else if (regHK.test(this.symbol)) {\n            return '港股HK'\n        } else if (regA.test(this.symbol)) {\n            return '沪深A股'\n        } else {\n            return '未知'\n        }\n    }\n    this.setPrice = function(price) {\n        this.price = price;\n        console.log(this.price)\n    }\n}\n\nconst stock = new Stock('AAPL', '苹果公司');\n \nconsole.log(stock instanceof Stock);\nconsole.log(stock.__proto__.constructor === Stock);\nconsole.log(stock.constructor === Stock); // 原理同上，都是在原型链中找\nconsole.log(stock.symbol);\nconsole.log(stock.getMarket());\nconsole.log(stock.setPrice(192.80));\n```\n\n::: danger\n注意这里不能把getMarket与setPrice方法作为原型链上的方法，重新覆盖原型对象：\n```js\nStock.prototype = {\n    this.getMarket: function() {\n        var regUS = /^[a-zA-Z]{2,8}$/;\n        var regHK = /^\\d{5}$/;\n        var regA = /^[0-9]{6}$/;\n        if (regUS.test(this.symbol)) {\n            return '美股US'\n        } else if (regHK.test(this.symbol)) {\n            return '港股HK'\n        } else if (regA.test(this.symbol)) {\n            return '沪深A股'\n        } else {\n            return '未知'\n        }\n    },\n    this.setPrice: function(price) {\n        this.price = price;\n        console.log(this.price)\n    }\n}\n\n```\n覆盖后`stock.constructor === Stock`则不等，因为此时构造器就是Object\n:::\n"},{"title":"类与继承","url":"/Roundtables/Question-Bank/object-oriented/class-extends.html","content":"---\ntitle: 类与继承\ntags: [类, 继承, 原型链]\ncategories: class\n---\n\n# 类与继承\n\n> JS中继承的本质就是通过`原型链`\n## 继承的几种方式\n\n### 1、原型链实现 继承\n```js {9}\nfunction Parent() {\n    this.type = \"parent\";\n    this.habit = [1, 2, 3];\n}\n\nfunction Child() {\n}\n\nChild.prototype = new Parent();\n\nconst s1 = new Child();\nconsole.log(s1);\nconst s2 = new Child();\nconsole.log(s2);\n\n\ns1.habit.push(4);\nconsole.log(s1, s2);\n\ns1.type = \"child\";\nconsole.log(s1, s2);\n```\n\n#### 控制台输出结果\n![](./images/extends-1-01.png)\n\n#### 解释\n原型链中的原型对象Parent，对于多个实例如s1与s2来说是共有公用的。由于构造函数Child是空对象，所以实例s1与s2开始是没有实例属性的。\n1. 当给s1.habit增加一个4，由于habit是引用类型，实例中没有该属性，则会通过原型链添加到原型对象Parent中的habit上，而它是共有的，所以s1.habit访问时也会到达原型对象的habit（`s2.__proto__ === s1.__proto__`）；\n2. 当给s1.type赋值时，由于type是个原始类型属性，所以相当于是在实例s1中添加了实例属性type=\"child\"，而不会去改变原型对象，所以s1.type===\"child\"，而s2.type===\"parent\"；\n::: warning 结论\n综上，原型链继承的缺点是：**原型上任何类型的属性值都不会通过实例被重写，但是引用类型的属性值会受到实例的影响而修改**，所以引用类型的属性值可能被误操作而导致所有实例都改变。\n:::\n\n### 2、借用构造函数 继承\n\n```js {7}\nfunction Parent() {\n    this.type = \"parent\";\n    this.habit = [1, 2, 3]\n}\n\nfunction Child() {\n    Parent.call(this);\n    this.type = \"child\"; // 这里因为与Parent有同名属性type且后执行，会覆盖Parent.中的type\n    this.height = \"small\";\n}\n\nParent.prototype.say = function() {\n    console.log(\"Hello~\")\n}\n\nconst s1 = new Child; // 不传参数时可以省略()\nconst s2 = new Child;\nconsole.log(s1, s2);\n```\n\n#### 控制台输出结果\n![](./images/extends-2-01.png)\n\n#### 原理\n- 我们知道，函数只不过是一段可以在特定作用域执行代码的特殊对象，我们可以通过 call或apply 方法指定函数的作用域；\n- 借用构造函数继承，就是`在子类的构造函数中，通过 apply ( ) 或 call ( )的形式，调用父类构造函数，以实现继承`；\n- 子类构造函数创建的实例s，会调用父类构造函数`生成属性副本`，从而实现继承父类实例属性，且`多实例间互不影响`。但对于父类原型对象上的属性无法继承，是`部分继承`；\n\n::: warning 结论\n综上，借用构造函数继承的缺点是：**只实现了部分继承，父类的原型对象上的属性无法被子类继承**。\n:::\n\n### 3、组合继承（原型链+借用构造函数）\n\n组合继承：结合借用构造函数拷贝属性副本，与原型链继承共有属性（即`将需要复用的方法提出到父类的原型对象上去挂载`）相结合，从而更好实现继承。\n\n```js {7,10,14}\nfunction Parent() {\n    this.type = \"parent\";\n    this.habit = [1, 2, 3];\n}\n\n//将需共享的方法放到 Parent.prototype 中，实现复用\nParent.prototype.eat = function () { console.log('吃吃喝喝') }\n\nfunction Child() {\n    Parent.call(this);\n    this.type = \"child\"\n}\n\nChild.prototype = new Parent();\n\nconst s1 = new Child;\nconst s2 = new Child;\nconsole.log(s1, s2);\n```\n#### 控制台输出结果\n![](./images/extends-3-01.png)\n\n#### 组合继承优化\n\n需要优化的点有两个：\n1. 解决Parent执行两次的问题：`Parent.call(this)`与`new Parent()`执行了两次，是没有必要的。**继承的本质就是将父类的原型对象引用到子类的原型对象上**，因此可以简化构造函数执行过程，直接将父类原型对象赋值给子类原型对象即可：\n```js {7,10,14}\nfunction Parent() {\n    this.type = \"parent\";\n    this.habit = [1, 2, 3];\n}\n\n//将需共享的方法放到 Parent.prototype 中，实现复用\nParent.prototype.eat = function () { console.log('吃吃喝喝') }\n\nfunction Child() {\n    Parent.call(this);\n    this.type = \"child\"\n}\n\nChild.prototype = Parent.prototype; // 替换 new Parent();\n\nconst s = new Child;\ns.constructor === Parent // true，这里还有遗留问题\n```\n\n2. （**完美继承**）解决s.constructor指向问题：优化1中还有个问题没解决就是`实例对象s的构造函数依然是父类Parent`。可以通过引入一个中间对象，来隔离子类原型对象与父类原型对象，并手动改变子类原型的构造器为自己本身：\n```js {7,10,14-15}\nfunction Parent() {\n    this.type = \"parent\";\n    this.habit = [1, 2, 3];\n}\n\n//将需共享的方法放到 Parent.prototype 中，实现复用\nParent.prototype.eat = function () { console.log('吃吃喝喝') }\n\nfunction Child() {\n    Parent.call(this);\n    this.type = \"child\"\n}\n\nChild.prototype = Object.create(Parent.prototype); // 使用 Object.create(父类原型对象)创建一个以父类原型为原型对象的中间对象\nChild.prototype.constructor = Child; // 手动改变实例s的原型对象构造器指向\n\nconst s = new Child;\ns.constructor === Parent // false\ns.constructor === Child // true\n```\n\n"},{"title":"原型链与对象","url":"/Roundtables/Question-Bank/object-oriented/prototype-chain.html","content":"---\ntitle: 原型链与对象\ntags: [构造函数, 实例, 原型对象, js对象]\ncategories: prototype\n---\n\n# 原型链与对象\n\n## 创建对象的3种方法\n\n1. 字面量方式\n```js\nvar o1 = { name: 'o1' };\nvar o11 = new Object({ name: 'o11' });\n```\n\n2. 使用“构造函数”\n```js\nfunction M(name) {\n    this.name = name;\n}\n\nvar o2 = new M('o2')\n```\n\n3. 使用 Object.create\n```js\nvar p = { name: 'p' }\n\nvar o3 = Object.create(p);\n```\n\n控制台输出：\n\n![](./images/prototype-1-01.png)\n\n- o1、o11、o3都是 Object {}，o2是构造函数 M {}；\n- o3相比于o1和o11又特殊在：Object.create所创建的是一个空对象，传入的p是此空对象实例的原型对象，即o3.__proto__指向p; 所以o3本身是不具备name属性的，需要访问它对应的原型对象p上的name属性。\n\n## 构造函数、实例、原型对象 间的关系\n\n![关系图：构造函数、实例、原型对象](./images/prototype-2-01.png)\n\n::: warning\n**prototype（显式原型属性）**\n**\\_\\_proto\\_\\_（隐式原型属性）**\n:::\n\n\n\n#### 解释\n![](./images/prototype-2-02.png)\n\n- M是构造函数\n- o2是M的实例\n- M.prototype是M的原型对象\n- 原型对象中有个constructor属性指向M\n- 实例o2中有个__proto__属性指向原型对象M.prototype\n- 注意：`对象(不管是实例对象还是原型对象)都有__proto__属性，但只有构造函数才有prototype属性`。\n- 注意：`构造函数其实也是对象，所以构造函数也有__proto__属性`：\n    ```js\n        M.__proto__ === Function.prototype // true\n        // 构造函数M是Function这个构造函数的一个实例。\n    ```\n\n## 什么是原型链\n\n### 定义\n实例通过__proto__属性指向它对应的原型对象，此原型对象当中也有__proto__属性指向其对应的原型对象，这样一层层向上形成链式结构，直至`Object.prototype`原型对象便到达`原型链的顶端`。\n\n### 原型链的工作原理\n原型对象上的方法是被不同的实例所共有的，这就是原型链的作用。\n也就是说，当一个实例在访问一个属性的时候，先在自身找是否存在此属性，如果没有就向上一级查询自己的原型对象，如果没有就继续向上一级查询原型对象，直到找到此属性或者到达原型链的顶端，这就是`原型链的工作原理`。\n\n## new运算符工作原理\n\n### new的工作步骤\n- 步骤一：创建新实例对象o，关联构造函数M的原型对象；\n- 步骤二：执行构造函数M，并绑定M的作用域上下文到新实例对象o上；\n- 步骤三：判断步骤二中返回的res是否为(广义上)对象，如果是对象则抛弃o返回res；如果不是对象则返回o。\n\n### 代码模拟\n```js\nvar thisNew = function(M) {\n    // Object.create()返回空对象o，并关联M的原型对象\n    var o = Object.create(M.prototype);\n    // 执行构造函数M，并绑定作用域到o上\n    var res = M.call(o);\n    // 判断res是否是广义上的对象，是则返回res，否则返回o\n    if (typeof res === \"object\") {\n        return res;\n    } else {\n        return o;\n    }\n}\n```\n验证模拟的代码是否能完成new运算符的功能：\n\n ![验证模拟new操作符](./images/prototype-4-01.png)\n \n即使是再在M的原型对象上追加run方法，通过我们模拟的thisNew所创建的实例o也具备run方法。从而证明了new运算符背后的工作原理。\n\n\n\n"},{"title":"package.lock.json","url":"/Roundtables/Question-Bank/pkgmanage/package.lock.json.html","content":"## package.lock.json\n\n## 要点\n\n- 如果你使用的 npm 版本 为 ^5.x.x , package-lock.json 会默认自动生成\n- 你应该使用 package-lock 来确保一致的安装和兼容的依赖关系\n- 你应该将 package-lock 提交到源代码控制\n- 从npm ^ 5.1.x开始，package.json能够胜过 package-lock.json，所以你遇到较少让人头痛的问题\n- 不再删除 package-lock 只是需要运行npm install并重新生成它\n- ```package.json```只能锁定大版本，比如：```typescript: ^3.0``` 向上标号```^```是定义了向后（新）兼容依赖，如果当前有超过```3.0```的版本(在大版本```3.x```内)，比如```3.1```就会安装```3.1```。\n- ```package-lock.json```的作用就是用来保证我们的应用程序依赖之间的关系是一致的, 兼容的.\n- 能保证```npm install```时忽略```^```，除非手动修改```package.json```里面的版本号，或者通过```npm i webpack```或```npm i webpack@xx.xx.xx```更新依赖。这样```package.json```和```package.lock.json```都会更新。\n## 参考文章\n\n深入了解的话，强烈建议阅读：\n\n- [你想知道关于package-lock.json的一切，但是太害怕了问了？](https://segmentfault.com/a/1190000017239545)"},{"title":"无状态组件","url":"/Roundtables/Question-Bank/react/SFC.html","content":"# 无状态组件\n\n## 无状态 VS 有状态\n\n### 无状态组件\n无状态函数式组件（Stateless Functional Component, SFC），顾名思义，无状态，也就是你无法使用State、生命周期方法，这就决定了函数组件都是展示性组件，接收Props，渲染DOM，而不关注其他逻辑。\n- 写法上只需要return react元素即可，没有render()。\n- 使用上没有this，也没有ref。\n\n#### 不支持 `ref`\n无状态组件不支持 \"ref\"。原因很简单，因为在 React 调用到无状态组件的方法之前，是**没有一个实例化的过程的，因此也就没有所谓的 \"ref\"**。\n\n#### 声明方式\n```js\n// 注意，props需要传入。\nfunction SquareButton(props) {\n  return (\n    <button className=\"square\" onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n// 只需要return element即可，没有render()\n// 当然也可以直接通过箭头函数\n```\n### 无状态组件`调用方式差别`：组件式调用、函数式调用\n\n> 假定已知 Demo组件 为无状态组件。父组件调用方式如下：\n```js\n// 方式一：组件式调用\nrender() {\n    return <Demo someProps={123} />;\n}\n// 方式二：函数式调用\nrender() {\n    return Demo({someProps: 123});\n}\n```\n\n**差别**：\n1. 首先明确一点，因为无状态组件只是一个方法而没有生命周期和state，所以相比于有状态组件来说性能更高；\n2. 但如果以 `组件式调用` 无状态组件的话，性能的提高不明显可以忽略不计；这是因为以`组件式调用`，React会调用 createElement()生成这个无状态组件，还是会执行创建元素，挂载等等。\n3. 无状态组件真正的性能提升，是以 `函数式调用` 时，此时React会直接以一个function替代createElement()，也就不会执行创建元素和挂载，因此性能可大幅度提升！\n\n\n### 有状态组件\n\n在无状态组件的基础上，如果组件内部包含状态（state）且状态随着事件或者外部的消息而发生改变的时候，这就构成了有状态组件（Stateful Component）。\n\n有状态组件通常会带有生命周期（lifecycle），用以在不同的时刻触发状态的更新。\n\n## PureComponent VS Component\n\nReact15.3 中新加了一个 `PureComponent` 类，它是优化 React 应用程序最重要的方法之一。\n\n`PureComponent`的作用是**可以用来提升性能**，因为它减少了应用中的渲染次数。特别是在无状态的简单组件（纯展示组件）上的性能可以高出 React.Component 几十倍，所以性能还是很可观的。\n\nReact.`PureComponent` 与 React.Component 几乎完全相同，只是因为对 `shouldComponentUpdate()`的处理不同，使得React.`PureComponent`的性能更高。\n\n### PureComponent原理（shallowEqual）\n\n- 当定义了`shouldComponentUpdate()`时，React **会直接使用 `shouldComponentUpdate()` 的结果作为是否更新的依据**；\n- 当没有定义`shouldComponentUpdate()`时，React 就会去判断是不是 `PureComponent`，如果是 `PureComponent`，会使用 `shallowEqual`(浅比较) 来实现`「比较更新」`。当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的「生成」和「比对」过程，达到提升性能的目的。\n\n**注意有个关键问题**：React.PureComponent 做了如下判断：\n```js\nif (this._compositeType === CompositeTypes.PureClass) {\n  shouldUpdate = !shallowEqual(prevProps, nextProps)\n  || !shallowEqual(inst.state, nextState);\n}\n```\n这里的 shallowEqual 会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是`只比较了第一层的值`，确实很浅，所以`深层的嵌套数据是对比不出来的`。\n\n::: danger 注意\n**因此，虽然使用 PureComponent 可以少写 shouldComponentUpdate 函数，节省了点代码，但浅对比可能会在面对复杂数据结构时，没有办法正确判断深层的数据一致性，而导致界面得不到更新。**\n:::\n\n#### 参考链接\n\n[Reac系列之--无状态组件你真的知道吗？](https://www.jianshu.com/p/980abadd8a18)\n\n[React SFC 无状态组件及多种组件写法](https://blog.lbinin.com/frontEnd/React/React-SFC.html#%E5%8E%9F%E7%90%86)\n"},{"title":"根据要求定义react组件`<Student/>`","url":"/Roundtables/Question-Bank/react/Student.html","content":"# 根据要求定义react组件`<Student/>`\n\n编写Student组件，可以接收学生姓名、性别(F/M)、年龄、所在班级信息、考试成绩（其中姓名、性别、成绩为必传项，其它为选填，未传递需要指定一个默认值），并显示出来。同时有一个查看成绩的按钮，点击后alert出该学生的成绩。\n\n请根据以上描述实现该组件：\n```js\n<Student name=\"小明\" sex=\"F\" score={99} age={18} class=\"1班\" />\n```\n\n## 方法一：使用js实现\n```js\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PropTypes from \"prop-types\";\n\nclass Student extends Component {\n  checkScore = () => {\n    window.alert(this.props.score);\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.checkScore}>查看成绩</button>\n      </div>\n    );\n  }\n}\n\nStudent.propTypes = {\n  name: PropTypes.string.isRequired,\n  sex: PropTypes.oneOf([\"F\", \"M\"]).isRequired,\n  score: PropTypes.number.isRequired,\n  age: PropTypes.number,\n  class: PropTypes.string\n};\n\nStudent.defaultProps = {\n  age: 18,\n  class: \"1班\"\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Student name=\"小张\" sex=\"F\" score={60} />\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n## 方法二：使用ts实现\n```tsx\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\n\ninterface IProp {\n  name: string;\n  sex: \"F\" | \"M\";\n  score: number;\n  age?: number;\n  class?: string;\n}\n\nclass Student extends Component<IProp> {\n  // static关键词会使属性挂在类Student上成为静态属性，不加的话就是实例属性，挂在this上\n  static defaultProps: Partial<IProp> = {\n    age: 18,\n    class: \"1班\"\n  };\n  checkScore = () => {\n    window.alert(this.props.score);\n  };\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.checkScore}>查看成绩</button>\n      </div>\n    );\n  }\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Student name=\"小张\" sex=\"F\" score={60} />\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n\n"},{"title":"React Hooks 使用技巧","url":"/Roundtables/Question-Bank/react/black-magic-of-hooks.html","content":"# React Hooks 使用技巧\n\n## 怎么替代 SCU（shouldComponentUpdate）\n在 Class Component 的写法通常是：\n```jsx\nclass Button extends React.PureComponent {}\n```\n这样就自带了 shallowEqual 的 shouldComponentUpdate。\n\n相比之下，Function Component 替代 shouldComponentUpdate 的方案并没有 Class Component 优雅，代码是这样的：\n- 使用 React.memo()：\n```jsx\nconst Button = React.memo(props => {\n  // your component\n});\n```\n- 使用 useMemo：\n或者在父级就直接生成一个自带 memo 的子元素：\n```jsx\nfunction Parent({ a, b }) {\n  // Only re-rendered if `a` changes:\n  const child1 = useMemo(() => <Child1 a={a} />, [a]);\n  // Only re-rendered if `b` changes:\n  const child2 = useMemo(() => <Child2 b={b} />, [b]);\n  return (\n    <>\n      {child1}\n      {child2}\n    </>\n  );\n}\n```\n\n## 怎么替代 componentDidUpdate\n由于 useEffect 每次 Render 都会执行，因此需要模拟一个 useUpdate 函数：\n```jsx\nconst mounting = useRef(true);\nuseEffect(() => {\n  if (mounting.current) {\n    mounting.current = false;\n  } else {\n    fn();\n  }\n});\n```\n\n\n## 怎么替代 forceUpdate\n- React 官方文档提供了一种方案：\n```js\nconst [ignored, forceUpdate] = useReducer(x => x + 1, 0);\n\nfunction handleClick() {\n  forceUpdate();\n}\n```\n每次执行 dispatch 时，只要 state 变化就会触发组件更新。\n\n- 当然 useState 也同样可以模拟：\n```js\nconst useUpdate = () => useState(0)[1];\n```\n我们知道 useState 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 setValue，这样它的功能就仅剩下刷新组件了。\n\n\n## 聚合拆分过多的 state\nuseState 目前的一种实践，是将变量名打平，而非像 Class Component 一样写在一个 State 对象里：\n```jsx\nclass ClassComponent extends React.PureComponent {\n  state = {\n    left: 0,\n    top: 0,\n    width: 100,\n    height: 100\n  };\n}\n\n// VS\n\nfunction FunctionComponent {\n  const [left,setLeft] = useState(0)\n  const [top,setTop] = useState(0)\n  const [width,setWidth] = useState(100)\n  const [height,setHeight] = useState(100)\n}\n```\n实际上在 Function Component 中也可以聚合管理 State：\n```jsx\nfunction FunctionComponent() {\n  const [state, setState] = useState({\n    left: 0,\n    top: 0,\n    width: 100,\n    height: 100\n  });\n}\n```\n只是更新的时候，**不再会自动 merge，而需要使用 `...state` 语法：**\n```jsx\nsetState(state => ({ ...state, left: e.pageX, top: e.pageY }));\n```\n\n更推荐的是，**把 state 切分成多个 state 变量**，**每个变量包含的不同值会同时发生变化**。\n\n举个例子，我们可以把组件的 state 拆分为 position 和 size 两个对象，并永远以非合并的方式去替换 position：\n```jsx\nfunction Box() {\n  const [position, setPosition] = useState({ left: 0, top: 0 });\n  const [size, setSize] = useState({ width: 100, height: 100 });\n\n  useEffect(() => {\n    function handleWindowMouseMove(e) {\n      setPosition({ left: e.pageX, top: e.pageY });\n    }\n    // ...\n```\n\n## 如何获取上一轮的 props 或 state\n虽然不怎么常用，但是毕竟 Class Component 可以通过 componentWillReceiveProps 拿到 prevProps 与 nextProps，对于 Function Component，最好通过自定义 Hooks 方式拿到上一个状态：\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const prevCount = usePrevious(count);\n  return (\n    <h1>\n      Now: {count}, before: {prevCount}\n    </h1>\n  );\n}\n\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n```\n通过 `useEffect` 在组件渲染完毕后再执行的特性，再利用 `useRef` 的可变特性，让 `usePrevious` 的返回值是 “上一次” Render 时的。\n\n可见，合理运用 useEffect useRef，可以做许多事情，而且封装成 CustomHook 后使用起来仍然很方便。未来 usePrevious 可能成为官方 Hooks 之一。\n\n## 如何惰性创建昂贵的对象\n如果依赖数组的值相同，useMemo 允许你 记住一次昂贵的计算。但是，这仅作为一种提示，并不 保证 计算不会重新运行。但有时候需要确保一个对象仅被创建一次。\n\n1、第一个常见的使用场景是当**创建初始 state 很昂贵时**：\n```jsx\nfunction Table(props) {\n  // ⚠️ createRows() 每次渲染都会被调用\n  const [rows, setRows] = useState(createRows(props.count));\n  // ...\n}\n```\n由于整个函数组件都是 Render，因此每次初始化时，createRows()都会被调用，为避免重新调用昂贵的createRows()，我们可以传一个 函数 给 useState：\n```jsx\nfunction Table(props) {\n  // ✅ createRows() 只会被调用一次\n  const [rows, setRows] = useState(() => createRows(props.count));\n  // ...\n}\n```\nReact 只会在首次渲染时调用这个函数。\n\n2、略\n\n\n## 如果 effect 的依赖频繁变化该怎么办？\n即使effect依赖的deps频繁变化，你也不能忽略副作用函数所依赖的变量，如下，明明使用了count，却没有声明在依赖中，所以当count变化时，副作用函数也不会执行，count则不会超过1：\n```jsx\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n```\n如果将count声明在依赖中，可以完成功能，但却会付出代价：\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(count + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, [count]);\n```\n代码可以正常运行了，拿到了最新的 count。\n\n但是：\n- 计时器不准了，因为每次 count 变化时都会销毁并重新计时。\n- 频繁 生成/销毁 定时器带来了一定性能负担。\n\n可以 想办法不依赖外部变量，使用 setCount 的函数回调模式，每次改变旧的值：\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n不过如果effect还依赖作用域中的其他变量时，比如 步频不是1而是step变量，还是无法解决问题，推荐的方法是使用 useReducer 函数，将更新与动作解耦：\n```jsx {7}\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { count, step } = state;\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: 'tick' });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return (\n    <>\n      <h1>{count}</h1>\n      <input value={step} onChange={e => {\n        dispatch({\n          type: 'step',\n          step: Number(e.target.value)\n        });\n      }} />\n    </>\n  );\n}\n\nconst initialState = {\n  count: 0,\n  step: 1,\n};\n\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === 'tick') {\n    return { count: count + step, step };\n  } else if (action.type === 'step') {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n```\n由于更新变成了 `dispatch({ type: \"tick\" })` 所以**不管更新时需要依赖多少变量，在调用更新的动作里都不需要依赖任何变量**。具体更新操作在 reducer 函数里写就可以了。\n\n([在线demo](https://codesandbox.io/s/xzr480k0np))\n\n\n## 参考链接\n\n- [Hooks FAQ](https://zh-hans.reactjs.org/docs/hooks-faq.html)\n- [精读《Function VS Class 组件》](https://github.com/dt-fe/weekly/blob/master/95.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20VS%20Class%20%E7%BB%84%E4%BB%B6%E3%80%8B.md)\n- [精读《useEffect 完全指南》](https://segmentfault.com/a/1190000018639033)\n- [精读《怎么用 React Hooks 造轮子》](https://github.com/dt-fe/weekly/blob/master/80.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%80%8E%E4%B9%88%E7%94%A8%20React%20Hooks%20%E9%80%A0%E8%BD%AE%E5%AD%90%E3%80%8B.md#componentdidupdate)\n"},{"title":"关于props.children的一切","url":"/Roundtables/Question-Bank/react/children.html","content":"# 关于props.children的一切\n\n## 组件的props.children是指什么？\n\nReact支持在自定义组件时，在其中嵌套 JSX 结构。嵌套的结构在组件内部都可以通过 `props.children` 获取到，这种组件编写方式在编写容器类型的组件时非常有用：\n```jsx\nclass Card extends Component {\n  render () {\n    return (\n      <div className='card'>\n        <div className='card-content'>\n          {this.props.children}\n        </div>\n      </div>\n    )\n  }\n}\n\nReactDOM.render(\n  <Card>\n    <h2>React.js</h2>\n    <div>开源</div>\n    订阅：<input />\n  </Card>,\n  document.getElementById('root')\n)\n```\n`props.children`打印结果如下：\n\n![](./images/props_children.png)\n\nReact.js 把嵌套的 JSX 元素一个个都放到数组当中，然后通过 `props.children` 传给了 Card。\n\n\n## React.Children 操纵子元素\n\n**React.Children** 提供了用于处理 this.props.children 不透明数据结构的辅助方法。\n\n*这里的`“不透明”`，代表 this.props.children 可以是任何类型，例如数据，函数，对象，等等。因此你可以传递任何东西。*\n\n### 1、遍历当前组件的children\n```jsx\nReact.Children.map(children, function(child, i) {}) // 遍历，并返回一个新数组；\n\nReact.Children.forEach(children, function(child, i) {}) // 只遍历\n```\n\n### 2、传递不同类别的children有何区别？如何获取children的数量？\n\n- 如果传递一个字符串或者函数作为子元素，将打破`this.props.children.length`的正常使用：比如有一个后代，“Hello World.”，但是`this.props.children.length`相反却输出12!\n- 而不管子元素是什么类型，`React.Children.count(children)`都可以准确地返回 children 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数。\n\n\n### 3、在渲染函数中如何操作子节点的集合（数组化）\n\n`React.Children.toArray(children)`，将 children 这个复杂的数据结构以数组的方式**扁平展开并返回**，并为每个子节点**分配一个 key**。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 this.props.children 之前对内容**重新排序**或**获取子集**时。\n\n### 4、验证只有一个子React元素\n`React.Children.only(children)`，验证 children 是否只有一个子节点（必须是 React 元素），如果有则返回它，否则此方法会抛出错误。\n\n\n### 5、修改子元素属性\n\n当想要给多个子元素添加属性时，比如这里为了分组，需要给RadioButton添加相同的name属性：\n```jsx\nrender () {\n  return (\n    <RadioGroup>\n      <RadioButton value=\"first\"> First </RadioButton>\n      <RadioButton value=\"second\"> Second </RadioButton>\n      <RadioButton value=\"third\"> Third</RadioButton>\n    </RadioGroup>\n  );\n}\n\n// 我们当然可以遍历，然后给每一个单独的RadioButton分配一个name属性。\n<RadioGroup>\n  <RadioButon name=\"g1\" value=\"first\">First</RadioButton>\n  <RadioButton name=\"g1\" value=\"second\">Second</RadioButton>\n  <RadioButton name=\"g1\" value=\"third\">third</RadioButton> \n</RadioGroup>\n```\n我们当然可以这样直接手动给每个RadioButton添加name=\"g1\"属性，但这并不是聪明的做法，我们可以使用React.cloneElement()这样做：\n\n```jsx\nclass RadioGroup extends React.Component {\n    constructor() {\n        super();\n        this.renderChildren = this.renderChildren.bind(this);\n    }\n    renderChildren() {\n        return React.Children.map(this.props.children, child => {\n            return React.cloneElement(child, {\n                name: this.props.name\n            })\n        })\n    }\n    render () {\n        return (\n        <div className=\"group\">\n            {this.renderChildren()}\n        </div>\n        );\n    }\n}\n\n// 此时，只需给我们的RadioGroup组件设置一个唯一name属性值:\n<RadioGroup name=\"g1\">\n  <RadioButton value=\"first\">First</RadioButton>\n  <RadioButton value=\"second\">Second</RadioButton>\n  <RadioButton value=\"three\"> Three</RadioButton>\n</RadioGroup>\n```\n"},{"title":"React组件分类（不同角度）","url":"/Roundtables/Question-Bank/react/component-classify.html","content":"# React组件分类（不同角度）\n\n## 函数组件与类组件\n传送门：[函数组件与类组件](./element-component-instance-node.html#react组件-分3类（函数组件与类组件）)\n\n## 有状态组件与无状态组件\n传送门：[有状态与无状态组件](./element-component-instance-node.html#构建-react组件-的方法（3种：包括有状态与无状态组件）)\n\n## \b受控组件与非受控组件\n\n### 定义\n1. **受控组件**：受控组件是在 React 中处理输入表单的一种技术。表单元素通常维护它们自己的状态，而react则在组件的状态属性中维护状态。我们可以将两者结合起来控制输入表单。这称为受控组件。因此，在受控组件表单中，数据由React组件处理。大多数情况下，**建议使用受控组件**。\n2. **非受控组件**：有一种称为非受控组件的方法可以通过使用Ref来处理表单数据。在非受控组件中，Ref用于直接从DOM访问表单值，而不是事件处理程序。\n\n### 区别\n受控组件    |\t非受控组件\n-   |   -\n1. 没有维持自己的状态   |   1. 保持着自己的状态\n2.数据由父组件控制  |   2.数据由 DOM 控制\n3. 通过 props 获取当前值，然后通过回调通知更改  |   3. 通过 refs 来操作真实的DOM，获取其当前值\n\n"},{"title":"给出基于react-router的路由定义","url":"/Roundtables/Question-Bank/react/declare-react-router.html","content":"# 给出基于react-router的路由定义\n```\n假设页面需要以下几个页面：\n    /: Home\n    /login: Login\n    /personal: Personal\n    /personal/deposit: Deposit\n    /about: About\n\n- 假定有全局变量isLogin来表示是否登录\n- /personal、/personal/deposit需要登录后才能访问。如果未登录，跳转/login\n- /login 要求只能为登录情况下访问，如果已登录跳转/personal\n- 非以上地址访问全部跳转首页\n```\n请尽可能只通过react-router实现上述要求：\n\n\n## johninch\n```tsx\nimport React from 'react';\nimport ReactDom from 'react-dom';\nimport { BrowserRouter, Switch, Route } from 'react-router-dom';\nimport Home from './home';\n// ...\n\nlet isLogin = false;\n\nReactDom.render(\n    <BrowserRouter>\n       <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route path=\"/personal\" render={() => {\n                isLogin ? (\n                    <Route exact path=\"/personal\" component={Personal} />\n                    <Route path=\"/personal/deposit\" component={Deposit} />\n                ) : (\n                    <Login />\n                )\n            }}/>\n            <Route path=\"/about\" component={About} />\n            <Redirect to=\"/\">\n       </Switch>\n    </BrowserRouter>\n)\n```\n"},{"title":"Element、Component、Node、Instance如何区分？","url":"/Roundtables/Question-Bank/react/element-component-instance-node.html","content":"# Element、Component、Node、Instance如何区分？\n\n> 谈谈React中Element、Component、Node、Instance 四个概念的理解以及它们之间的联系、异同点等\n\n----\n\n## 一、Element(元素)\n\n### 定义\n- React元素 是简单JS对象，描述的是React虚拟dom（结构及渲染效果）。\n- React元素是React应用的最基础组成单位。通常情况我们都不会直接使用 React元素。React组件的复用，本质上是为了复用这个组件返回的React元素。\n\n### React如何判断一个值是Element（isValidElement）？\n通过判断一个对象是否是合法的react元素，即判断虚拟DOM的`$$typeof`属性是否为`REACT_ELEMENT_TYPE`:\n```js {5}\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE\n  );\n} \n```\n### React元素 分两类\n- DOM类型的元素：DOM类型的元素使用像h1、div、p等DOM节点标签 创建 React元素；\n- 组件类型的元素：组件类型的元素使用 React组件 创建 React元素；\n```js\n    const buttonElement = <Button color='red'>OK</Button>;\n\n    const buttonElement = {\n        type: 'Button',\n        props: {\n            color: 'red',\n            children: 'OK'\n        }\n    }\n```\n\n\n\n### React如何判断一个Element是来自原生节点还是自定义组件？\n\n原生DOM节点的Element其**type属性**是`原生DOM标签字符串`；而自定义组件的Element其**type属性**为`首字母大写的字符串`。\n\n#### React的渲染过程\n\n例如Home组件使用了Welcome组件，返回的 React元素 如下：\n```js\n{\n    type: 'div',\n    props: {\n        children: [\n        {\n            type: 'Welcome',\n            props: {\n            name: '老干部'\n            }\n        },\n        {\n            type: 'p',\n            props: {\n              children: 'Anything you like'\n            }\n        }，\n        ]\n    }\n}\n```\n- React 对于 type = 'div' 和 type = 'p' 等这类原生节点，会直接将虚拟DOM渲染为真实节点；\n- 但React 面对 type='Welcome' 这类自定义组件节点时，并不知道如何渲染。当React 发现Welcome 是一个自定义组件时，**会调用该组件的render方法，生成该组件的Element**，如果该组件的element中依然有首字母大写开头的Element的type，继续重复上述步骤，直到发现没有首字母大写的type，即原生DOM节点Element为止。\n\n::: tip 自定义组件首字母必须大写的原因\n通过React组件的渲染过程可得：所有的React自定义组件必须首字母大写，原因是生成React Element的时候，type属性会直接使用该组件的实例名称（\\<InstanceName />），如果没有大写，React将不能判断是否需要继续调用该组件的render方法创建Element，阻断React元素的渲染。\n:::\n\n### 构建 React元素 的方法（3种）\n::: details 构建 React元素 的方法：使用 JSX 语法、React.createElement()、React.cloneElement()\n\n1. **JSX语法**\n\n```js\nconst element = <h1 className='greeting'>Hello, world</h1>;\n```\n\n编译后：\n\n```js\nconst element = React.createElement('h1', {className: 'greeting'}, 'Hello, world!');\n```\n\n最终返回的 React元素element为：\n\n```js\nconst element = {\n  type: 'h1',\n  props: {\n    className: 'greeting',\n    children: 'Hello, world'\n  }\n}\n```\n\n2. **React.createElement()**\n\nJSX 语法就是用React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\n\n```js\nReact.createElement(\n    type,\n    [props],\n    [...children]\n)\n```\n\n3. **React.cloneElement()**\n\nReact.cloneElement()与React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会合并入原有的属性，传入到返回的新元素中，而旧的子元素将被替换。\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n```\n:::\n\n## 二、Component(组件)\n\nReact组件(Component)最核心的作用是：调用```React.createElement()```返回 React元素。\n\n### React组件 分3类（函数组件与类组件）\n*如果DOM节点也被算作一种组件的话*：\n\n- host类型（DOM节点）：React 会根据对应 type，生成真正的 DOM node，并将它所带的 props 写入 node 的 attribute 中，而对 children 继续递归，直到碰到没有 children 的 host Element 为止；\n- function类型：function的返回值是element；\n  ```js\n  function Welcome(props) {\n    return <h1>Hello, {props.name}</h1>;\n  }\n  ```\n- class类型：class的render函数的返回值是element；\n  ```js\n  class Welcome extends React.Component {\n    render() {\n      return <h1>Hello, {this.props.name}</h1>;\n    }\n  }\n  ```\n\n注意：```使用 class定义的组件，render方法是唯一必需的方法，其他组件的生命周期方法都只不过是为render服务而已，都不是必需的。```\n\n### React 如何调用class和function 组件\n\nReact调用组件的目的都是返回React元素，对于class和function类型的组件，React内部的调用方式是不同的：\n\n1. 如果是一个函数，React只需要`直接调用`它:\n```js\n// function 类型:\nfunction Greeting() {\n  return <p>Hello</p>;\n}\n\n// React内 直接调用function类型的组件：\nconst result = Greeting(props); // <p>Hello</p>\n```\n\n2. 如果是一个类，React就需要使用`new来实例化`它，`然后在实例上调用render`方法：\n```js\n// class 类型:\nclass Greeting extends React.Component {\n  render() {\n    return <p>Hello</p>;\n  }\n}\n\n// React内 需要使用new来实例化它，然后在实例上调用render方法:\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // <p>Hello</p>\n```\n\n### React 如何区分class和function 组件\n\n不过这里还有一个问题，function 和 class 的 typeof 都是 function，这两个是怎么判断的呢？\n\n因为 class 定义的组件，继承于 React.Component，`React.Component.prototype`上拥有一个特殊的标志属性 `isReactComponent` ，只需要检测是否拥有这个属性就能确定是 class 还是 function。\n```js\n// Inside React\nclass Component {}\nComponent.prototype.isReactComponent = {};\n\n// We can check it like this\nclass Greeting extends Component {}\nconsole.log(Greeting.prototype.isReactComponent); // ✅ Yes\n```\n\n### 构建 React组件 的方法（3种：包括有状态与无状态组件）\n::: details 构建 React组件 的方法：React.createClass()、ES6 class和 无状态函数\n\n1. ES5的React.createClass()\n\n是三种方式中最早，兼容性最好的方法，但已被官方放弃；\n\n2. **ES6 class有状态组件**\n```ts\nclass App extends React.Component { render() {} }\n```\nES6 class是目前官方推荐的使用方式，但它的实现仍是调用React.createClass()来实现。\n\n3. **无状态函数组件**\n\n无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。\n\n注：React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。\n:::\n\n### 从写法上区分 元素与组件\n::: tip 区分\n\\<A /> 整个表达式是一个 Element，而 A 是一个 Component， Component 要么是 function（class 也是 function），要么是纯 DOM。\n:::\n\n## 三、Node(节点)\n\n```ts\nMyComponent.propTypes = { \n  optionalNode: PropTypes.node,\n}\n```\n\n在使用PropTypes校验组件属性时，有一种PropTypes.node类型：这表明optionalNode是一个React 节点。\n\nReact 节点是指**可以被React渲染的数据类型，包括`数字、字符串、React 元素，或者是一个包含这些类型数据的数组`。**\n\n## 四、Instance(实例)\n\nReact组件的实例：\n - 只有组件实例化后，每一个组件实例才有了自己的props和state，才持有对它的DOM节点和子组件实例的引用。\n - 在传统的面向对象的开发方式中，实例化的工作是由开发者自己手动完成的，但在React中，`组件的实例化工作是由React自动完成的，组件实例也是直接由React管理的`。换句话说，**开发者完全不必关心组件实例的创建、更新和销毁**。\n\n\n\n#### 参考链接\n\n[](https://www.jianshu.com/p/11c331242552)\n"},{"title":"React Fiber","url":"/Roundtables/Question-Bank/react/fiber.html","content":"\n# React Fiber\n\n## Fiber 解决什么问题（主线程阻塞）\nVDOM 在操作真正的 DOM 之前，先通过 VDOM 前后对比得出需要更新的部分，再去操作真实的 DOM，减少了浏览器多次操作 DOM 的成本。这一过程，官方起名 `reconciliation`，可翻译为`协调算法`。\n\n- 在 react@15 ，reconciler（stack reconcilation）采用自顶向下递归，更新整个子树。如果组件树不大不会有问题，但是当组件树越来越大，`递归遍历的成本就越高，持续占用主线程`。\n- JS引擎线程、GUI引擎线程（页面布局和页面绘制）都是运行在浏览器的主渲染进程当中的，而浏览器的渲染进程在同一时间只能做一件事，所以 JS引擎线程、GUI引擎线程 之间是互斥的。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。\n- React 的 stack reconcilation 是**CPU密集型的操作**，**并且整个过程是一气呵成的，不能被打断**，在此期间，React 会霸占着浏览器资源，导致两个问题：\n    1. 一则会导致用户触发的事件得不到响应；\n    2. 二则会导致掉帧，用户可以感知到这些卡顿（页面元素很多时，整个过程占用的时机就可能超过 16ms (1000ms / 60)，就容易出现掉帧的现象）。\n\n![Stack-Reconcilation](./images/Stack-Reconcilation.png)\n\n体验一下：[Fiber vs Stack Demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/)\n\n::: tip 前端框架可从 3个方向 解决「主线程阻塞」问题\n对于 '前端框架' 来说，解决这种问题有三个方向:\n1. 优化每个任务，让它有多快就多快。挤压CPU运算量；\n2. 快速响应用户，让用户觉得够快，不能阻塞用户的交互；\n3. 尝试 Worker 多线程；\n\n*对于Worker 多线程渲染方案也有人尝试，但要保证状态和视图的一致性相当麻烦。*\n\n#### Vue 选择了1️⃣\n\n因为对于Vue来说，使用模板让它有了很多优化的空间，配合响应式机制可以让Vue精确地进行节点更新（尤雨溪：如果我们可以**把`更新做得足够快`的话，理论上就不需要时间分片了**）；\n\n#### React 选择了2️⃣\n\n为了给用户制造一种应用很快的'假象'，不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要**通过某些调度策略`合理地分配CPU资源`**，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。\n:::\n\n## Fiber 工作原理\n\n**解决基本思路**：具体解决主线程长时间被 JS 运算占用这一问题，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。\n\n::: tip 可中断/恢复的Fiber\nReact@15使用的是 **JS 引擎自身的函数调用栈**，它会一直执行到**栈空**为止。\n\nReact@16 的 Fiber实现了**自己的组件调用栈**，它以**链表**的形式遍历组件树，让自己的 Reconcilation 过程变成**可中断**的，可以灵活的暂停、继续和丢弃执行的任务。**适时地让出CPU执行权**，可以让浏览器及时地响应用户的交互，并且，给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正。\n:::\n\n浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:\n1. 处理用户输入事件\n2. Javascript执行\n3. 调用rFA （requestAnimationFrame）\n4. 布局 Layout\n5. 绘制 Paint\n如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 `requestIdleCallback` 的回调。例如\n\n![](./images/requestIdleCallback.png)\n\n但是在浏览器繁忙的时候，可能不会有盈余时间，这时候`requestIdleCallback`回调可能就不会被执行。 为了避免饿死，可以通过`requestIdleCallback`的第二个参数指定一个超时时间。\n\n::: warning requestIdleCallback\n**requestIdleCallback** 的意思是让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。\n:::\n\n## Fiber 到底是什么\n\n知道Fiber为什么而生，且知道其原理思路后，再回头来看，Fiber 到底是什么。\n\n### 是一种流程控制：协程调度 Scheduling\nFiber 也称「协程」，**`协程`只是一种`控制流程的让出机制`**。协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程）。React Fiber 的思想和协程的概念是契合的: React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。\n\n由于浏览器任务不具备中断/恢复的条件，且没有抢占机制，因此，只能**采用类似协程这样控制权让出**的 `合作式调度(Cooperative Scheduling)`，每次只做一个很小的任务，做完后能够“喘口气儿”，回到主线程看下有没有什么更高优先级的任务需要处理，如果有则先处理更高优先级的任务，没有则继续执行。\n\n#### 怎么确定有高优先任务要处理，即什么时候让出？\n\n在目前浏览器中是`没法判断`当前是否有更高优先级的任务等待被执行。\n\n所以，可以通过`超时检查的机制`来让出控制权。解决办法是: React 预定了5个优先级（低优先级的可以慢慢等待, 高优先级的任务应该率先被执行），不同优先级对应不同的运行时长，然后在合适的检查点检测是否超时，如果超时就停止执行，将控制权交还给浏览器。\n\n*React 那为什么不使用 Generator？* React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。\n\n### 是一个执行单元：时间分片\n\nFiber 的另外一种解读是「纤维」: 这是**一种数据结构或者说`执行单元`**。\n\nReact 没有使用 Generator 这些语言/语法层面的协程让出机制，而是`实现了自己的调度让出机制`。这个机制就是基于Fiber这个执行单元的：React会从更新队列(updateQueue)中弹出更新任务来执行，每次执行完一个 执行单元, 就会检查现在还剩多少时间，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，将控制权让出去，等下一次有执行权时再恢复。\n\n## React 对 Fiber 的改造\n\n「功能改造」首先需要先从「数据结构」下手：\n::: details Fiber结构（新增属性）： 结构信息、副作用、替身\n```ts\ninterface Fiber {\n  /**\n   * ⚛️ 节点的类型信息\n   */\n  // 标记 Fiber 类型, 例如函数组件、类组件、宿主组件\n  tag: WorkTag,\n  // 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)\n  type: any,\n\n  /**\n   * ⚛️ 节点的状态\n   */\n  // 节点实例(状态)：\n  //        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。\n  //        对于类组件来说，这里保存类组件的实例\n  //        对于函数组件说，这里为空，因为函数组件没有实例\n  stateNode: any,\n  // 新的、待处理的props\n  pendingProps: any,\n  // 上一次渲染的props\n  memoizedProps: any, // The props used to create the output.\n  // 上一次渲染的组件状态\n  memoizedState: any,\n\n  /**\n   * ⚛️ 结构信息\n   */ \n  return: Fiber | null,\n  child: Fiber | null,\n  sibling: Fiber | null,\n  // 子节点的唯一键, 即我们渲染列表传入的key属性\n  key: null | string,\n\n  /**\n   * ⚛️ 副作用\n   */\n  // 当前节点的副作用类型，例如节点更新、删除、移动\n  effectTag: SideEffectTag,\n  // 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来\n  nextEffect: Fiber | null,\n\n  /**\n   * ⚛️ 替身\n   * 指向旧树中的节点\n   */\n  alternate: Fiber | null,\n}\n```\n:::\nFiber 包含的属性可以划分为 5 个部分:\n- **节点类型信息**：tag表示节点的分类、type 保存具体的类型值，如div、MyComp；\n- **节点的状态**：节点的组件实例、props、state等，它们将影响组件的输出；\n- :tada:**结构信息(新增)**：新增的 `上下文信息`，Fiber 依次通过 return、child 及 sibling 的顺序对 ReactElement 做处理，将之前简单的树结构，变成了`链表的形式`，维护了更多的节点关系。\n- :tada:**副作用(新增)**：新增的，在 Reconciliation 过程中发现的 `副作用(变更需求) `就保存在节点的 effectTag 中(想象为打上一个标记)。也使用了链表结构，在遍历过程中React会将所有有`副作用`的节点都通过nextEffect连接起来，从而`收集本次渲染的所有节点副作用`。\n- :tada:**替身(新增)**：新增的`WIP树`，React 在 Reconciliation 过程中会构建一颗新的树(官方称为workInProgress tree，`WIP树`)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的`旧树`，React就是一边和旧树比对，一边构建`WIP树`的。 alternate 指向旧树的同等节点。\n\n有了上述数据结构的变更，React是通过如下几方面来优化的：\n\n### 1、增加上下文信息，拆分工作单元\nReact@15，Reconcilation 是同步的、递归执行的。称它为 **Stack Reconcilation**，是基于函数「调用栈」的Reconcilation算法。栈挺好的，代码量少，递归容易理解, 也非常适合树这种嵌套数据结构的处理。只不过这种依赖于**调用栈的方式**`不能随意中断、也很难被恢复, 不利于异步处理`。这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。\n\n因此，React为了模拟函数调用栈, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代：\n```js\nexport type Fiber = {\n  // Fiber 类型信息\n  type: any,\n  // ...\n\n  // ⚛️ 链表结构\n  // 指向父节点，或者render该节点的组件\n  return: Fiber | null,\n  // 指向第一个子节点\n  child: Fiber | null,\n  // 指向下一个兄弟节点\n  sibling: Fiber | null,\n}\n```\nFiber 和调用栈帧一样, **保存了节点处理的上下文信息**，因为是手动实现的，所以更为可控，我们可以**保存在内存中，随时中断和恢复**。\n\n### 2、将渲染拆分为两个阶段（Fiber Reconcilation）\n在 React@15 中 `Stack Reconcilation` 是同步递归的，一边Diff（即Reconciliation，两者可视为同一个东西）一边提交。而在 React@16 中，每次渲染有两个阶段：**Reconciliation(协调阶段)** 和 **Commit(提交阶段)**，被称之为 `Fiber Reconcilation`：\n- **协调阶段 Reconciliation**: 可以认为是 Diff 阶段，这个阶段`可以被中断(interruptible)`，这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等，这些变更，React 称之为**副作用(Effects)**。以下生命周期钩子会在协调阶段被调用：\n  - constructor\n  - componentWillMount 废弃\n  - componentWillReceiveProps 废弃\n  - static getDerivedStateFromProps\n  - shouldComponentUpdate\n  - componentWillUpdate 废弃\n  - render\n- **提交阶段 Commit**: 将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。这个阶段必须`同步执行，不能被打断(not interruptible)`. 这些生命周期钩子在提交阶段被执行:\n  - getSnapshotBeforeUpdate()：严格来说，这个是在进入 commit 阶段前调用\n  - componentDidMount\n  - componentDidUpdate\n  - componentWillUnmount\n\n::: danger React 为什么**废弃**可能包含副作用的生命周期方法\n在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。\n\n需要注意的是：**因为协调阶段可能被中断、恢复，甚至重做，⚠️React 协调阶段的生命周期钩子可能会被调用多次!**, 例如 componentWillMount 可能会被调用两次。\n\n*因此建议 协调阶段的生命周期钩子不要包含副作用。React@16 索性就废弃了这部分可能包含副作用的生命周期方法，例如componentWillMount、componentWillUpdate.* \n:::\n\n### 3、双缓存（WIP树）\n\nReact 中 `WIP树`（workInProgress tree工作进度树）就是一个`缓存`。React 在 Reconciliation 过程中会一边和`旧树`比较，一边构建一颗新的`WIP树`，可以认为是一颗表示当前工作进度的树，Diff完毕后，**一次性提交给浏览器**进行渲染。\n\n这样做可以**减少内存分配和垃圾回收**。WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。\n\n### 4、副作用收集和提交\n收集本次渲染的所有副作用节点，即 将所有打了 EffectTag 标记的节点串联起来，最后将副作用提交（commit）。\n\n## 并发模式（Concurrent Mode）\n\n图中的波形是浏览器的调用栈执行曲线，React 在开启 `Concurrent Mode` 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。\n![Fiber-Reconcilation](./images/Fiber-Reconcilation.png)\n\n### 并发模式的优点\n\n开启 `Concurrent Mode` 后，我们可以得到以下好处:\n- 快速响应用户操作和输入，提升用户交互体验\n- 让动画更加流畅，通过调度，可以让应用保持高帧率\n- 利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。\n- 用Suspense 降低加载状态(load state)的优先级，减少闪屏。比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。\n\n但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的。\n\n### 为什么 React16 没有感觉变快\nReact@16 还是同步渲染的，因为**没有开启并发模式**。想要真正体会到 React Fiber 重构的效果（异步渲染），可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的React 还是同步渲染的，一直在跳票，Fiber 的 Concurrent并发模式 没开启，渲染还是同步的。而没有开启 Concurrent 模式的 React@16，除了数据结构不同外，和 React@15 没什么区别。\n\n## 参考链接\n- [这可能是最通俗的 React Fiber(时间分片) 打开方式](https://juejin.im/post/5dadc6045188255a270a0f85)\n- [React Fiber 原理介绍](https://segmentfault.com/a/1190000018250127?utm_source=tag-newest)\n- [Concurrent Rendering in React](https://www.youtube.com/watch?v=ByBPyMBTzM0)\n\n"},{"title":"Function VS Class 组件（最大区别 - Capture Value）","url":"/Roundtables/Question-Bank/react/function-vs-class.html","content":"\n# Function VS Class 组件（最大区别 - Capture Value）\n\nfunction components 和 class components 之间有什么本质的区别吗？\n\n答案就是 function components 所拥有的 **捕获渲染值(Capture Value)**特性。\n\n思维上的不同：Function Component 是更彻底的状态驱动抽象，甚至没有 Class Component 生命周期的概念，只有一个状态，而 React 负责同步到 DOM。 \n\n既然是状态同步，那么每次渲染的状态都会固化下来，这包括 state props useEffect 以及写在 Function Component 中的所有函数。\n\n注意：*下文中所描述的，全部都是在 React 中 function 和 class 的差别，差异本身和React Hooks无关。*\n\n## 什么是Capture Value\n\n对比下面两段代码。（[在线demo](https://codesandbox.io/s/pjqnl16lm7)）\n\n- Class Component:\n    ```jsx\n    class ProfilePage extends React.Component {\n        showMessage = () => {\n            alert(\"Followed \" + this.props.user);\n        };\n\n        handleClick = () => {\n            setTimeout(this.showMessage, 3000);\n        };\n\n        render() {\n            return <button onClick={this.handleClick}>Follow</button>;\n        }\n    }\n    ```\n- Function Component:\n    ```jsx\n    function ProfilePage(props) {\n        const showMessage = () => {\n            alert(\"Followed \" + props.user);\n        };\n\n        const handleClick = () => {\n            setTimeout(showMessage, 3000);\n        };\n\n        return <button onClick={handleClick}>Follow</button>;\n    }\n    ```\n通常认为这两段代码是等效的，然而，其实这两段代码是有细微的差别的：\n\n尝试顺序操作：点击一个Follow按钮 -> 改变select选项然后等待3秒 -> 查看alert的文字\n\n你会发现一个问题：\n- 在function components中，在Dan的主页点击follow然后切换到Sophie，alert仍然会展示“Followed Dan”。即 **`Function Component` 展示的是`修改前`的值**。\n    ![](./images/Function-VS-Class-01.gif)\n- 在class components中，alert的却是“Followed Sophie”。即 **`Class Component` 展示的是`修改后`的值**。\n    ![](./images/Function-VS-Class-02.gif)\n\n\n那么 React 文档中描述的 props 不是不可变（Immutable）数据吗？为啥在运行时还会发生变化呢？\n::: tip 什么叫「Capture Value」特性\n我们知道，在 React中，每次 Render 都有自己的 Props 与 State，可以认为**每次 Render 的内容都会形成一个`快照`并保留下来**，因此当状态变更而 Rerender 时，就形成了 N 个 Render 状态，而每个 Render 状态都拥有自己固定不变的 Props 与 State。这就是 **Capture Value 特性**。\n\n不过，虽然 props 是不可变的，但在 Class Component 中使用了 this.props 来获取 props，而**因为 this 是可变的**，所以 this.props 的调用会导致每次都访问最新的 props。与类组件相对的，Function Component 不存在 this.props 的语法，因此 props 总是不可变的。\n:::\n\n## 如何使class组件也有 Capture Value\n::: details 拓展：如何使类组件也有 Capture Value 特性\n1、之所以在类组件中使用this会失去Capture Value特性，本质上就是因为 **拿到this.props太晚了**，简单的方式就是**更早地拿到this.props**的值，然后显式的将它传递到超时处理函数中：\n```jsx {7}\nclass ProfilePage extends React.Component {\n  showMessage = (user) => {\n    alert('Followed ' + user);\n  };\n\n  handleClick = () => {\n    const {user} = this.props;\n    setTimeout(() => this.showMessage(user), 3000);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Follow</button>;\n  }\n}\n```\n但上述方式并不解决所有问题，因为如果ShowMessage调用另一个方法，而该方法读取this.props.something或this.state.something，我们必须通过在ShowMessage调用的每个方法，将this.props和this.state作为参数传递。这破坏了class的解构，代码冗长，不易维护。\n\n2、如果我们**依赖于js的闭包**，问题就会得到解决。闭包通常是被避免的，因为它很难考虑一个随时间变化的值。但是在React中，props和state应该是不可变的：\n```jsx {3,4,6,7}\nclass ProfilePage extends React.Component {\n  render() {\n    // Capture the props!\n    const props = this.props;\n\n    // Note: we are *inside render*.\n    // These aren't class methods.\n    const showMessage = () => {\n      alert('Followed ' + props.user);\n    };\n\n    const handleClick = () => {\n      setTimeout(showMessage, 3000);\n    };\n\n    return <button onClick={handleClick}>Follow</button>;\n  }\n}\n```\n\n3、上面2的方式是正确的，但看起来很奇怪。因为如果只是在render中定义函数而不是使用类方法，那么使用 class还有什么意义呢？可以直接简化点使用 function组件了呀！我们可以通过移除class来简化代码：\n```jsx\nfunction ProfilePage(props) {\n  const showMessage = () => {\n    alert('Followed ' + props.user);\n  };\n\n  const handleClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    <button onClick={handleClick}>Follow</button>\n  );\n}\nprops仍然可以被捕获到，React将它作为一个参数传递。但 props对象本身不会因React而发生变化了。\n```\n:::\n\n## Capture Value 存在范围\n\n- 每次 Render 都有自己的 Props 与 State；\n- 每次 Render 都有自己的事件处理；\n- 每次 Render 都有自己的 Effects（即 hooks 也有 Capture Value 特性）；\n\n## function组件如何绕过 Capture Value\n利用 useRef 就可以绕过 Capture Value 的特性。可以认为 **ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态**，而不会在每个 Render 间存在隔离。\n\n传送门：[如何获取上一轮的 props 或 state](./black-magic-of-hooks.html#如何获取上一轮的-props-或-state)\n\n\n## 参考链接\n\n- [how-are-function-components-different-from-classes](https://overreacted.io/how-are-function-components-different-from-classes/)\n- [【译】函数组件和类组件有什么不同？](https://juejin.im/post/5c99bd42f265da61156099c5)\n- [精读《Function VS Class 组件》](https://github.com/dt-fe/weekly/blob/master/95.%E7%B2%BE%E8%AF%BB%E3%80%8AFunction%20VS%20Class%20%E7%BB%84%E4%BB%B6%E3%80%8B.md)\n\n"},{"title":"JSX 语法","url":"/Roundtables/Question-Bank/react/jsx-render.html","content":"# JSX 语法\n\n## 什么是JSX语法\n\nJSX（JavaScript XML）是JS的语法扩展，是使用 XML 语法编写 JavaScript 的一种语法糖。在 React 中，所有的组件的渲染功能都依靠 JSX，它利用 JS 的表现力和类似 HTML 的模板语法。JSX 可以生成 React “元素”。\n\n## 为什么JSX代码中一定要引入React？\n\nJSX只是为 `React.createElement(component,props,...children)方法提供的语法糖`。所有的 JSX代码最后都会转换成 React.createElement(...)，`Babel帮助我们完成了这个转换的过程`。所以使用了 JSX的代码都必须引入 React。\n\n## JSX 中可以渲染出false、true、null、undefined、''、0、[]、{}等值么？\n\n- `{}`：jsx 无法直接渲染对象，会报对象不是一个合法的react子节点，如果想要渲染一些子节点，最好用数组替代；\n- `[]`：可以正常渲染，如果数组中没有任何元素，则页面是空白的；\n- `false, true, null, ''`：可以渲染，页面不展示任何元素；\n- `undefined`：不能，因为render函数必须要有返回值；\n- `0`：可以正常渲染，页面显示0；\n\n只有 {}、undefined 不能正常渲染。\n"},{"title":"React 生命周期","url":"/Roundtables/Question-Bank/react/lifecycle.html","content":"# React 生命周期\n\n## 请给出下面render代码执行后控制台的字符串输出内容\n```js\n// 已知组件\nclass Base extends Component{\n    constructor(props) {\n        super(props);\n        console.log(props.prefixer + ' constructor')\n    }\n    componentWillMount() { console.log(this.props.prefixer + ' will mount') }\n    componentDidMount() { console.log(this.props.prefixer + ' did mount') }\n    componentDidUpdate() { console.log(this.props.prefixer + ' did update') }\n    render() { \n        console.log(this.props.prefixer + ' render')\n        return this.props.children || null;\n     }\n}\n \n \n// 渲染调用\nrender(<Base prefixer=\"parent\">\n    <Base prefixer=\"child\" />\n</Base>, document.querySelector('#root'))\n```\n\n答案：\n```\nparent constructor\nparent will mount\nparent render\nchild constructor\nchild will mount\nchild render\nchild did mount\nparent did mount\n```\n\n## React生命周期有哪些，16版本生命周期发生了哪些变化\n15生命周期：\n![](./images/lifecycle15.png)\n\n16生命周期：\n![](./images/lifecycle16.png)\n\n- React16新的生命周期弃用了3个钩子函数： `componentWillMount`、`componentWillUpdate`、`componentWillReceiveProps`；\n- 新增了 `getDerivedStateFromProps`、`getSnapshotBeforeUpdate`来代替弃用的三个钩子函数（React16并没有删除这三个钩子函数，但是不能和新增的钩子函数混用，React17将会删除这三个钩子函数）；\n- 新增了错误处理阶段：`componentDidCatch`。\n\n> 由于`Fiber在新版本中会支持异步渲染的特性`，而`componentWillMount`、`componentWillUpdate`、`componentWillReceiveProps`这3个生命周期钩子，在*异步渲染模式下会有一些潜在的问题*，因此被弃用。\n\n## componentWillUnmount有什么用，列举使用场景\nComponentWillUnmount()在组件被卸载和销毁之前立即调用。在此方法中执行任何必要的清理：\n- 移除定时器和事件；\n- 取消还未返回的网络请求回调（即网页发出请求,在请求数据还未回来的时候,跳到另一页面,数据回来之后会setstate,这样会导致内存泄露）。\n\n\n\n#### 参考链接\n[React生命周期有哪些，16版本生命周期发生了哪些变化](https://juejin.im/post/5d89cbd26fb9a06b2005a597#heading-0)"},{"title":"React事件机制","url":"/Roundtables/Question-Bank/react/react-event.html","content":"# React事件机制\n\nReact自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。\n\nReact事件并没有绑定在真实的 Dom节点上，而是通过事件代理，在最外层的 document上对事件进行统一分发。\n\n## React事件和原生事件有什么区别？\n\n1. React事件使用驼峰命名，而不是全部小写；通过 JSX，React事件传递一个函数作为事件处理程序，而不是一个字符串。\n    ```html\n    <!-- 例如， HTML： -->\n    <button onclick=\"activateLasers()\">\n    Activate Lasers\n    </button>\n\n    <!-- 在 React 中略有不同： -->\n    <button onClick={activateLasers}>\n    Activate Lasers\n    </button>\n    ```\n2. 另一个区别是，在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。\n\n## React事件和原生事件的执行顺序，可以混用吗？\n\n### 执行顺序\nreact的所有事件都挂载在 document中，当真实dom触发后，冒泡到document，才会对react事件进行处理。所以原生的事件会先执行，然后执行 react合成事件，最后执行真正在 document上挂载的事件。\n\n### react事件和原生事件可以混用吗？\nreact事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation方法，则会导致其他 react事件失效。因为所有元素的事件将无法冒泡到 document上。所有的react事件都将无法被注册。\n\n\n## React的合成事件是什么？React事件如何解决跨浏览器兼容？\n- React 根据 W3C 规范定义了每个事件处理函数的参数，即合成事件。合成事件是围绕浏览器原生事件充当跨浏览器包装器的对象。它们将不同浏览器的行为合并为一个 API。这样做是为了确保事件在不同浏览器中显示一致的属性。\n\n- 事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。它具有与浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()，在所有浏览器中他们工作方式都相同。React合成的 SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。\n- 另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。\n\n\n## 为何React事件要自己绑定this？\n\nReact在 document上进行统一的事件分发，dispatchEvent 通过循环调用所有层级的事件来模拟事件冒泡和捕获。\n在 React源码中，当具体到某一事件处理函数将要调用时，将调用 invokeGuardedCallback方法。\n```js\nfunction invokeGuardedCallback(name, func, a) {\n    try {\n        func(a);\n    } catch (x) {\n        if (caughtError === null) {\n            caughtError = x;\n        }\n    }\n}\n```\n可见，**事件处理函数作为回调函数是直接调用的**，并没有指定调用的组件，所以不进行手动绑定的情况下this会回退到默认绑定，所以我们需要手动将当前组件绑定到 this上。\n\n参考传送门：[为什么需要处理react类组件的this绑定问题](./react/react-handle-this.html#一、为什么需要处理react类组件的this绑定问题)\n\n\n## 参考链接\n\n[【React深入】React事件机制](https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247484039&idx=1&sn=1f657356676d4809633f30668acb50d2&chksm=ce6ec62bf9194f3d8a4eb382bd01c56231908a1b08fb9c2c9783f96df6650ee808fe18343032&scene=21#wechat_redirect)\n"},{"title":"react类组件中处理this绑定的4种方法","url":"/Roundtables/Question-Bank/react/react-handle-this.html","content":"---\ntitle: react类组件中处理this绑定的4种方法\ntags: [类组件, this指向问题, 箭头函数, bind]\ncategories: react\n---\n\n# react类组件中处理this绑定的4种方法\n\n## 一、为什么需要处理react类组件的this绑定问题\n\n在 React 类组件中，由于`将事件处理函数`引用`作为回调传递`后，事件处理程序方法**会丢失其隐式绑定的上下文**，导致 this 值会回退到默认绑定，变成 undefined。示例如下：\n```html\n<button type=\"button\" onClick={this.handleClick}>\n    Click Me\n</button>\n```\n有人可能会问：既然是依据“默认绑定规则”，不应该指向全局对象window或global吗？\n\n这是因为，类声明和类表达式的主体（构造函数、静态方法和原型方法）以 `严格模式` 执行。在严格模式下，默认绑定this会指向undefined。\n\n## 二、处理this绑定的4种方法\n\n*忽略被废弃React.createClass的情形。只讨论使用React.Component创建的类组件this绑定：*\n\n### 1. **render方法中使用bind**\n\n在事件函数后使用.bind(this)将this绑定到当前组件中。\n```js\nclass App extends React.Component {\n    handleClick() {\n        console.log('this > ', this);\n    }\n    render() {\n        return (\n            <div onClick={this.handleClick.bind(this)}>test</div>\n        )\n    }\n}\n```\n这种方法很简单，可能是大多数初学开发者在遇到问题后采用的一种方式。然后`由于组件每次执行render将会重新分配函数`这将会`影响性能`。特别是在你做了一些性能优化之后，它会破坏PureComponent性能。*不推荐使用*。\n\n### 2. **render方法中使用箭头函数**\n\n这种方法使用了ES6的上下文绑定来让this指向当前组件，但是它同第1种存在着相同的性能问题，不推荐使用。\n```js\nclass App extends React.Component {\n    handleClick() {\n        console.log('this > ', this);\n    }\n    render() {\n        return (\n        <div onClick={e => this.handleClick(e)}>test</div>\n        )\n    }\n}\n```\n\n### 3. **构造函数中bind**\n\n为了避免在render中绑定this引发可能的性能问题，可以在constructor中预先进行绑定。\n\n但这种方式有较多的重复代码，比较繁琐。\n```js\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.handleClick = this.handleClick.bind(this);\n    }\n    handleClick() {\n        console.log('this > ', this);\n    }\n    render() {\n        return (\n        <div onClick={this.handleClick}>test</div>\n        )\n    }\n}\n```\n\n### 4. **在定义阶段使用箭头函数绑定（`最佳实践`）**\n\n推荐 ECMA stage-2 所提供的箭头函数绑定。要使用这个功能，需要在.babelrc中开启stage-2功能，绑定方法如下：\n```js\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    handleClick = () => {\n        console.log('this > ', this);\n    }\n    render() {\n        return (\n        <div onClick={this.handleClick}>test</div>\n        )\n    }\n}\n```\n如果你使用ES6和React 16以上的版本，**最佳实践**是使用这种方法来绑定this。\n\n**优势**：\n- 它避免了第1种、第2种方法可能潜在的性能问题。\n- 它避免了第3种绑定时的繁琐重复代码。\n- 箭头函数会自动绑定到当前组件的作用域中，不会被call改变。\n\n\n参考链接：[React.js绑定this的5种方法](https://juejin.im/post/5b13c3a16fb9a01e75462a64)\n"},{"title":"React Hooks 概述","url":"/Roundtables/Question-Bank/react/react-hooks.html","content":"# React Hooks 概述\n\nHooks本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。\n\n这些hooks的目标就是让你不再写class，让function一统江湖。\n\n钩子 | 用法 | 作用\n|:-- |:-- |:-- |\nuseState | const [state, changeState] = useState(initialValue) | 用于生成状态以及改变状态的方法\nuseEffect | useEffect(fn, [...relativeState]) | 用于生成与状态绑定的副作用\nuseContext | useContext(MyContext) | 用于接收context对象并返回当前值\nuseReducer | const [state, dispatch] = useReducer(reducer, initialArg, init) | useState的变体，类似于redux\nuseCallback | useCallback(fn, [...relativeState]) | 用于生成与状态绑定的回调函数\nuseMemo | useMemo(fn, [...relativeState]) | 用于生成与状态绑定的组件/计算结果\nuseRef | const newRef = useRef(initialValue) | 用于 获取节点实例 / 数据保存\n\n## 为什么要搞一个Hooks\n### 1、复用一个有状态的组件太麻烦\n\nclass的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。官方推荐怎么解决这个问题呢？答案是：**渲染属性（Render Props）** 和 **高阶组件（Higher-Order Components）**。\n\n以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的 React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看你的组件层级嵌套是不是很夸张吧。但使用 hooks，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。\n\n### 2、生命周期钩子函数里的逻辑太乱\n我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情，有时候在不同的钩子中还会写同样的事情。\n\n### 3、class 的使用让人困惑\n绑定this的指向问题很麻烦，而无状态function组件由于需求变动需要有自己的state时，还需要将function组件改成class组件，很麻烦。\n\n## useState\n```jsx\nimport { useState } from 'React';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。\n\n数组解构实际上是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。\n```js\nlet _useState = useState(0);\nlet count = _useState[0];\nlet setCount = _useState[1];\n```\n\n### 如何记住之前的状态\n> function component 本质上也是一个普通的函数，而普通函数中声明的变量，当函数运行完成后，变量就销毁了（不考虑闭包等情况），那为什么它可以记住之前的状态呢？\n\nReact是通过 类似单链表形式的memoizedStates变量，通过 next 按顺序串联所有的 hook的：\n```js\ntype Hooks = {\n\tmemoizedState: any, // 指向当前渲染节点 Fiber\n  baseState: any, // 初始化 initialState， 已经每次 dispatch 之后 newState\n  baseUpdate: Update<any> | null,// 当前需要更新的 Update ，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯\n  queue: UpdateQueue<any> | null,// UpdateQueue 通过\n  next: Hook | null, // link 到下一个 hooks，通过 next 串联每一 hooks\n}\n \ntype Effect = {\n  tag: HookEffectTag, // effectTag 标记当前 hook 作用在 life-cycles 的哪一个阶段\n  create: () => mixed, // 初始化 callback\n  destroy: (() => mixed) | null, // 卸载 callback\n  deps: Array<mixed> | null,\n  next: Effect, // 同上 \n};\n```\n\nuseState是可以多次调用的，useState接收的初始值既可以是简单数据类型，也可以接收对象或者数组作为参数：\n```js\nfunction ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n}\n```\n\n::: danger 注意：状态更新方式的不同\n**this.setState()**做的是**合并**状态后返回一个新状态，而**useState**是直接**替换**老状态后返回新状态。\n:::\n\nhook的“形态”类似被否定掉的Mixins方案：都是提供一种「插拔式的功能注入」的能力。而mixins之所以被否定，是因为Mixins机制是**让多个Mixins共享一个对象的数据空间**，这样就**很难确保不同Mixins依赖的状态不发生冲突**。但Hook是使用在function中的，且每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性。\n\n\n### React是怎么保证多个useState的相互独立的？\n\nReact当中使用 memoizedStates数组，来解决 Hooks 的复用问题。\n- 初次渲染时，React根据useState出现的顺序，依次将相互独立的state收集到memoizedStates当中，保证多个useState间的相互独立。\n- 更新的时候，按照顺序，从 memoizedStates 中把上次记录的值拿出来。因此，React规定我们**必须把hooks写在函数的最外层**，**不要写在循环、条件语句当中，也不要在子函数中调用**，从而确保hooks的执行顺序一致（显然，memoizedStates 数组是按 hook定义的顺序来放置数据的，如果 hook 顺序变化，memoizedStates 并不会感知到，就会错误匹配更新，造成错误）。\n也就是说，多个hook，共享同一个 memoizedStates，共享同一个状态顺序。\n\n*以上原理同样适用于 useEffect。*\n\n## useEffect\n\n### 什么是useEffect\n```js\nuseEffect(callback [, deps]);\n```\nuseEffect是用来处理副作用函数的。它以一抵三（componentDidMount、componentDidUpdate、componentWillUnmount），在使用中合理的做法是，给每一个副作用一个单独的useEffect钩子。关键点如下：\n1. **频率**：react的每次渲染，都会调用传给useEffect的副作用函数。\n2. **时机**：当react要渲染时，会先记住useState中的副作用函数，等react更新DOM之后，它才会依次地执行我们所定义的副作用函数。\n3. **异步**：useEffect中的副作用函数是异步执行的（不会阻碍浏览器更新视图），而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的（*但也有特殊情形，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生*）。\n\n### 副作用函数callback的执行次数\n副作用函数callback的执行有如下3种情况：\n1. 如果 deps 不存在，那么 callback 每次 render 都会执行；\n2. 如果 deps 存在，只有当它发生了变化，callback 才会执行；\n3. 如果 deps 为[]，则只在 首次render 后执行；\n\n#### 1、为什么不传deps时，副作用函数每次组件render都执行\n\n考虑在类组件的模式下，如果在副作用函数中依赖的状态改变后，就需要在 componentDidUpdate 中清除之前的注册，并重新注册。而useEffect每次组件更新后都会重新执行一遍，则不会有上述问题。\n::: details 副作用函数依赖改变，需componentDidUpdate清除注册和重新注册\n```js\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  // 比如 props.friend.id 改变了，就需要：\n  componentDidUpdate(prevProps) {\n    // 先把上一个friend.id解绑\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevProps.friend.id,\n      this.handleStatusChange\n    );\n    // 再重新注册新但friend.id\n    ChatAPI.subscribeToFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(\n      this.props.friend.id,\n      this.handleStatusChange\n    );\n  }\n```\n:::\n\n\n#### 2、跳过副作用函数\nuseEffect的第二个参数deps依赖列表，**只有当deps的值发生`改变`时**，才执行我们传的副作用函数（第一个参数）。\n```js\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句\n```\n\n#### 3、只在首次渲染执行一次\n当第二个参数传**空数组[]**时，则相当于只有`componentDidMount`，副作用函数**只在首次渲染的时候执行**。这是因为deps依赖列表一直不变化，callback 不会二次执行。（*不过这种用法可能带来bug，少用*）。\n\n\n### useEffect解绑副作用\n- 场景：避免内存泄漏，在componentDidMount注册，就需要在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册。\n- 方法：使useEffect的副作用函数A返回一个清理函数B即可。\n    ```js\n    useEffect(() => {\n        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n        // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup\n        return function cleanup() {\n            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n        };\n    });\n    ```\n- 注意：\n    1. 返回的这个清理函数B，将会在组件下一次重新渲染之后，在副作用函数A之前执行；\n    2. 与componentWillUnmount只会在组件销毁前执行一次不同的是，副作用函数A及其可选的清理函数B在每次组件渲染都会执行。\n\n\n### 自定义的 Effect Hooks\n\n所谓的自定义hook，就是把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用，就插进哪个组件里。\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n```\n```jsx\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\n\n## useContext\n```js\nconst value = useContext(MyContext);\n```\n- useContext(MyContext) 相当于 class 组件中的 `static contextType = MyContext` 或者 `<MyContext.Consumer>`。\n- 接收一个 context 对象（React.createContext 的返回值），并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `<MyContext.Provider>` 的 value prop 决定。\n- useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 `<MyContext.Provider>` 来为下层组件提供 context。\n- 当组件上层最近的 `<MyContext.Provider> `更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。\n\n## useReducer\nuseReducer 类似于 redux 中的功能，相较于 useState，它**更适合一些逻辑较复杂且包含多个子值**，**或者下一个 state 依赖于之前的 state** 等等的特定场景，useReducer 总共有三个参数：\n```js\nconst [state, dispatch] = useReducer(reducer, initialArg, init);\n```\n- 第一个参数是 一个 **reducer**，就是一个函数类似 `(state, action) => newState` 的函数，传入 上一个 state 和本次的 action；\n- 第二个参数是 **初始state**，也就是默认值，是比较简单的方法；\n- 第三个参数是 **惰性初始化**，这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为对重置 state 的 action 做处理提供了便利。\n\n```jsx\nfunction init(initialCount) {\n  return {count: initialCount};\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case 'decrement':\n      return {count: state.count - 1};\n    case 'reset':\n      return init(action.payload);\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter({initialCount}) {\n  const [state, dispatch] = useReducer(reducer, initialCount, init);\n  return (\n    <>\n      Count: {state.count}\n      <button\n        onClick={() => dispatch({type: 'reset', payload: initialCount})}>\n        Reset\n      </button>\n      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n    </>\n  );\n}\n```\n\n## useCallback\n```js\nconst memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);\n```\n返回一个 **memoized 回调函数**。`useCallback(fn, deps) 相当于 useMemo(() => fn, deps)`。\n\n- 用于对不同 useEffect 中存在的相同逻辑的封装，减少代码冗余，配合 useEffect 使用。\n- 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。\n\n::: tip useMemo与useCallback的唯一区别\nuseMemo 和 useCallback 几乎是99%相似的，`useCallback(fn, deps) 相当于 useMemo(() => fn, deps)`。\n\n他们的唯一区别就是：**useCallback是根据依赖(deps)缓存第一个入参的(callback)。useMemo是根据依赖(deps)缓存第一个入参(callback)执行后的值**。\n:::\n\n## useMemo\n```js\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n返回一个 **memoized 值**。\n\n- 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。\n- 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。\n\n::: danger useMemo不要包含副作用\n记住，传入 useMemo 的函数会在**渲染期间执行**，这与useEffect在渲染之后执行不同。因此，不要在 useMemo 内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。\n:::\n\n## useRef\n```js\nconst refContainer = useRef(initialValue);\n```\n- useRef 返回一个 **可变的 ref 对象**，其 **.current** 属性被初始化为传入的参数（initialValue）。本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。\n- 返回的 ref 对象在组件的整个生命周期内保持不变。\n- 使用场景：\n    - 可以用于 DOM refs。\n    ```jsx\n    function TextInputWithFocusButton() {\n        const inputEl = useRef(null);\n        const onButtonClick = () => {\n            // `current` 指向已挂载到 DOM 上的文本输入元素\n            inputEl.current.focus();\n        };\n        return (\n            <>\n                <input ref={inputEl} type=\"text\" />\n                <button onClick={onButtonClick}>Focus the input</button>\n            </>\n        );\n    }\n    ```\n    - 一个属性容器，类似于 class 的实例属性，ref 对象是一个 current 属性可变且可以容纳任意值的通用容器。\n    ```jsx\n    function Timer() {\n        const intervalRef = useRef();\n\n        useEffect(() => {\n            const id = setInterval(() => {\n                // ...\n            });\n\n            intervalRef.current = id;\n            return () => {\n                clearInterval(intervalRef.current);\n            };\n        });\n\n        // ...\n    }\n    ```\n\n\n## 参考链接：\n- [30分钟精通React Hooks](https://juejin.im/post/5be3ea136fb9a049f9121014#heading-6)\n- [React Hooks 原理](https://github.com/brickspert/blog/issues/26)\n"},{"title":"React未归类知识点补充","url":"/Roundtables/Question-Bank/react/react-other-points.html","content":"# React未归类知识点补充\n\n## 什么叫做react「单向数据流」？\n\n**“自上而下数据流”或是“单向数据流”**：即规范了数据的流向——由外层组件向内层组件进行传递和更新。任何的 state 总是所属于特定的组件，该组件只能通过props将数据状态state传递给子组件，不能由子组件向父组件传递数据，不能向上修改父组件的数据，也不能在自身组件中修改props的值。\n\nReact的编程思想是严谨且周密的，它约束了我们的花式操作，使应用中的数据流更加清晰易懂，确保我们在使用react构建复杂项目的时候不会出现太多问题。\n\n另外，Vue在不同组件间也是强制使用“单向数据流”的。React、Vue都是单向数据流的框架。\n\n### 为什么要限定 单向数据流？\n\n几乎所有框架都是通过props往内层组件传参(props本质是函数执行的参数)，我们先考虑下函数传参的情形：\n- 当往一个函数内传递复杂数据类型（对象参数），如果在这个函数里修改了这个对象，那么函数外的对象也是会随着改动的(因为本质是一个内存里的东西)；\n- 类比到react当中组件间的数据传递，父组件的数据通过props传递给子组件，而子组件里更新了props，导致父组件更新。毫无疑问，这是会 **导致数据紊乱的、不可控的**操作。\n因此绝大多数框架在这方面做了处理。\n\n当然，除了使用props一层层往下传，react还提供了`context`，方便进行组件间的隔代通信，但react官方并不提倡使用。\n\n###  如何在react中实现逆向通信？（子组件向父组件方向通信）\n\n通过在父组件中定义方法，通过props参数将该方法传递给子组件，子组件调用这个方法并且把自己的data作为参数，那么父函数就可以通过形参拿到了子组件传来的data了。这样的逆向通信，实际`也是符合单向数据流`的概念，无非就是把函数当做参数传递下去而已。\n\n另外，除开上面的 **\"父组件中定义函数传递给子组件并被其调用\"**，还可以使用 Refs，父组件也可以轻松拿到子组件的所有属性和方法。\n\n\n参考链接：[React精讲(一):单向数据流](https://www.bbsmax.com/A/Vx5MvM1LdN/)\n\n\n## react官方为什么不实现双向绑定？react中如何实现双向绑定？\n\n传送门：[双向绑定原理](/Question-Bank/MVVM/mvvm-base.html#双向绑定原理)\n\nReact的目标从来不是“让开发者写更少的代码”，而是让“代码结构更加清晰易于维护”，因此官方一直提倡`单向数据流的思想`，`推崇函数式，摈弃副作用`，所以没有实现双向绑定。\n\nReact的工作逻辑是：state变化就会执行render，这时需要你自己处理数据结构，完成绑定，更自由地渲染view。而view value的变化除了自己监听view事件，没有其他方式能够捕获这个变化了，因此，如果要react要实现双向绑定，只能在view上监听你需要的事件（绑定onChange事件），自由的决定要不要更新state，更新哪些state（通过setState()方法），此时就形成了闭环，state变化了又是新一轮的render。\n\n## 什么是react组件的状态提升（Lifting State Up）\n\n在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。当多个组件需要反映相同的数据源变化时，建议将共享状态提升到最近的共同父组件中去。形成「自上而下的数据流」。\n\n## React 中的 Fragment\n在React中，render()函数中返回的所有元素需要包裹在一个\"根\"元素里面，以前我们选择用一个`<div>`来包裹，但这回添加无意义的额外标签，而`React.Fragment组件`能够**在不额外创建 DOM 元素的情况下，让 render() 方法中返回多个元素**：\n```jsx\nrender() {\n  return (\n    <React.Fragment>\n      Some text.\n      <h2>A heading</h2>\n    </React.Fragment>\n  );\n}\n```\n也可以使用其**简写语法** `<></>`。\n\n## 简述react-redux中的Provider和connect的作用？\n\nReact-Redux 将所有组件分成两大类：UI组件（纯组件，没有状态，只由props参数提供数据）和容器组件（管理数据和处理业务逻辑，有内部状态）。\n\n使用Redux和React应用连接时，需要使用react-redux提供的Provider和connect：\n- connect：用于从 UI 组件生成容器组件，负责将store state注入容器组件，并选择特定状态作为容器组件props传递；\n    ```jsx\n    import { connect } from 'react-redux'\n\n    const ContainerComponent = connect(\n        mapStateToProps,\n        mapDispatchToProps\n    )(UIComponent)\n\n    ```\n- Provider：负责将Store注入React应用，让容器组件拿到state对象（它的原理是React的context属性）；\n    ```jsx\n    import { Provider } from 'react-redux'\n    import { createStore } from 'redux'\n    import todoApp from './reducers'\n    import App from './components/App'\n\n    let store = createStore(todoApp);\n\n    render(\n        <Provider store={store}>\n            <App />\n        </Provider>,\n    document.getElementById('root')\n    )\n    ```\n\n对于Mobx而言，同样需要两个步骤：\n- Provider：使用mobx-react提供的Provider将所有stores注入应用；\n- 使用inject将特定store注入某组件，store可以传递状态或action；然后使用observer保证组件能响应store中的可观察对象（observable）变更，即store更新，组件视图响应式更新。\n\n\n## Context对象\n\nContext 是解决react自上到下通过组件传递数据时，跨组件传递非常麻烦不便的问题。Context 可以让我们无须明确地传遍每一个组件，就能将值“广播式”地深入传递进组件树。\n\n新版本ContextAPI：React.createContext、Context.Provider、Class.contextType、Context.Consumer、Context.displayName。\n\n- **React.createContext**：创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。\n    ```jsx\n    const MyContext = React.createContext(defaultValue);\n    ```\n- **Context.Provider**\n    ```jsx\n    <MyContext.Provider value={/* 某个值 */}>\n    ```\n- **Class.contextType**：挂载在 class 上的 contextType 属性是一个`静态属性`，会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\n    ```jsx\n    class MyClass extends React.Component {\n        componentDidMount() {\n            let value = this.context;\n            /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */\n        }\n        componentDidUpdate() {\n            let value = this.context;\n            /* ... */\n        }\n        componentWillUnmount() {\n            let value = this.context;\n            /* ... */\n        }\n        render() {\n            let value = this.context;\n            /* 基于 MyContext 组件的值进行渲染 */\n        }\n    }\n    MyClass.contextType = MyContext;\n\n    // -------------- 分割线 -----------------------------\n\n    // 如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。\n    class MyClass extends React.Component {\n        static contextType = MyContext;\n        render() {\n            let value = this.context;\n            /* 基于这个值进行渲染工作 */\n            return (\n              <div>{value}</div>\n            )\n        }\n    }\n    ```\n- **Context.Consumer**：在类组件与函数式组件中都可以通过 Consumer 订阅 context，但这需要`函数作为子元素（function as a child）`。这个函数接收当前的 context 值，返回一个 React 节点。\n    ```jsx\n    <MyContext.Consumer>\n      { value => /* 基于 context 值进行渲染*/ }\n    </MyContext.Consumer>\n    ```\n- **Context.displayName**：context 对象接受一个名为 displayName 的 property，类型为字符串。React **DevTools** 使用该字符串来确定 context 要显示的内容。\n    ```jsx\n    const MyContext = React.createContext(/* some value */);\n    MyContext.displayName = 'MyDisplayName';\n    ```\n\n使用示例：\n```jsx\n// 为当前的 theme 创建一个 context（“light”为默认值）。\nconst ThemeContext = React.createContext('light');\n\nclass App extends React.Component {\n  render() {\n    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n    // 无论多深，任何组件都能读取这个值。\n    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\n\n// 中间的组件再也不必指明往下传递 theme 了。\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nclass ThemedButton extends React.Component {\n  // 挂载在 class 上的 contextType 属性会被重赋值为被创建的 Context 对象。\n  // 这能让你使用 this.context 来消费最近的 Context.Provider。你可以在任何生命周期中访问到它的值，\n  // 在这个例子中，当前的 theme 值为 “dark”。\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context} />;\n  }\n}\n```\n\n### 三种Context的用法比较\n\n分类 | 特点\n|:--|:--|\nconsumer |\t嵌套复杂，Consumer 第一个子节点必须为一个函数，无形增加了工作量\ncontextType |\t只支持 类组件，无法在多 context 的情况下使用\nuseContext | 一种hooks，不需要嵌套，多 context 写法简单\n```jsx\n// 创建一个 context\nconst Context = createContext(0)\n\n// 组件一, Consumer 写法\nclass Item1 extends PureComponent {\n  render () {\n    return (\n      <Context.Consumer>\n        {\n          (count) => (<div>{count}</div>)\n        }\n      </Context.Consumer>\n    )\n  }\n}\n// 组件二, contextType 写法\nclass Item2 extends PureComponent {\n  static contextType = Context\n  render () {\n    const count = this.context\n    return (\n      <div>{count}</div>\n    )\n  }\n}\n// 组件一, useContext 写法\nfunction Item3 () {\n  const count = useContext(Context);\n  return (\n    <div>{ count }</div>\n  )\n}\n\nfunction App () {\n  const [ count, setCount ] = useState(0)\n  return (\n    <div>\n      点击次数: { count } \n      <button onClick={() => { setCount(count + 1)}}>点我</button>\n      <Context.Provider value={count}>\n        <Item1></Item1>\n        <Item2></Item2>\n        <Item3></Item3>\n      </Context.Provider>\n    </div>\n    )\n}\n```\n\n## react@16.6种的memo方法是做什么的？\n\nReact.memo：\n- React.memo 作为性能优化的高阶组件。只适用于函数组件，但不适用于 class 组件。\n- 说白了 memo 就是函数组件的 PureComponent，用来做性能优化的手段。\n- 包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。\n- 默认情况下其只会对复杂对象做浅层对比，可通过第二个判断函数自定义。\n```jsx\nfunction MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n```\n\n## react@16.6中的lazy方法是做什么的？\n\nReact.lazy：\nReact.lazy 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。\n```jsx\nimport React, { Suspense } from 'react';\n\n// 这个组件是动态加载的\nconst OtherComponent = React.lazy(() => import('./OtherComponent'));\n\nfunction MyComponent() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <OtherComponent />\n      </Suspense>\n    </div>\n  );\n}\n```\n渲染 lazy 组件依赖该组件渲染树上层的 `<React.Suspense>` 组件。这是指定加载指示器（loading indicator）的方式。可以将 Suspense 组件置于懒加载组件之上的任何位置。甚至可以用一个 Suspense 组件包裹多个懒加载组件\n\n### 代码分割路由组件\n```jsx\nimport React, { Suspense, lazy } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst Home = lazy(() => import('./routes/Home'));\nconst About = lazy(() => import('./routes/About'));\n\nconst App = () => (\n  <Router>\n    <Suspense fallback={<div>Loading...</div>}>\n      <Switch>\n        <Route exact path=\"/\" component={Home}/>\n        <Route path=\"/about\" component={About}/>\n      </Switch>\n    </Suspense>\n  </Router>\n);\n```\n"},{"title":"React中的代码复用（Render-Props、HOC）","url":"/Roundtables/Question-Bank/react/react-reuse.html","content":"# React中的代码复用（Render-Props、HOC）\n\n> 组件通常是针对一类对象来说的，有很多类具有相似的行为，但是他们确实属于不同的类别。如果用面向对象的思维考虑，应该设计公用类或者接口，使用继承类或继承接口来复用功能。\n\n> 继承类的坏处在于大量的继承会导致类之间的关系很复杂，继承接口的坏处在于子类需要实现接口的方法，调用也比较麻烦。\n\n> **“组合优于继承”**，可以考虑使用组合来解决问题。\n\nReact中有3种代码复用的方法：Mixin、`HOC`、`Render props`。\n\nReact Mixin将通用共享的方法包装成Mixins方法，然后注入各个组件实现，但Mixin已经不被官方推荐使用，所以本文只重点介绍**高阶组件**和**渲染属性**。\n\n::: details Mixin为何被官网废弃\n1. Mixin引入了隐式依赖关系。\n2. Mixin导致名称冲突。\n3. Mixin导致复杂的滚雪球：随着时间和业务的增长， 你对Mixin的修改越来越多， 到最后会变成一个难以维护的Mixin。\n4. 拥抱ES6，ES6的class不支持Mixin。\n:::\n\n## 高阶组件 (HOC)\n\n- 高阶组件是**重用组件逻辑**的高级方法，其实只是一个装饰器模式，用于增强原有组件的功能。\n- 高阶组件其实并不是组件，它只是一个函数接收一个组件作为参数，经过增加一系列新功能后，返回一个新的组件。这样返回的组件增强了功能，但渲染与原有保持一致，没有破坏原有组件的逻辑。\n\n```tsx\nconst withUser = WrappedComponent => {\n  const user = sessionStorage.getItem(\"user\");\n  return props => <WrappedComponent user={user} {...props} />;\n};\n\nconst UserPage = props => (\n  <div class=\"user-container\">\n    <p>My name is {props.user}!</p>\n  </div>\n);\n\nexport default withUser(UserPage);\n```\n\n## 渲染属性 (Render props)\n渲染属性（Render Props）也是一种在不重复代码的情况下共享组件间功能的方法。Render-Props 最重要的是`使用一个值为函数的prop来传递需要动态渲染的nodes或组件`，属性名不一定是非叫render，其它命名依然有效。\n```tsx\n// 子组件依赖于父组件的某些数据时，需要将父组件的数据传到子组件，子组件拿到数据并渲染\n<DataProvider render={data => (\n  <Cat target={data.target} />\n)}/>\n\n// Render Props，不是说非用一个叫render的props不可\n// 习惯上可能常写成下面这种\n<DataProvider>\n  {data => (\n    <Cat target={data.target} />\n  )}\n</DataProvider>\n```\n\n类（对于一类事物的抽象），接口（对于一类行为的抽象）。JS 里面没有接口，所以用高阶组件和 render props 都可以达到对同一类行为的抽象。所有的手段最终都是为了提高代码的可维护性，减少使用成本。\n\n## Render props VS HOC\n总的来说，render props其实和高阶组件类似，可相互替代，就是在`pure component`上增加state，响应react的生命周期。\n### 对于HOC模式\n- 优点如下：\n    - 支持ES6；\n    - 复用性强，HOC为纯函数且返回值为组件，可以多层嵌套；\n    - `支持传入多个参数`，增强了适用范围；\n- 缺点如下：\n    - 当多个HOC一起使用时，`无法直接判断`子组件的props是哪个HOC负责传递的；\n    - 多个组件嵌套，容易产生同样名称的props；\n    - HOC可能会产生许多无用的组件，加深了组件的层级；\n    - `静态构建`，需要提前构建好要使用的高阶组件。\n\n### Render Props模式的出现主要是为了解决HOC的问题\n优点如下所示：\n- 支持ES6；\n- 不用担心props命名问题，在render函数中只取需要的state；\n- 不会产生无用的组件加深层级；\n- render props是`动态构建`的，所有的改变都在render中触发，可以更好的利用组件内的生命周期。\n\n\n#### 参考链接\n\n[风满楼:React高阶组件和render props的适用场景有区别吗，还是更多的是个人偏好?](https://www.zhihu.com/question/269915942/answer/351688035)\n\n[React-代码复用(mixin.hoc.render props)](https://segmentfault.com/a/1190000018612397)\n\n[React组件Render Props VS HOC 设计模式](https://www.jianshu.com/p/ff6b3008820a)\n"},{"title":"React-Router使用关键点","url":"/Roundtables/Question-Bank/react/react-router-dom.html","content":"# React-Router使用关键点\n\n## Router路由器组件 (两种：BrowserRouter、HashRouter)\n`react-router-dom` 提供了和两种路由器组件（`<BrowserRouter>`，`<HashRouter>`）。前者基于url的pathname段，后者基于hash段。两种路由器组件都会创建一个history对象。\n\n如果我们的应用有服务器响应web的请求，我们通常使用`<BrowserRouter>`组件; 如果使用静态文件服务器，则我们应该使用`<HashRouter>`组件。\n\n基于React Router的web应用，根组件应该是一个Router组件（BrowserRouter，HashRouter）：\n```js\nimport { BrowserRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>,\n  document.getElementById('root')\n);\n```\n> **注意**：\n>> Router中只能有唯一的一个子元素（如上只有一个App）。\n\n## 路由匹配组件（Route、Switch）\n\n`react-router-dom` 中有两个匹配路由的组件: `<Route>` 和 `<Switch>`.\n\n### 无指定path总是渲染\n```tsx\n// 因为没有指定路径 ，所以总是能匹配，渲染Always组件\n<Route component={Always}/> \n```\n\n### Route组件的渲染方式（component、render、children 3种）\n\n三个路由属性：component、render、children。\n\n#### component\n\ncomponent 的值是一个组件，当 URL 和 Route 匹配时，Component属性定义的组件就会被渲染。例如：\n```tsx\n// 当 URL = \"http://example.com/foo\" 时，Foo组件会被渲染。\n<Route path='/foo' component={Foo} >\n```\n\n> **注意**：\n>> 不要将component属性设置为一个函数，然后在其内部渲染组件。这样会*导致已经存在的组件被卸载，然后重新创建一个新组件，而不是仅仅对组件进行更新*。\n\n#### render\nrender 的值是一个函数，这个函数返回一个 React 元素。这种方式方便地为待渲染的组件传递额外的属性。例如：\n```tsx\n// Foo 组件接收了一个额外的 data 属性。\n<Route path='/foo' render={(props) => {\n  <Foo {...props} data={extraProps} />\n}}>\n</Route>\n```\n\n#### children\nchildren 与render类似，也是一个函数，函数返回要渲染的 React 元素。\n\n> 不同之处:\n>> 与前两种方式不同之处是，**无论是否匹配成功**， children 返回的组件**都会被渲染**，但当匹配不成功时，match 属性为 null，这意为着可以据此作出UI上的调整。例如:\n```tsx\n// 如果 Route 匹配当前 URL，待渲染元素的根节点 div 的 class 将设置成 active.\n<Route path='/foo' render={(props) => {\n  <div className={props.match ? 'active': ''}>\n    <Foo {...props} data={extraProps} />\n  </div>\n}}>\n</Route>    \n```\n\n## Switch组件的作用（v4新增）\n\n- `<Switch>`是React-Router@v4 新增的路由匹配组件，只会渲染第一个被location匹配到的`<Route>`或者`<Redirect>`子元素路由；\n- 在`v4`之前，没有`<Switch>`提供包裹，通常用一个`<div>`包裹一打`<Route>s`，这种情况下会将匹配到的所有子路由都渲染出来，这也是react的设计需要（便于构建sidebars 和 breadcrumbs，bootstrap tabs...）；\n- `<Switch>`是唯一的因为它仅仅只会渲染一个路径。相比之下（不使用`<Switch>`包裹的情况下），每一个被location匹配到的`<Route>`将都会被渲染。\n\n### 通配符\n```tsx\n<Route path=\"/hello/:name\">\n// 匹配 /hello/michael 和 /hello/ryan\n\n<Route path=\"/hello(/:name)\">\n// 匹配 /hello, /hello/michael 和 /hello/ryan\n\n<Route path=\"/files/*.*\">\n// 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg\n```\n\n### Switch配合`exact`精确匹配\n- 不使用**exact**时，Switch会从前往后顺序匹配，有可能先匹配到非预期的路由，所以为了达到预期，需要调整路由的前后顺序。\n```tsx\n// 当url是/about\n<Switch>\n    <Route path=\"/\" component={Home} />\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/contact\" component={Contact} />\n    <Route component={NoMatch} />\n</Switch>\n// 会先匹配到Home组件，因为path='/'先与path='/about'匹配到\n```\n- 使用**exact**后，只有path属性进行精确比对后完全相同该`<Route>`才会被渲染。\n```tsx\n// 当url是/about\n<Switch>\n    <Route exact path=\"/\" component={Home} /> // 当浏览器地址严格是 / 时，渲染Home组件\n    <Route path=\"/about\" component={About} /> // 当浏览器地址是 /about 时，渲染About组件\n    <Route path=\"/contact\" component={Contact} /> // 当浏览器地址是 /contact 时，渲染contact组件\n    <Route component={NoMatch} /> // 没有指定路径，那就选他作为匹配的路由规则，NoMatch组件\n</Switch>\n// 只会严格匹配到 path='/about'的 About组件\n```\n\n## 导航组件（Link、NavLink、Redirect）\n\n### Link\nReact Router提供了一个组件用来在应用中添加link。当`<Link>`渲染时，一个`<a>`标签在html页面中被创建出来。\n```tsx\n<Link to=\"/\">Home</Link>\n// <a href='/'>Home</a>\n```\n\n### NavLink\n`<NavLink>`组件是一个特殊的`<Link>`组件。当它的path与当前location匹配时，可以自定义其样式。\n```tsx\n// location = { pathname: '/react' }\n<NavLink to=\"/react\" activeClassName=\"hurray\">\n  React\n</NavLink>\n// <a href='/react' className='hurray'>React</a>\n```\n\n### Redirect\n当需要页面重定向时，我们可以使用`<Redirect>`组件。当一个`<Redirect>`组件被渲染时，页面将被渲染到`<Redirect>`组件的to属性指定的位置上。\n```tsx\n<Route exact path=\"/\" render={() => (\n  loggedIn ? (\n    <Redirect to=\"/dashboard\"/>\n  ) : (\n    <PublicHomePage/>\n  )\n)}/>\n```\n\n## React-Router与常规路由有何不同\n主题    |   常规路由   |    React 路由\n|:-------------|:-------------|:-----|\n参与 页面  |每个视图对应一个新文件 |只涉及单个HTML页面\nURL 更改    |发送HTTP请求到服务器并且接收相应的HTML页面    |仅更改历史记录属性\n用户 体验    |用户实际在每个视图的不同页面切换，页面跳转刷新   |用户认为自己正在不同的页面间切换，页面无刷新\n\n"},{"title":"React虚拟DOM相关","url":"/Roundtables/Question-Bank/react/react-virtual-dom.html","content":"# React虚拟DOM相关\n\n## 虚拟Dom是什么\n![](./images/react-VDOM.png)\n\n- 在原生的 JS中，我们直接对 DOM进行创建和更改，而 DOM元素通过我们监听的事件和我们的应用程序进行通讯。\n- 而 React会先将代码转换成一个 JS对象（即虚拟DOM），然后这个 JS对象再转换成真实 DOM。\n- 虚拟DOM只不过是真实 DOM 的 JS对象表示。当我们需要创建或更新元素时，React首先会让这个 Vitrual Dom对象进行创建和更改，然后再将 Vitrual Dom对象渲染成真实DOM。当我们需要对 DOM进行事件监听时，首先对 Vitrual Dom进行事件监听，Vitrual Dom 会代理原生的 DOM事件从而做出响应。\n\n## 虚拟Dom原理\n\n- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；\n- diff 算法 — 比较两棵虚拟 DOM 树的差异；\n- pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。\n\n## 简述react diffing算法思路\n\n传统的diff算法，是通过循环递归对节点进行依次对比，算法复杂度达到 `O(n^3) `，n是树的节点数，效率极低！而 React diff算法是一种`调和`实现，即将Virtual DOM树转换成最少操作的actual DOM树。\n\nReact 通过 **三大策略** 进行优化，将`O(n^3)复杂度 转化为 O(n)复杂度`:\n\n1. 策略一（**tree diff**）：两棵树 只对同层次节点 进行比较。Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计（如果是跨层级的话，只有创建节点和删除节点的操作，不考虑其他）。\n2. 策略二（**component diff**）：\n    - 拥有相同类的两个组件 生成相似的树形结构，\n    - 拥有不同类的两个组件 生成不同的树形结构。\n3. 策略三（**element diff**）：对于同一层级的一组子节点，通过`唯一key`区分。\n\n## 虚拟Dom比普通Dom性能更好吗？(虚拟DOM优劣势)\n\n**Vitrual Dom 可以提升性能，这一说法实际上是很片面的。**\n\n- 首先，直接操作 DOM是非常耗费性能的，这一点毋庸置疑。但是 React/vue使用了 Vitrual Dom，VDOM也还是要操作 DOM，这是无法避免的。\n- 并且，如果是首次渲染的话，Vitrual Dom 甚至要进行更多的计算，消耗更多的内存。\n- Vitrual Dom 的「优势」在于：\n    1. **无需手动操作Dom**，提升开发效率：React/vue的 `Diff算法`和`批处理策略Patch` 会在一次更新中自动完成，不用开发者手动完成（*实际上，这个计算过程我们在直接操作 DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，所以，在这个过程中 React/vue帮助我们 \"提升了性能\"*）。\n    2. **保证性能下限**：第一点提到开发者实际是可以自己手动优化完成dom更新的，但这点依赖于开发者的水平，大部分情况下自己做的是不如 React/vue好的，所以VDOM保证了性能下限。\n    3. **跨平台**: DOM与平台强相关，而虚拟DOM本质上是JavaScript对象，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器渲染、移动端开发等等。\n- Vitrual Dom 的「缺点」只有一个：\n    1. **无法进行极致优化**: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优化。\n\n所以，**Vitrual Dom 帮助我们提高了开发效率**，在**重复渲染时它帮助我们计算如何更高效的更新**，`而不是它比 DOM操作更快`。\n\n## 虚拟Dom中的$$typeof属性的作用是什么？\n\nReactElement中有一个 `$$typeof`属性，它被赋值为 REACT_ELEMENT_TYPE：\n```js\nvar REACT_ELEMENT_TYPE =  (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||  0xeac7;\n```\n`$$typeof`是一个 Symbol类型的变量，这个变量可以防止 XSS。如果你的服务器有一个漏洞，允许用户存储任意 JSON对象，而客户端代码需要一个字符串，这可能会成为一个问题：\n```js\nlet expectedTextButGotJSON = {\n    type: 'div',\n    props: {\n        dangerouslySetInnerHTML: {\n            __html: '/* put your exploit here */'\n        },\n    },\n};\n\nlet message = { text: expectedTextButGotJSON };\n\n<p>{message.text}</p>\n```\nJSON中不能存储 Symbol类型的变量。\n\nReactElement.isValidElement函数用来判断一个 React组件是否是有效的，下面是它的具体实现：\n```js\nReactElement.isValidElement = function(object) {\n  return (\n    typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n```\nReact渲染时会把没有 `$$typeof`标识，以及规则校验不通过的组件过滤掉。当你的环境不支持 Symbol时，$$typeof被赋值为 0xeac7，至于为什么，React开发者给出了答案：0xeac7看起来有点像 React。\n\n\n\n\n\n"},{"title":"React Refs相关","url":"/Roundtables/Question-Bank/react/refs.html","content":"# React Refs相关\n\n## ref主要用于\n1. **获取对dom的引用**，用以操作dom、执行动画以及调用适配第三方库等；\n2. **访问类组件实例**，直接调用一些组件实例方法。\n\n**注意**：*但是不要过度使用ref。很多可以通过合理定义state所在组件层级，来用组件方式解决的情况，避免用ref。*\n\n## Refs 3种使用方式（字符串、回调refs、creatRef()）\n\n字符串、回调refs、creatRef() 这三种ref方法比较：\n\n### 1. 不要再使用字符串方式。\n\n因为string类型的refs存在一些问题，该方式**已被官方deprecate**了。使用模式是定义\"textInput\"名称，通过 this.refs.textInput 来访问 DOM 节点。\n\n### 2. 函数式回调refs\n\n回调refs **可以方便的监听组件、dom的销毁和重建**，在一些条件渲染中非常有用。但是使用很繁琐，需要定义函数，定义绑定实例变量。\n\n```tsx\nclass CustomTextInput extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.textInput = null;\n\n        this.setTextInputRef = element => {\n            this.textInput = element;\n        };\n\n        this.focusTextInput = () => {\n            // 使用原生 DOM API 使 text 输入框获得焦点\n            if (this.textInput) this.textInput.focus();\n        };\n    }\n\n    componentDidMount() {\n        // 组件挂载后，让文本框自动获得焦点\n        this.focusTextInput();\n    }\n\n    render() {\n        // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React\n        // 实例上（比如 this.textInput）\n        return (\n            <div>\n                <input type=\"text\" ref={this.setTextInputRef} />\n            </div>\n        );\n    }\n}\n```\n\n### 3. react16.3新增的createRef()方式\n\n- 使用**更加简洁**方便，但是**没有监听组件重建和销毁的能力**。\n- ref 的值根据节点的类型而有所不同：\n    - 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。\n    - 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。\n    - **你不能在函数组件上使用 ref 属性，因为他们没有实例**。\n- 注意要通过 \"current\" 来访问 DOM节点 或 类组件实例。\n    - DOM节点 绑定 ref\n    ```tsx\n    class CustomTextInput extends React.Component {\n        constructor(props) {\n            super(props);\n\n            // 创建一个 ref 来存储 textInput 的 DOM 元素\n            this.textInput = React.createRef();\n\n            this.focusTextInput = this.focusTextInput.bind(this);\n        }\n\n        focusTextInput() {\n            // 直接使用原生 API 使 text 输入框获得焦点\n            // 注意：我们通过 \"current\" 来访问 DOM 节点\n            this.textInput.current.focus();\n        }\n\n        render() {\n            // 告诉 React 我们想把 <input> ref 关联到\n            // 构造器里创建的 `textInput` 上\n            return (\n                <div>\n                    <input type=\"text\" ref={this.textInput} />\n                </div>\n            );\n        }\n    }\n    ```\n    - 类组件 绑定 ref\n    ```tsx\n    // CustomTextInput必须是类组件，不能是函数组件\n    class AutoFocusTextInput extends React.Component {\n        constructor(props) {\n            super(props);\n            this.textInput = React.createRef();\n        }\n\n        componentDidMount() {\n            this.textInput.current.focusTextInput();\n        }\n\n        render() {\n            return (\n                <CustomTextInput ref={this.textInput} />\n            );\n        }\n    }\n    ```\n\n综上，应该根据具体需求选择 函数回调refs 与 createRef() 方式。\n\n## Refs 转发（forwardRef()）\n\n有一些场景下，我们在父组件中可能希望能访问子组件中的dom或者节点。`forwardRef` 就是用来**将父组件的ref传递给子组件**。这样我们在对该组件添加ref时，将可以直接获取到其内部的dom节点，或者任意我们希望对方能获取到的值！！\n\n在之前版本中，我们可以通过props将ref callback或者createRef实例传递给子组件方式来变相实现forawardRef效果（**本质上就是类似props回调传值**）。或者通过findDOMNode()来对指定的组件实例获取其渲染的dom节点。这种用法只能获取到dom引用。\n\n### 使用\n使用 `FancyButton` 的组件可以获取底层 `DOM节点 button的ref` ，并在必要时访问，就像其直接使用 DOM button 一样：\n```tsx\nconst FancyButton = React.forwardRef((props, ref) => (\n  <button ref={ref} className=\"FancyButton\">\n    {props.children}\n  </button>\n));\n\n// 你可以直接获取 DOM button 的 ref：\nconst ref = React.createRef();\n<FancyButton ref={ref}>Click me!</FancyButton>;\n```\n逐步解释：\n1. 通过调用 `React.createRef` 创建了一个 React `ref` 并将其赋值给 `ref` 变量。\n2. 通过指定 `ref` 为 **JSX属性**，将其向下传递给 `<FancyButton ref={ref}>`。\n3. React 传递 `ref` 给 `forwardRef` 内函数 `(props, ref) => ...`，作为其**第二个参数**。\n4. 向下转发该 `ref` 参数到 `<button ref={ref}>`，将其指定为 **JSX 属性**。\n5. 当 `ref` 挂载完成，`ref.current` 将指向 `<button> DOM节点`。\n\n### 在 高阶组件HOC 中转发ref\n\n注意**在高阶组件传递props的动作中，refs将不会透传下去**。`这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理`。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。\n\n此时，可以使用 **React.forwardRef** 明确地将 `refs作为常规prop属性传递给包裹组件`，`然后此ref就可以被挂载到被包裹的内部子组件上了`。\n```tsx\nfunction logProps(Component) {\n  class LogProps extends React.Component {\n    render() {\n      const {forwardedRef, ...rest} = this.props;\n\n      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref\n      return <Component ref={forwardedRef} {...rest} />;\n    }\n  }\n\n  // 注意 React.forwardRef 回调的第二个参数 “ref”。\n  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”\n  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。\n  return React.forwardRef((props, ref) => {\n    return <LogProps {...props} forwardedRef={ref} />;\n  });\n}\n```\n\n## 参考链接\n\n[Refs and the Dom](https://reactjs.org/docs/refs-and-the-dom.html)\n\n[Refs 转发](https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components)\n"},{"title":"setState的执行机制","url":"/Roundtables/Question-Bank/react/setState.html","content":"# setState的执行机制\n\n## setState是异步的么，为什么有时能有时又不能立即拿到更新结果?\n\n### **1、钩子函数和合成事件中**\n\n**React的生命周期和合成事件中，React仍然处于它的批处理更新机制中，这时无论调用多少次 setState，都不会立即执行更新**，而是将要更新的`state`存入`_pendingStateQueue`，将要更新的组件存入`dirtyComponent`。当上一次更新机制执行完毕，最顶层组件didmount后会将批处理标志设置为 false。这时将取出`dirtyComponent`中的组件以及 `_pendingStateQueue`中的`state`进行更新。**这样就可以确保组件不会被重新渲染多次。**\n```tsx\ncomponentDidMount() {\n    this.setState({\n        index: this.state.index + 1\n    })\n    \n    console.log('state', this.state.index);\n}\n```\n所以，如上面的代码，当我们在执行 setState后立即去获取 state，这时是获取不到更新后的 state的，因为处于React的批处理机制中，state被暂存起来，待批处理机制完成之后，统一进行更新。\n\n::: tip\n**setState本身并不是异步的，而是 React的批处理机制给人一种异步的假象**。\n:::\n\n\n### **2、异步代码和原生事件中**\n\n```tsx\n componentDidMount() {\n    setTimeout(() => {\n        console.log('调用setState');\n        this.setState({\n            index: this.state.index + 1\n        })\n        console.log('state', this.state.index);\n    }, 0);\n}\n ```\n如上面的代码，当我们在**异步代码中**调用 setState时，根据 JS的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，`这时 React的批处理机制已经走完`，批处理标志设被设置为 false，这时再调用 setState即可立即执行更新，拿到更新后的结果。\n\n在**原生事件中**调用 `setState并不会触发 React的批处理机制`，所以立即能拿到最新结果。\n\n### 最佳实践\nsetState的第二个参数接收一个函数，该函数会在 React的批处理机制完成之后调用，所以你想在调用 setState后立即获取更新后的值，请在该回调函数中获取。\n```tsx\nthis.setState(\n    {\n        index: this.state.index + 1\n    },\n    () => {\n        console.log(this.state.index);\n    }\n)\n```\n\n\n## 为什么有时连续多次setState只有一次生效？(state队列合并机制)\n\n### setState多次传入「对象」时，合并计算\n例如下面的代码，两次打印出的结果是相同的：\n```tsx\ncomponentDidMount() {\n    this.setState(\n        {\n            index: this.state.index + 1\n        },\n        () => {\n            console.log(this.state.index);\n        }\n    )\n    this.setState(\n        {\n            index: this.state.index + 1\n        },\n        () => {\n            console.log(this.state.index);\n        }\n    )\n}\n```\n原因就是 `React会将批处理机制中存储的多个setState进行合并`，类似于 `Object的 assign`，如果传入的是**对象，则会被合并成一次**，所以上面的代码两次打印的结果是相同的：\n```js\nObject.assign(  nextState,  {index: state.index+ 1},  {index: state.index+ 1})\n```\n\n### setState多次传入「函数」时，每次都立即计算\n注意，assign函数中对**函数做了特殊处理**，处理第一个参数传入的是函数，**函数的参数 preState是前一次合并后的结果**，所以计算结果是准确的：\n```tsx\ncomponentDidMount() {\n    this.setState(\n        (state, props) => ({\n            index: state.index + 1\n        }),\n        () => {\n            console.log(this.state.index);\n        }\n    )\n    this.setState(\n        (state, props) => ({\n            index: state.index + 1\n        }),\n        () => {\n            console.log(this.state.index);\n        }\n    )\n}\n```\n所以上面的代码两次打印的结果是不同的，第二次用的是第一次改变后的结果作为输入。\n\n### 最佳实践\n\nReact会对多次连续的 setState进行合并，如果你想立即使用上次 setState后的结果进行下一次 setState，可以让 setState 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。\n\n\n## 几个钩子函数中setState要点\n\n- 不推荐直接在 `componentDidMount`直接调用 setState。componentDidMount本身处于一次更新中，我们又调用了一次 setState，就会在未来再进行一次 render，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。\n    - 当然在 componentDidMount我们可以调用接口，再回调中去修改 state，这是正确的做法。\n    - 当state初始值依赖dom属性时，在 componentDidMount中 setState是无法避免的。\n- 在`componentWillUpdate`、`componentDidUpdate`这两个生命周期中不能调用 setState。会造成死循环，导致程序崩溃。\n\n## 参考链接\n\n[由实际问题探究setState的执行机制](https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&mid=2247483989&idx=1&sn=d78f889c6e1d7d57058c9c232b1a620e&chksm=ce6ec6f9f9194fef681c79ee869bf58d5413132c73496710b2eb32c859a2249a895c2ce8a7cd&scene=21#wechat_redirect)\n\n"},{"title":"编写时间打印组件","url":"/Roundtables/Question-Bank/react/time-console.html","content":"# 编写时间打印组件\n\n编写组件，要求打印“当前时间：HH时mm分ss秒”字符串，并且不断更新\n\n\n\n"},{"title":"编写react高阶组件实现时间显示组件随时间不断更新`<withClock/>`","url":"/Roundtables/Question-Bank/react/withClock.html","content":"# 编写react高阶组件实现时间显示组件随时间不断更新`<withClock/>`\n\n假设已知渲染指定时间的组件Timer：\n```js\n// 只渲染一次\n<Timer date={new Date()} /> \n// 时间不断刷新\nconst ClockTimer = withClock(Timer);\n<ClockTimer />\n```\n要求编写高阶组件withClock，使其可以根据当前时间变动不断刷新\n\n```js\n// index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport withClock from \"./withClock\";\n\nconst Timer = ({ date }) => <span>{date}</span>;\nconst ClockTimer = withClock(Timer);\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ClockTimer />\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n```\n\n```js\n// withClock.js\nimport React, { Component } from \"react\";\n\nexport default function withClock(WrappedComponent) {\n  return class extends Component {\n    state = {\n      time: new Date()\n    };\n\n    timeoutId = null;\n\n    componentDidMount() {\n      this.clockWalk();\n    }\n\n    clockWalk = () => {\n      this.timeoutId = setTimeout(() => {\n        this.setState({\n          time: new Date()\n        });\n        this.clockWalk();\n      }, 1000);\n    };\n\n    render() {\n      return <WrappedComponent date={`${this.state.time.toLocaleDateString()} ${this.state.time.toLocaleTimeString()}`} {...this.props} />;\n    }\n  };\n}\n```\n\n"},{"title":"使用正则验证给定字符串是否是中国居民身份证","url":"/Roundtables/Question-Bank/regular-expression/Chinese-ID-card.html","content":"# 使用正则验证给定字符串是否是中国居民身份证\n\n已知中国居民身份证为18位，其中第7-14位出生年月日期，其中年份为四位数字表示；最后一位校验数字可以是罗马数字X。\n要求根据以上条件，编写正则验证是否是符合19xx-20xx间出生的人的有效身份证，不符合该区间的出生日期判定为非法身份证。\n\n非法值示例：\n    110111308803052064\n    110111198820222064\n    110111198802362064\n    11011119890222064A\n\n```js\nfunction checkIdCard(str) {\n    var reg = /^\\d{6}(19|20)\\d{9}(X|\\d)$/;\n    if (reg.test(str)) {\n        console.log(str + \"  是合法身份证\");\n    } else {\n        console.log(\"非法身份证\");\n    }\n}\n\nconsole.log(checkIdCard(\"00000020990000000X\")); // 合法\nconsole.log(checkIdCard(\"11011119890222064A\")); // 非法\n```\n"},{"title":"使用正则判断给定的股票代码所属市场","url":"/Roundtables/Question-Bank/regular-expression/code-to-market.html","content":"# 使用正则判断给定的股票代码所属市场\n\n假设已知美股(US)股票代码为2到8位字母，港股(HK)为5位数字，沪深(A)为6位数字\n\n```js\nfunction witchMarket(symbol) {\n    var regUS = /^[a-zA-Z]{2,8}$/;\n    var regHK = /^\\d{5}$/;\n    var regA = /^[0-9]{6}$/;\n    if (regUS.test(symbol)) {\n        console.log(symbol + ': 美股')\n    } else if (regHK.test(symbol)) {\n        console.log(symbol + ': 港股')\n    } else if (regA.test(symbol)) {\n        console.log(symbol + ': A股')\n    } else {\n        console.log(symbol + ': 未知')\n    }\n}\n\nconsole.log(witchMarket('AAPL'))\nconsole.log(witchMarket('00600'))\nconsole.log(witchMarket('123456'))\n```\n"},{"title":"使用正则处理字符串","url":"/Roundtables/Question-Bank/regular-expression/handle-string.html","content":"# 使用正则处理字符串\n\n## 数字转成千分位制\n注意使用了`x(?=y)先行断言`与`(?:)非捕获括号`，以及`替换模式$n`：\n```js\nfunction toThousands(num) {\n    return (num || 0).toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,')\n}\n```\n\n## 去除字符串首尾空格trim\n```js\nString.prototype.trim = function() {\n    return this.replace(/(^\\s*)|(\\s*$)/g, '')\n}\n```\n\n## 输出字符串中所有字符的个数\n```js\nfunction countChar(str) {\n    let obj = {};\n    for (let i = 0; i < str.length; i++) {\n        if (!Obj[str.charAt(i)]) {\n            Obj[str.charAt(i)] = 1\n        } else {\n            Obj[str.charAt(i)]++\n        }\n    }\n}\n```\n\n\n"},{"title":"正则表达式基础","url":"/Roundtables/Question-Bank/regular-expression/reg-base.html","content":"---\ntitle: 正则表达式基础\ntags: [贪婪模式, 先行断言, 正向否定查找]\ncategories: regular-expression\n---\n\n# 正则表达式基础\n\n## 实例化正则对象\n```js\n// 字面量方式\nvar reg = /\\d/g;\n\n// 使用构造函数\nvar reg = new RegExp('\\\\d', 'g');\n```\n- **字面量方式**：把要写的正则放在两个//之间，其中//最后面的g是*高级搜索标志*。\n- **使用构造函数**：通过new一个RegExp，接受两个字符串参数。第一个是正则的内容，在\\d前面加上了一个\\是对\\d中的\\进行`转义（escaping）`，记住这个是必须的，有特殊的字符都需要转义。第二个参数是*高级搜索标志*。\n\n## Escaping转义\n\n如果需要使用`任何特殊字符`的字面值（例如，搜索字符'*'），你必须通过在它前面放一个`反斜杠来转义`它。\n\n## 元字符\n\n有特殊含义的非字母字符。\n\n### 直接量 元字符\n\n- **\\f**     换页符。\n- **\\n**     换行符。\n- **\\r**     回车符。\n- **\\t**     制表符。\n- **\\v**     垂直制表符。\n- **\\0**     匹配Null字符。\n- **\\/**     一个/直接量。\n- **\\\\**     一个\\直接量。\n- **\\.**     一个.直接量。\n- **\\***     一个*直接量。\n- **\\+**     一个+直接量。\n- **\\?**     一个?直接量。\n- **\\|**     一个|直接量。\n- **\\(**     一个(直接量。\n- **\\{**     一个{直接量。\n- **\\[**     一个[直接量。\n\n### 匹配类 元字符\n\n- **[]**    匹配类，匹配的时候匹配到[]其中一个即可：[0-9]表示0到9，[a-zA-Z]表示匹配所有的大小写字母。\n- **^** 反向类：[^9]表示除9之外的所有字符。\n\n### 预定义类 元字符\n\n- **.**   表示除换行符(\\n、\\r也包括回车符)之外的任何单个字符，等价于 [^\\r\\n]。\n- **d**   表示数字字符，等价于[0-9]。\n- **D**   表示非数字字符，等价于[^0-9]。\n- **s**   表示空白字符，等价于[\\t\\n\\x\\f\\r]。\n- **S**   表示空白字符，等价于[^\\t\\n\\x\\f\\r]。\n- **w**   表示单词字符(字母数字下划线)，等价于[a-zA-Z_0-9]。\n- **W**   表示单词字符(字母数字下划线)，等价于[^a-zA-Z_0-9]。\n\n### 边界类 元字符\n\n- **^...**  表示以...开始。\n- **...$**  表示以...结束。\n- **\\b**    表示单词边界。\n- **\\B**    表示非单词边界。\n\n### 量词 元字符\n\n- **?** 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。作为量词时有两种模式：\n    - 默认是`贪婪模式（匹配尽可能多的字符）`：/e?le?/ 匹配 \"angel\" 中的 'el'、\"angle\" 中的 'le' 以及 \"oslo' 中的 'l'。\n    - 如果**紧跟在任何量词 *、 +、? 或 {} 的后面**，将会使量词变为`非贪婪模式（匹配尽量少的字符）`：例如，对 \"123abc\" 使用 /\\d+/ 将会匹配 \"123\"，而使用 /\\d+?/ 则只会匹配到 \"1\"。\n- **+** 匹配前面一个表达式 1 次或者多次。等价于 {1,}。\n- **\\***    匹配前一个表达式 0 次或多次。等价于 {0,}。\n- {n} 表示出现n次。\n- {n,m} 表示出现n到m次。\n- {n,} 表示至少出现n次。\n\n### 分组 元字符\n\n- **(x)**   括号被称为`捕获括号`：会匹配 x 并且记住匹配项。记住的匹配项有可以使用在两种环节中：\n    - \\1、\\2、...、\\n 是用在正则表达式的`匹配环节`。\n        - 模式 `/(foo) (bar) \\1 \\2/`，可匹配\"foo bar foo bar\"。模式中的 \\1 和 \\2 表示被捕获括号匹配的子字符串，即 foo 和 bar。\n    - $1、$2、...、$n 是用在正则表达式的`替换环节`。\n        - 模式`'John Smith'.replace(/(\\w+)\\s(\\w+)/, \"$2, $1\")`可输出\"Smith, John\"。模式中的 $1 和 $2 表示被捕获括号匹配的子字符串，即 John 和 Smith，之后重新排列。\n- **(?:x)** 这种括号叫作`非捕获括号`：匹配 x 但是不记住该匹配项。\n- x|y 匹配 x 或者 y 。\n- **x(?=y)**    `先行断言`：匹配 x 仅仅当 x 后面跟着 y 。\n    - 例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配'Jack'仅仅当它后面跟着'Sprat'或者是'Frost'。但是'Sprat'和'Frost'都不是匹配结果的一部分。\n- **(?<=y)x**   `后行断言`：匹配 x 仅仅当 x 前面是 y 。\n    - 例如，/(?<=Jack)Sprat/会匹配到'Sprat'仅仅当它前面是'Jack'。/(?<=Jack|Tom)Sprat/匹配'Sprat'仅仅当它前面是'Jack'或者是'Tom'。但是'Jack'和'Tom'都不是匹配结果的一部分。\n- **x(?!y)**    `正向否定查找`：仅仅当 x 后面不跟着 y 时匹配 x 。\n    - 例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!\\.)/ 匹配一个数字。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n- **(?<!y)x**   `反向否定查找`：仅仅当 x 前面不是 y 时匹配 x 。\n\n## 高级搜索标志\n\n- g\t全局搜索。\n- i\t不区分大小写搜索。\n- m\t多行搜索。\n\n## 正则相关方法汇总\n\n正则表达式可以被用于 RegExp 的 exec 和 test 方法，以及 String 的 match、replace、search 和 split 方法。\n\n### RegExp方法\n\n- **exec**\t一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。\n- **test**\t一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。\n\n#### 匹配手机号\n```js\n/^1[34578]\\d{9}&/.text(num)\n```\n\n#### 匹配邮箱\n\n匹配邮箱规则很复杂，实际的生产中只需要满足基本的验证规则：姑且把邮箱地址分成“第一部分@第二部分”这样：\n    - 第一部分：由字母、数字、下划线、英语句号（.）组成，\n    - 第二部分：为一个域名，域名由字母、数字、短横线（-）、英语句号（.）、域名后缀组成，而顶级域名后缀一般为2-6位字母，如cn,com,net。\n```js\n/^[0-9A-Z_\\.]+@[0-9A-Z-]+\\.[A-Z]{2,6}$/i.test(str);\n```\n\n#### 用exec从url中截取信息\n```js\nvar url = 'http://www.baidu.com?dsp=ipad&sid=20510';\nvar reg = /[?&](\\w+)=(\\w+)/g;\nvar obj = {};\n\nwhile(ret = reg.exec(url)) {\n    console.log('循环', ret);\n    obj[ret[1]] = ret[2];\n}\n\nconsole.log('obj', obj);\n```\n\n使用.exec方法，当其匹配到reg，会逐次返回匹配值数组：\n![](./images/reg-exec.png)\n\n### String方法\n\n- **match** 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。\n- **search**    一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。\n- **replace**   一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。\n- **split** 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。\n\n"},{"title":"使用正则表达式实现大驼峰字符串转换","url":"/Roundtables/Question-Bank/regular-expression/upper-camel-case.html","content":"# 使用正则表达式实现大驼峰字符串转换\n\n例如，给定this-is-a-string，将其转换为 ThisIsAString\n\n```js\n//连接符转成驼峰写法\nfunction toCamel(str) {\n    var reg = /-(\\w)/g;\n    str = '-' + str\n    return str.replace(reg, function() {\n        return arguments[1].toUpperCase()\n    });\n}\nconsole.log(toCamel(\"this-is-a-string\")); // ThisIsAString\n\n//连接符转成驼峰写法\nfunction toCamel(str) {\n    var reg = /-(\\w+)/g;\n    str = '-' + str\n    return str.replace(reg, (match, letter) => {\n        return letter.substring(0, 1).toUpperCase() + letter.substring(1);\n    });\n}\nconsole.log(toCamel(\"this-is-a-string\")); // ThisIsAString\n```\n"},{"title":"前端常见安全问题","url":"/Roundtables/Question-Bank/security/fe-security.html","content":"---\ntitle: 前端常见安全问题\ntags: [CSRF, XSS, sql注入]\ncategories: security\n---\n\n# 前端常见安全问题\n\n## CSRF 跨站请求伪造\nCSRF，跨站请求伪造，Cross-site request forgery\n\n### 攻击原理\n首先用户要登录网站A，网站A就会下发给用户cookie信息，当用户再访问网站B时，用户会被引诱点击网站B上的攻击链接，指向网站A的某个漏洞接口(常常是get类型)，点击后浏览器会上传用户的cookie，网站A会判定其为合法用户从而通过登录。\n\n![CSRF攻击原理](./images/CSRF.png)\n\n### 防御措施：\n- token验证(除了下发cookie还要分配一个token，攻击链接只能携带cookie但不能携带token)\n- referer验证(服务器判断页面的来源从而屏蔽攻击)\n- 隐藏令牌(与token验证类似，只是字段不会放在链接上，如放在http header头中，较隐蔽)\n\n## XSS 跨站脚本攻击\nXSS，跨站脚本攻击，Cross-site scripting\n\n### 攻击原理\n向页面中注入js脚本，运行函数体来完成自己攻击网站的目的，可能导致cookie泄露\n\n### 防御措施\n核心点就是`过滤阻止插入的js脚本执行`。\n\n## CSRF与XSS的区别\n- `CSRF依赖于用户登录网站，利用网站的漏洞接口完成攻击`；\n- `XSS则是向页面注入js脚本来执行函数体`。\n\n**注意**：顺便提下sql注入，原理就是通过吧sql命令插入到web表单提交；或输入域名；或页面请求的查询字符串中，达到欺骗服务器执行恶意的sql命令。\n\n\n"},{"title":"什么是类型兼容？","url":"/Roundtables/Question-Bank/typescript/ts-compatibility.html","content":"# 什么是类型兼容？\n\n类型兼容性用于确定一个类型是否能赋值给其他类型，TypeScript 结构化类型系统的基本规则是：`如果 x 要兼容 y，那么 y 至少具有与 x 相同的属性`。\n\n要查看 x 是否能赋值给 y，首先看它们的参数列表，x 的每个参数必须能在 y 里找到对应类型的参数，注意的是参数的名字相同与否无所谓，只看它们的类型：\n```ts\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\n\nx = y; // Type '(b: number, s: string) => number' is not assignable to type '(a: number) => number'.(2322)\n```\n\n"},{"title":"void、never、any、unknow有什么区别？string可以赋予前面提到的四种类型吗？","url":"/Roundtables/Question-Bank/typescript/type-difference.html","content":"# void、never、any、unknow有什么区别？string可以赋予前面提到的四种类型吗？\n\n## any\n\n我们通常会在不确定声明的一个变量为何种类型的情况下，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，指定any类型\n``` js\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\n<strong>string可以赋值any类型</strong>\n\n## void\n\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void。\n``` js\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n```\n声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：\n``` js\nlet unusable: void = undefined;\n```\n<strong>string不可以赋值void类型</strong>\n\n## unknow\n\nunknow类型和any类型区别：unknown 类型只能赋值给 any 类型和 unknown 类型本身\n``` js\nlet str: unknow;\nlet str2: any;\nlet str3: string = str // Type 'unknown' is not assignable to type 'string'.\n```\n<strong>string可以赋值unKnow类型</strong>\n\n## never\n\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）\n```js\nlet x: never;\nlet y: number;\n\n// 运行错误，数字类型不能转为 never 类型\nx = 123;\n\n// 运行正确，never 类型可以赋值给 never类型\nx = (()=>{ throw new Error('exception')})();\n\n// 运行正确，never 类型可以赋值给 数字类型\ny = (()=>{ throw new Error('exception')})();\n\n// 返回值为 never 的函数可以是抛出异常的情况\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 返回值为 never 的函数可以是无限循环这种无法被执行到的终止点的情况\nfunction loop(): never {\n    while (true) {}\n}\n```\n<strong>string不可以赋值never类型</strong>"},{"title":"TypeScript学习笔记","url":"/Roundtables/Question-Bank/typescript/typescript-base.html","content":"---\ntitle: TypeScript学习笔记\ndate: 2020-01-16 14:41:08\ntags: [TypeScript]\n---\n\n# TypeScript学习笔记\n\n## TS定义\nTypeScript 是 JavaScript 的一个`超集`，主要提供了**类型系统**和**对 ES6 的支持**，它由 Microsoft 开发，可以编译成纯 JavaScript，运行在任何浏览器上。\n\n## TS优缺点\n\n### 优点：\n1. TS 增加了代码的可读性和可维护性。\n    - 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了；\n    - 可以在编译阶段就发现大部分错误，这总比在运行时候出错好；\n    - 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等；\n2. TS 具有包容性。\n    - TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可；\n    - 即使不显式的定义类型，也能够自动做出类型推论；\n    - 编译报错也还是会生成js文件；\n\n### 缺点：\n1. TS 有学习成本。需要理解如接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念；\n2. TS 有使用成本。短期会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本\n\n## TS的安装\n\n```\nnpm install -g typescript // 全局安装\n\ntsc hello.ts // 编译一个ts文件 为 hello.js\n```\n我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀\n\n## TS基础\n\n### 原始数据类型\n\n- boolean\n- string\n- number\n- void\n- null 和 undefined \n\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 `void 表示没有任何返回值的函数`；而在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n```ts\nlet u: undefined = undefined;\nlet n: null = null;\n```\n`与 void 的区别是，undefined 和 null 是所有类型的子类型`。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n```ts\n// 这样不会报错\nlet num: number = undefined;\n```\n#### TS中string与String有什么区别？\nTS中用小写字母开头的类型代表字面量, 大写的是ES内置的对象，用来表示通过new实例化的数据：\n```js\n// 字面量\nconst n:number = 123;\nconst s:string = '456';\nconst o:object = {a:1,b:'2'};\n// 非字面量\nconst n:Number = new Number(123);\nconst s:String = new String('456');\nconst o:Object = new Object({a:1,b:'2'});\n```\n\n### 任意值any\n\n一个普通类型，在赋值过程中改变类型是不被允许的，而 any 类型，则允许被赋值为任意类型。\n\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型。\n\n声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值：\n```ts\n// 不会报错\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\nconsole.log(anyThing.myName.firstName);\nanyThing.setName('Jerry');\nanyThing.setName('Jerry').sayHello();\n```\n\n### 类型推论\n\nTypeScript 会在`没有明确的指定类型，但是有赋值`的时候推测出一个类型，这就是类型推论。\n\n如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查。\n\n### 高级类型1-联合类型（|：union types）\n\n联合类型（Union Types）表示取值可以为多种类型中的一种，用 | 分隔每个类型。\n\nTS 的交叉类型并`不是指每个类型的并集`，`| 应该理解成 or `，A | B 表示 A 或 B 的结果，它只可能是其中一个，这也就意味着它的类型是不确定的。\n\n当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候（也没有赋值，无法类型推断时），我们`只能访问此联合类型的所有类型里共有的属性或方法`：比如可以变量为var foo: string | number，则foo.length 则报错，因为length不是共有属性，而foo.toString()是没问题的。\n\n::: details 无法判断联合类型，需[类型断言]\n```ts\ninterface ICat {\n  run(): void\n  meow(): void\n}\ninterface IDog {\n  run(): void\n  bark(): void\n}\nclass Cat implements ICat {\n    run() { };\n    meow() { };\n}\nconst getAnimal = (): ICat | IDog {\n    return new Cat();\n}\n\nconst animal = getAnimal();\nanimal.run(); // ok\nanimal.meow(); // error\n\n// 这里 ICat 和 IDog 都拥有 run 方法\n// 不确定返回的具体是什么类型，如果想要编译通过就需要使用类型断言：\n\n// 类型断言\n(animal as ICat).meow() // ok\n\n// 判断是否存在该方法\nif ('meow' in animal) {\n  animal.meow()\n} else {\n  animal.bark();\n}\n```\n:::\n\n### 高级类型2-交叉类型（&：intersection types）\n\n交叉类型可以让我们把现有的类型组合在一起得到一个新的类型，从而同时拥有它们的全部属性，表示方法是：`A & B` 。\n\nTS 的交叉类型并`不是指每个类型的交集`，`& 的意思理解成 and `，A & B 表示同时包含 A 和 B 的结果，这里传进去的 user 必须同时拥有 name, age, grade 这三个属性，我们可以直接使用它而不需要判断是否存在该属性。\n```ts\ninterface IPerson {\n  name: string;\n  age: number;\n}\ninterface IStudent {\n  grade: number;\n}\nconst getBio = (user: IPerson & IStudent) => {\n  return `His name is ${user.name}, I am ${user.age} years old and a student of Grade ${user.grade}.`\n}\ngetBio({name: ‘Joi’, age: 12, grade: 6})\n```\n\n### 区分类型1-类型断言\n\n> 对于联合类型，在还不确定类型的时候，只能访问所有联合类型公有的属性或方法，随之带来的问题就是访问非公有的属性或方法时会报错，那么该如何区分值的具体类型，以及如何访问共有成员？\n\n方法一就是使用类型断言，将其断言为所属联合类型中的某种类型：\n\n类型断言有两种语法 `<类型>值` 和 `值 as 类型`，在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后者。\n\n当一个变量是联合类型的时候，我们能够确定的只有每个类型共有的方法，除非准确地知道该变量属于哪个类型。\n```ts\nconst canvas = document.getElementById('#canvas') // HTMLElement | null\nconst ctx = canvas.getContext('2d') // 错误\n```\n在上述代码中， canvas 元素可能不存在于文档中，所以 TS 推断它的类型是 HTMLElement | null ，不管是 null 还是 HTMLElement 都没有 getContext 方法。当我们很确定自己定义了该元素，就可以使用 类型断言 来指定它的类型，告诉编译器「我很清楚自己在做什么，这里不会出错」。之前的代码可以写成这样：\n```ts\nconst canvas = document.getElementById('#canvas') // HTMLElement | null\nconst ctx = (canvas as HTMLCanvasElement).getContext('2d') \n// 或者 (<HTMLCanvasElement>canvas).getContext(‘2d’)\n```\n**但是类型断言有个很大的问题是`写法很繁琐`**，假设我们有几个图形，有不同的求面积的方法：\n```ts\ninterface ICircle {\n  radius: number\n}\ninterface IRectangle {\n  width: number;\n  height: number;\n}\n\nconst getArea = (shape: ICircle | IRectangle): number => {\n  if ((<ICircle>shape).radius) {\n    return Math.PI * ((<ICircle>shape).radius ** 2);\n  } else {\n    return (shape as IRectangle).width * (shape as IRectangle).height;\n  }\n}\n// 不仅在 if 条件分支里面需要写断言，在 else 分支同样要进行断言，很繁琐\n```\n\n### 区分类型2-类型保护\n\n通过类型保护，TS 可以判断出不同条件分支的类型。类型保护常用的方式有两种`in`与`param is type`。\n\n*其实还有两种，使用 instanceof与typeof，但都有使用场景约束，具体见传送门[类型断言和类型保护](https://fullstackbb.com/typescript/type_guards_and_type_assertions/)。*\n#### 1.类型保护：in\n```ts\nconst whatPet = (pet: IFish | IBird): void => {\n  if ('swim' in pet) {\n    return pet.swim();\n  } else {\n    return pet.fly();\n  }\n}\n```\n\n#### 2.类型保护：类型预设（param is Type）\n类型预设 (type predicates) 的用法允许我们自定义类型保护，它的形式是在函数的返回值里面写成 param is Type ，param 必须是当前函数签名中的一个参数。\n```ts\nfunction isFish(pet: IFish | IBird): pet is IFish {\n    return (<IFish>pet).swim !== undefined;\n}\n\n// 'swim' 和 'fly' 调用都没有问题了\nconst whatPet = (pet: IFish | IBird): void => {\n  if (isFish(pet)) {\n    return pet.swim();\n  } else {\n    return pet.fly();\n  }\n}\n```\n\n### 接口interface——描述对象的形状\n\nobject其实是包含数组/元祖/枚举, 在ts的概念中, 这个叫做类型兼容, 就是说数组类型数据, 也可以用object来标注:\n```js\nlet array: object = [12,321];\n```\n实际上基本不用object类型的, 因为他标注的非常不具体, 一般都使用 接口（Interfaces）来对「对象的形状（Shape）」进行描述。\n\n上述就是接口的第一个用途，描述对象形状，除此之外，*接口interface还有另一个用途，对`类的一部分行为进行抽象`。*[类实现接口 implements](./typescript-base.html#类实现接口-implements)\n\n接口一般首字母大写。建议接口的名称加上 I 前缀。\n- 赋值的时候，变量的形状必须和接口的形状保持一致，多或者少属性都不行；\n- 但对于`?可选属性`，可以不存在；\n- 可定义`[propName: string]: 任意属性`：\n    ```ts\n    interface IPerson {\n        name: string;\n        age?: number;\n        [propName: string]: any;\n    }\n    ```\n    注意，`一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：`\n    ```ts\n    interface IPerson {\n        name: string;\n        age?: number;\n        [propName: string]: string;\n    }\n\n    let tom: IPerson = {\n        name: 'Tom',\n        age: 25, // 这里报错！因为 可选属性的类型number 不是 任意属性的类型string 的子集\n        gender: 'male'\n    };\n    ```\n- 可定义`readonly只读属性`：只读属性只能在创建的时候被赋值\n    ```ts\n    interface IPerson {\n        readonly id: number;\n    }\n\n    let tom: IPerson = {\n        id: 89757, // 只能在创建时赋值\n    };\n\n    tom.id = 9527; // 报错\n    ```\n\n### 数组的类型\n\n- **类型+方括号** 表示法：`let fibonacci: number[] = [1, 1, 2, 3, 5]; let list: any[];`\n- **数组泛型** 表示法：`let fibonacci: Array<number> = [1, 1, 2, 3, 5];`\n- **类数组** 接口表示：\n    ```ts\n    function sum() {\n        let args: number[] = arguments; // 报错\n    }\n    // arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：\n    function sum() {\n        let args: {\n            [index: number]: number;\n            length: number;\n            callee: Function;\n        } = arguments;\n    }\n\n    // 事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等都是 TS定义好的类型：\n    function sum() {\n        let args: IArguments = arguments;\n    }\n    ```\n\n### 函数的类型\n```js\n// 函数声明式\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\n\n// 函数表达式\nlet sum: (x: number, y: number) => number = function (x: number, y: number): number {\n    return x + y;\n};\n```\n\n**注意不要混淆**：TypeScript 中的 => 和 ES6 中的 =>。在 TypeScript 的类型定义中，=> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n#### 用接口定义函数的形状\n我们也可以使用接口的方式来定义一个函数需要符合的形状：\n```ts\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n```\n\n- `可选参数`：用 ? 表示可选的参数，且可选参数必须接在必需参数后面。\n- `默认值`：TypeScript 会将添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制了。\n    ```ts\n    function buildName(firstName: string = 'Tom', lastName: string) {\n        return firstName + ' ' + lastName;\n    }\n    let tomcat = buildName('Tom', 'Cat');\n    let cat = buildName(undefined, 'Cat');\n    ```\n- `剩余参数`：使用 rest参数 表示剩余参数，且rest 参数只能是最后一个参数。\n    ```js\n    function push(array: any[], ...items: any[]) {}\n    ```\n\n#### 函数重载\n\n重载允许一个函数接受不同数量或类型的参数时，通过多个定义，分别作出不同的处理：\n```js\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n```\nTS **会优先从最前面的函数定义开始匹配**，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n\n## 声明文件\n\n声明文件必需以 .d.ts 为后缀。声明文件仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除。\n\n使用 @types 统一管理第三方库的声明文件。\n@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：\nnpm install @types/jquery --save-dev\n\n### 全局变量：\n\n一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var 或 let\n\n需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现\n\n```ts\n// src/jQuery.d.ts\n\n// 声明为常量\ndeclare const jQuery: (selector: string) => any;\n\n// jQuery也是函数，所以也可以声明函数，且声明函数支持重载\ndeclare function jQuery(selector: string): any;\ndeclare function jQuery(domReadyCallback: () => any): any;\n```\n\nnamespace是ts在ES5时期提供的模块化方案，随着ES6的发展，已经不建议再使用 ts 中的 namespace，而推荐使用 ES6 的模块化方案了。\n\nnamespace 被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。\n\n注意，在 declare namespace 内部，我们直接使用 function ajax 来声明函数，而不是使用 declare function ajax：\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n```\n\n### interface 和 type\n除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 interface 或 type 来声明一个全局的接口或类型。\n\n### 防止命名冲突\n暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下：\n```ts\n// src/jQuery.d.ts\n\ndeclare namespace jQuery {\n    interface AjaxSettings {\n        method?: 'GET' | 'POST'\n        data?: any;\n    }\n    function ajax(url: string, settings?: AjaxSettings): void;\n}\n```\n注意，在使用这个 interface 的时候，也应该加上 jQuery 前缀：\n```ts\n// src/index.ts\n\nlet settings: jQuery.AjaxSettings = {\n    method: 'POST',\n    data: {\n        name: 'foo'\n    }\n};\njQuery.ajax('/api/post_something', settings);\n```\n\n### 声明合并\n假如 jQuery 既是一个函数，可以直接被调用 jQuery('#foo')，又是一个对象，拥有子属性 jQuery.ajax()（事实确实如此），那么我们可以组合多个声明语句，它们会不冲突的合并起来：\n```ts\n// src/jQuery.d.ts\n\ndeclare function jQuery(selector: string): any;\ndeclare namespace jQuery {\n    function ajax(url: string, settings?: any): void;\n}\n```\n```ts\n// src/index.ts\n\njQuery('#foo');\njQuery.ajax('/api/get_something');\n```\n\n\n### 自动生成声明文件\n如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加 declaration 选项，就可以同时也生成 .d.ts 声明文件了。\n我们可以在命令行中添加 --declaration（简写 -d），或者在 tsconfig.json 中添加 declaration 选项。这里以 tsconfig.json 为例：\n```json\n{\n    \"compilerOptions\": {\n        \"module\": \"commonjs\",\n        \"outDir\": \"lib\",\n        \"declaration\": true,\n    }\n}\n```\n\n### 内置对象\n\n- ECMAScript 标准提供的内置对象有：Boolean、Error、Date、RegExp 等。\n    ```ts\n    let b: Boolean = new Boolean(1);\n    let e: Error = new Error('Error occurred');\n    let d: Date = new Date();\n    let r: RegExp = /[a-z]/;\n    ```\n- DOM 和 BOM 提供的内置对象有：Document、HTMLElement（即document.body）、Event、NodeList 等。\n- TypeScript核心库：预置定义了所有浏览器环境需要用到的类型，核心库的定义中不包含 Node.js 部分，如果想用 TS 写 Node.js，则需要引入第三方声明文件：npm install @types/node --save-dev\n\n\n## TS进阶\n\n### 类型别名 type\n类型别名用来给一个类型起个新名字。类型别名与字符串字面量类型都是使用 **type** 进行定义\n```ts\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n;\n    } else {\n        return n();\n    }\n}\n```\n上例中，我们使用 **type** 创建类型别名。类型别名常`用于联合类型`。\n\n### 字符串字面量类型 type\n字符串字面量类型用来约束取值只能是某几个字符串中的一个。类型别名与字符串字面量类型都是使用 **type** 进行定义。\n```ts\ntype EventNames = 'click' | 'scroll' | 'mousemove';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById('hello'), 'scroll');  // 没问题\nhandleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'\n\n// index.ts(7,47): error TS2345: Argument of type '\"dbclick\"' is not assignable to parameter of type 'EventNames'.\n```\n\n### 元组 tuple\n数组合并了相同类型的对象；而元组（Tuple）合并了不同类型的对象，限定了数组元素的个数和对应类型。\n```ts\n// 当赋值或访问一个已知索引的元素时，会得到正确的类型：\n// 通过索引只赋值其中一项是允许的\nlet tom: [string, number];\ntom[0] = 'Tom';\ntom[1] = 25;\ntom[0].slice(1);\ntom[1].toFixed(2);\n\n// 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。\nlet tom: [string, number];\ntom = ['Tom', 25];\n```\n\n#### 元组越界添加\n当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：\n```ts\nlet tom: [string, number];\ntom = ['Tom', 25];\ntom.push('male');\ntom.push(true);\n// Argument of type 'true' is not assignable to parameter of type 'string | number'.\n```\n可以添加越界元素，但是无法访问，当然也不能给越界赋值：\n```ts\ntuple.push(2)  // 不报错\nconsole.log(tuple) // [0, \"1\", 2] 也能都打印出来\nconsole.log(tuple[2]) // 但是想取出元组中的越界元素，就会报错元组长度是2，在index为2时没有元素\ntuple[2] = '123' // 会报不能将类型‘123’分配给‘undefined’\n```\n\n### 枚举 enum\n枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。是 `ts中有而js中没有的类型`，编译后会被转化成对象。枚举成员会被赋值为`从 0 开始递增`的数字，同时也会对枚举值到枚举名`进行反向映射`：\n```ts\nenum Color {Red, Green, Blue}  等价  enum Color {Red=0, Green=1, Blue=2}\n\n// 可手动赋值为常数项或计算成员，未手动赋值的枚举项会接着上一个枚举项递增。\n// 计算成员因为不常用这里不做示例。\nenum Color {Red=1, Green, Blue=4}\nColor[2] === 'Green' // true\n\n// 可反向通过值得到键\nenum Color {Red=1, Green=2, Blue=4}\nColor[2] === 'Green' // true\n```\n编译后：\n```ts\nenum Color {Red, Green, Blue}\n\n// 编译后\n\nvar Color;\n(function (Color) {\n    Color[Color[\"Red\"] = 0] = \"Red\";\n    Color[Color[\"Green\"] = 1] = \"Green\";\n    Color[Color[\"Blue\"] = 2] = \"Blue\";\n})(Color || (Color = {}));\n// Color的值为: {0: \"Red\", 1: \"Green\", 2: \"Blue\", Red: 0, Green: 1, Blue: 2}\n```\n\n#### 常数枚举与外部枚举\n\n*暂时不知道应用场景*\n\n- 常数枚举是使用 const enum 定义的枚举类型，与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n    ```ts\n    const enum Directions { Up, Down, Left, Right }\n\n    let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n    // 编译结果是：\n    var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n    ```\n- 外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型，只会用于编译时的检查，编译结果中会被删除。\n    ```ts\n    const enum Directions { Up, Down, Left, Right }\n\n    let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n\n    // 编译结果是：\n    var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n    ```\n\n### TS中 类 的用法 class\n\n#### 修饰符 public、private、protected 和 只读属性\nTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。\n- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，`默认所有的属性和方法都是 public 的`；\n- `private` 修饰的属性或方法是私有的，`不能在声明它的类的外部访问`；\n- `protected` 修饰的属性或方法是受保护的，它`和 private 类似`，区别是它`在子类中也是允许被访问的`。\n- `readonly` 将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化。\n\n**参数属性**：通常ts中类的实例属性需要先定义创建，再在构造函数中初始化赋值。但 修饰符和`readonly`还可以使用在构造函数所传参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\n\n只读关键字readonly 和访问修饰符同时存在时，需写在其后面。\n```ts\n// 通常需要先创建，再初始化类成员属性\nclass Animal {\n    public name: string;\n    public constructor (public readonly theName) {\n        this.name = theName;\n    }\n}\n\n// 可以通过 参数属性 简化写法，创建和初始化一步完成\nclass Animal {\n    // public name: string = 'xiao hei';\n    public constructor (public readonly name: string = 'xiao hei') {\n        // this.name = name;\n    }\n}\n```\n\n#### 抽象类\n`abstract` 用于定义抽象类和其中的抽象方法。\n- 抽象类是不允许被实例化的；\n- 抽象类中的抽象方法必须被子类实现；\n\n#### 类的类型\n给类加上 TypeScript 的类型很简单，与接口类似：\n```ts\nclass Animal {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    sayHi(): string {\n      return `My name is ${this.name}`;\n    }\n}\n\nlet a: Animal = new Animal('Jack');\nconsole.log(a.sayHi()); // My name is Jack\n```\n\n### 类与接口 (包括 implements)\n\n#### 接口interface——类实现接口 implements\n这里介绍接口interface的另一个作用，`对类的一部分行为进行抽象`，使用 `implements`。\n\n防盗门和车都实现(implements)了 警报 的接口：\n```ts\ninterface Alarm {\n    alert(): void;\n}\n\nclass Door {\n}\n\nclass SecurityDoor extends Door implements Alarm {\n    alert() {\n        console.log('SecurityDoor alert');\n    }\n}\n\nclass Car implements Alarm {\n    alert() {\n        console.log('Car alert');\n    }\n}\n```\n\n一个类可以实现多个接口：\n```ts\ninterface Alarm {\n    alert(): void;\n}\n\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log('Car alert');\n    }\n    lightOn() {\n        console.log('Car light on');\n    }\n    lightOff() {\n        console.log('Car light off');\n    }\n}\n```\n\n#### 接口继承接口\n接口与接口之间可以是继承关系：\n```ts\ninterface Alarm {\n    alert();\n}\n\ninterface LightableAlarm extends Alarm {\n    lightOn();\n    lightOff();\n}\n```\n\n#### 接口继承类\n接口也可以继承类：\n```ts\nclass Point {\n    x: number;\n    y: number;\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n```\n\n\n### 泛型 \\<>\n\n泛型（Generics）是指在定义函数、接口或类的时候，`不预先指定具体的类型，而在使用的时候再指定类型的一种特性`。\n\n#### 基本使用\n```ts\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\n// 在函数名后添加了 <T>，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array<T> 中即可使用了。\n\n\n// 接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：\ncreateArray<string>(3, 'x'); // ['x', 'x', 'x']\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n\n// 定义泛型的时候，可以一次定义多个类型参数：\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n```\n\n#### 泛型约束\n\n在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法，当使用了它所没有的属性或方法时，就会报错。因此可以对泛型进行约束，只允许这个函数传入那些包含要使用的属性或方法的变量。这就是泛型约束。\n```ts\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingIdentity(7); // 报错\n// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.\n```\n\n多个类型参数之间也可以互相约束，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。\n```ts\nfunction copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyFields(x, { b: 10, d: 20 });\n```\n\n#### 泛型接口\n使用含有泛型的接口来定义函数的形状：\n```ts\ninterface CreateArrayFunc<T> {\n    (length: number, value: T): Array<T>;\n}\n\n// 此时在使用泛型接口的时候，需要定义泛型的类型\nlet createArray: CreateArrayFunc<any>;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n```\n\n#### 泛型类\n泛型也可以用于类的类型定义中：\n```ts\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n#### 泛型参数的默认类型\n在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n```ts\nfunction createArray<T = string>(length: number, value: T): Array<T> {\n    // ...\n}\n```\n\n### 函数、接口、类 声明合并\n如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：\n\n#### 函数合并： 即函数重载\n\n#### 接口合并\n同名接口合并时：\n- 属性合并时会将属性简单合并到一起，如果属性名称相同但类型不同则会报错；\n- 方法合并时与函数重载一致；\n\n#### 类合并：规则同接口合并\n\n## 工程\n### 代码检查\n2019 年 1 月，TypeScirpt 官方决定全面采用 ESLint 作为代码检查的工具，并创建了一个新项目 `typescript-eslint`。弃用了之前的两种检查方案。\n\n### 编译选项\n\n## 参考链接 及 工具\n[Typescript 入门教程](https://ts.xcatliu.com/)\n[在线ts环境](http://www.typescriptlang.org/play/index.html)\n\n"},{"title":"自定义组件实现v-model的双向绑定","url":"/Roundtables/Question-Bank/vue/customized-v-model.html","content":"# 自定义组件实现v-model的双向绑定\n\n> 编写自定义组件实现 v-model 的双向绑定\n\n----\n## 一、v-model是prop与event的语法糖\n\nv-model 双向绑定实际上就是（以input标签为例）：\n- 通过子组件中的 $emit 方法派发 input 事件，父组件监听 input 事件中传递的 value 值，并存储在父组件 data 中；\n- 然后父组件再通过 prop 的形式传递给子组件 value 值，在子组件中绑定 input 的 value 属性即可。\n```js\n// 父组件\n<my-input :value=\"value\" @input=\"value = innerValue\" />\n\n// 子组件\nVue.component('my-input', {\n  props: {\n    value: String\n  },\n  template: `\n    <input\n      type=\"text\"\n      :value=\"value\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n\n```\n\n## 二、在非input元素上实现v-model双向绑定\n一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。\n\n::: tip\n```<input type=”text” >、<textarea>``` 使用 **value** 属性 和 **input** 事件;\n```<input type=”checkbox”>、<input type=”radio”>``` 使用 **checked** 属性 和 **change** 事件;\n```<select>``` 使用 **value** 和 **change** 事件\n:::\n\n## 三、直接使用 v-model 指令，实现自定义组件双向绑定\n\n对于非input元素，需要配置 **model** 选项，在组件中修改 v-model 指令，指定 prop 和 event：\n\n```js\nexport default {\n  name: 'MyComp',\n  props: ['checked'],\n  model: {\n    prop: 'checked',\n    event: 'change'\n  }\n}\n```\n\n以下为两种具体实现（以checkbox为例）：\n\n1. 在子组件编写template时，将 v-model 拆开\n    ```js\n    <my-checkbox v-model=\"lovingVue\"></my-checkbox>\n\n    Vue.component('my-checkbox', {\n        model: {\n            prop: 'checked',\n            event: 'change'\n        },\n        props: {\n            checked: Boolean // 使用model配置后，依然需要props声明\n        },\n        template: `\n            <input\n                type=\"checkbox\"\n                :checked=\"checked\"\n                @change=\"$emit('change', $event.target.checked)\"\n            >\n        `\n    })\n    ```\n\n2. 在子组件编写template时直接使用v-model，通过计算属性双向绑定\n    ```js\n    <my-checkbox v-model=\"lovingVue\"></my-checkbox>\n\n    Vue.component('my-checkbox', {\n        model: {\n            prop: 'checked',\n            event: 'change'\n        },\n        props: {\n            checked: Boolean // 使用model配置后，依然需要props声明\n        },\n        computed: {\n            newLovingVue: {\n                get() {\n                    return this.checked\n                },\n                set(checked) {\n                    return this.$emit('change', checked)\n                }\n            }\n        },\n        template: `<input type=\"checkbox\" v-model=\"newLovingVue\">`\n    })\n    ```\n\n## 四、特殊场景：当 v-model 遇上 $listeners\n\n```$listeners``` 的要点总结详见下一篇： [$listeners & $attrs](./listeners-and-attrs.md)\n[官网传送门：将原生事件绑定到组件](https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6)\n\n- 官方文档上说，当我们想要在一个组件根元素上监听`原生事件`时，可以使用 v-on 的.native修饰符。但是这只在根元素就是原生事件触发对象时有用，当组件中根元素是一层wrapper标签，实际要监听的原生事件触发者被包裹起来时，就需要用到`$listeners`。\n\n- 一个 `$listeners` 属性，它是一个对象，里面包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件。有了这个 $listeners 属性，你就可以配合 v-on=\"$listeners\" 将所有的事件监听器指向这个组件的某个特定的子元素。\n\n- 对于 `配合 v-model 工作`的组件来说，为这些监听器创建一个类似下述 customListeners 的计算属性通常是非常有用的：\n    ```js\n    Vue.component('my-input', {\n    inheritAttrs: false,\n    props: ['label', 'value'],\n    computed: {\n        customListeners: function () {\n        var vm = this\n        // `Object.assign` 将所有的对象合并为一个新对象\n        return Object.assign({},\n            // 我们从父级添加所有的监听器\n            this.$listeners,\n            // 然后我们添加自定义监听器，\n            // 或覆写一些监听器的行为\n            {\n            // 这里确保组件配合 `v-model` 的工作\n            input: function (event) {\n                vm.$emit('input', event.target.value)\n            }\n            }\n        )\n        }\n    },\n    template: `\n        <label>\n            {{ label }}\n            <input\n                v-bind=\"$attrs\"\n                v-bind:value=\"value\"\n                v-on=\"customListeners\"\n            >\n        </label>\n    `\n    })\n    ```\n**注意：**\n- 这里之所以要覆盖input的事件监听器，是因为input标签触发返回的是一个event，而不是直接返回对应改变的值，这样处理后就可以使组件的v-model中的@input部分正常获取到内部emit的innerValue值（v-model中@input=\"value = innerValue\"）。\n- 如果不处理，会直接将外层v-model中的@input=\"value = innerValue\"指向内部的input标签，但input标签上无法直接拿到这个innerValue。\n"},{"title":"$listeners & $attrs","url":"/Roundtables/Question-Bank/vue/listeners-and-attrs.html","content":"\n# $listeners & $attrs\n> [demo地址](https://codesandbox.io/s/attrslisteners-20jdq)\n## $listeners\n::: tip\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\n:::\n\n### **用来实现跨组件双向绑定(以封装第三方组件为例)**\n\n***不使用$listeners***\n::: tip\n实现双向绑定时，只能通过绑定计算属性，通过计算属性的**set** 来主动触发this.$emit\n:::\n\n<br/>\n\n**如下有一组例子：**\n\n第三方组件**v-input**，简单的输入框v-model。**v-transfrom-input**是我们对其\n\n进行二次封装的组件，再供给页面中使用。这些逻辑都一块写在listeners.vue中。\n\n<br/>\n\n**第三方组件：v-input**\n```js\nVue.component(\"v-input\", {\n    props: {\n        value: String\n    },\n    // 如下是v-model=“value”语法糖的拆解\n    template: `\n        <div>\n            <input\n                :style=\"color\"\n                type=\"text\"\n                :bind=\"value\"\n                v-on:input=\"$emit('input', $event.target.value)\"\n            >\n        </div>\n    `\n});\n```\n\n<br/>\n\n**封装第三方组件：v-transform-input**\n\n想实现双向绑定值传递，需要绑定一个计算属性thisValue, 通过计算属性set来主动触发this.$emit('input')，实现上层父组件中v-model绑定值的更新。\n\n主动触发是因为当前组件为**非表单控件**，并没有用户输入事件来主动触发更行上层input方法，所以要添加逻辑来主动进行触发。\n```js\nVue.component(\"v-transform-input\", {\n    props: {\n        value: String\n    },\n    computed: {\n        thisValue: {\n            get() {\n                return this.value;\n            },\n            set(value) {\n                this.$emit(\"input\", value); // 主动触发上层父子间更改数据\n            }\n        }\n    },\n    template: ` <v-input v-model=\"thisValue\"></v-input>`\n});\n```\n\n<br/>\n\n**listeners.vue使用封装好的组件**\n```js\n// template\n<v-transform-input v-model=\"value\"></v-transform-input>\n// js\ndata() {\n    return {\n        value: ''\n    }\n}\n```\n\n<br/>\n\n***使用$listeners***\n::: tip\n利用listeners将父组件作用域绑定的方法绑定此组件作用域的特点。\n:::\n\n因为$listeners将父组件上v-model绑定值的input方法都绑定到了v-transform中，所以第三方组件v-input\n\n中触发this.$emit('input')就能在v-transform中找到$listeners绑定来的input方法，这个input方法其实就\n\n是最顶层v-model指令语法糖的默认input方法，更新的也是最顶层的那个value\n\n**封装第三方组件**\n```js\nVue.component(\"v-transform-input\", {\n    props: {\n        value: String\n    },\n    template: `\n        <v-input :value=\"value\" v-on=\"$listeners\">\n        </v-input>\n    `\n});\n```\n\n### **用来实现跨组件调用方法(以封装第三方组件为例)**\n\n***在没有使用$listeners时***\n::: tip\n调用第三方组件提供的方法需要逐层添加事件绑定，来调用$emit\n:::\n\n<br/>\n\n同样的组件：第三方组件**v-input**，提供一个setColor方法改变按钮的字体颜色，供上层组件调用，\n\n然后我们对其进行二次封装的**v-transfrom-input**，再供给页面中使用\n\n**第三方组件：v-input**\n```js\nVue.component(\"v-input\", {\n    props: {\n        value: String\n    },\n    data() {\n        return {\n            color: 'color: red'\n        }\n    },\n    methods: {\n        setColor() {\n            this.color = 'color: green';\n            this.$emit('otherMethod', 'green');\n        }\n    },\n    template: `\n        <div>\n            <input\n                :style=\"color\"\n                type=\"text\"\n                v-model=\"value\"\n            >\n            <button @click=\"setColor\">触发第三方组件方法</button>\n        </div>\n    `\n});\n```\n\n**封装第三方组件：v-transfrom-input**\n\n```js\nVue.component(\"v-transform-input\", {\n    methods: {\n        otherMethod(color) {\n            // 通过传统的$emit父子组件方法来调用\n            this.$emit('otherMethod', color);\n        }\n    }\n    template: `<v-input @otherMethod=\"otherMethod\"></v-input>`\n});\n```\n\n**使用封装好的组件: listeners.vue**\n```js\n// template\n<v-transform-inpu @otherMethod=\"otherMethod\"></v-transform-inpu>\n// js\nmethods: {\n    otherMethod(color) {\n        console.log('第三方组件触发', color);\n    }\n}\n```\n\n<br/>\n\n***使用$listeners***\n::: tip\n同样利用listeners将父组件作用域绑定的方法绑定此组件作用域的特点。\n:::\n上层父组件的otherMethod方法也合并到了当前组件v-transfrom-input的作用域中，v-inputsetColr中调\n\n用this.$emit('otherMethod'), 也就能在v-transfrom-input上找到对应方法。\n\n**改写封装的第三方组件**\n```js\nVue.component(\"v-transform-input\", {\n    template: `\n        <v-input v-on=\"$listeners\">\n        </v-input>\n    `\n});\n```\n\n### 当父组件双向绑定值没有初始化注册\n\n还是那个例子，不做初始化双向绑定就会失效。可能在vue实例第一次渲染时候，没有遍历到这个值，就不会生成相应的obsever。\n有待继续发掘。\n\n**使用封装好的组件: listeners.vue**\n```js\n// template\n<v-transform-inpu v-model=\"value\" @otherMethod=\"otherMethod\"></v-transform-inpu>\n// js\ndata() {\n    return {\n        // value: '' // 这里不做初始化处理。\n    }\n},\nmethods: {\n    otherMethod(color) {\n        console.log('第三方组件触发', color);\n    }\n}\n```\n\n## $attrs\n::: tip\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没\n\n有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过\n\nv-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n:::\n\n### 使用\n\n孙组件\n\n```js\n// template\n<template>\n    <p :style=\"getColor\">我是孙组件</p>\n</template>\n// script\nexport default{\n    // 如果在不在props中声明color 那么这个数据，请使用this.$attrs.color\n    // 如果声明，那么this.$props上就会有color\n    props: {\n        newColor: String\n    },\n    computed: {\n        getColor() {\n            return `color: ${this.newColor || \"green\"}`;\n        }\n    }\n}\n```\n\n子组件\n```js\n// template\n<grand-son v-bind=\"$attrs\"></grand-son>\n\n// script\nimport GrandSon from './GrandSon';\n\nexport default {\n    ...,\n    components: {\n        GrandSon\n    }\n}\n<>\n```\n\n父组件\n\n```js\n// template\n// style class 不会在$attrs上\n<son newColor=\"red\" custom=\"febcat\" style=\"font-size: 16px;\" class=\"son\"></son>\n\n// script\nimport Son from './Son';\n\nexport default {\n    ...,\n    components: {\n        Son\n    }\n}\n\n// css\n.son{\n    font-weight: 500;\n}\n```\n\n查看dom如下\n\n![$attrs](./images/attrs.jpg)\n\n<br/>\n\n### inheritAttrs禁用特性继承\n+ 默认值为true\n\n- 如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false\n\n+ 不会影响 style 和 class 的绑定。\n\n\n```js\nVue.component('my-component', {\n  inheritAttrs: false,\n  // ...\n})\n```\n\n## 小结\n**v-model表单控件**\n+ 通常默认绑定value，数据更新方法为input\n- checkbox, radio 使用为checked，更新方法为change\n+ select 默认绑定value, 数据更新为change\n---------\n**v-model非表单控件作为中间层组件（如封装第三方组件)**\n+ 未使用$listeners情况下需要通过v-model双向绑定计算属性，数据更新\n\n  触发set方法，在set方法中进而主动触发this.$emit('input')\n- 使用$listeners情况下，仅需配合$attrs就能达到目的，v-model也不必写\n---------\n**双向绑定值初始化**\n+ 不管任何形式的值，只要在data中没有初始化，那么双向绑定就不会成功\n\n<br/>\n"},{"title":"关于ElementUI的无限滚动","url":"/Roundtables/Question-Bank/vue/v-infinite-scroll.html","content":"# 关于ElementUI的无限滚动\n\n[传送门在此](https://element.eleme.cn/#/zh-CN/component/infiniteScroll)\n\n## 概览\n下面截取至官方文档的属性列表\n![image.png](./assets/img/1575260424448-e51bbf16-e3bc-46dd-9105-38f0e9d87820.png)\n\n官方的一个例子：\n```html\n<template>\n  <ul class=\"infinite-list\" v-infinite-scroll=\"load\" style=\"overflow:auto\">\n    <li v-for=\"i in count\" class=\"infinite-list-item\">{{ i }}</li>\n  </ul>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      load () {\n        this.count += 2\n      }\n    }\n  }\n</script>\n```\n例子上吧`v-infinite-scroll`指令绑定再在了`ul`上面，并且设置了`style=\"overflow:auto\"`。\n\n## 探究源码\n那么它是怎么实现无限滚动的呢？且看源码：\n\n```javascript\n// dom.js\nexport const isScroll = (el, vertical) => {\n  if (isServer) return;\n\n  const determinedDirection = vertical !== null || vertical !== undefined;\n  const overflow = determinedDirection\n    ? vertical\n      ? getStyle(el, 'overflow-y')\n      : getStyle(el, 'overflow-x')\n    : getStyle(el, 'overflow');\n\n  return overflow.match(/(scroll|auto)/);\n};\n\nexport const getScrollContainer = (el, vertical) => {\n  if (isServer) return;\n\n  let parent = el;\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window;\n    }\n    if (isScroll(parent, vertical)) {\n      return parent;\n    }\n    parent = parent.parentNode;\n  }\n\n  return parent;\n};\n\n// infinite-scroll\nexport default {\n  name: 'InfiniteScroll',\n  inserted(el, binding, vnode) {\n    const cb = binding.value;\n\n    const vm = vnode.context;\n    // only include vertical scroll\n    const container = getScrollContainer(el, true);\n    const { delay, immediate } = getScrollOptions(el, vm);\n    const onScroll = throttle(delay, handleScroll.bind(el, cb));\n\n    el[scope] = { el, vm, container, onScroll };\n\n    if (container) {\n      container.addEventListener('scroll', onScroll);\n\n      if (immediate) {\n        const observer = el[scope].observer = new MutationObserver(onScroll);\n        observer.observe(container, { childList: true, subtree: true });\n        onScroll();\n      }\n    }\n  },\n  unbind(el) {}\n};\n```\n通过源码可以发现，它有一个寻找 scrollContainer （可滚动容器）的过程（上面的getScrollContainer函数），如果当前元素可滚动（上面的isScroll函数），则取当前元素否则一直向上找直到最顶端。\n\n## 发现问题\n对于一些简单的元素通过该指令可以轻松的实现无限滚动加载，但是`ElementUI`的`table`就不是那么老实了。\n我们通过table提供的append插槽插入一个空标签，从而达到给table内部的可滚动容器绑定滚动事件的目的：\n\n```html\n<el-table\n  max-height=\"100\"\n  :data=\"tableData\"\n  style=\"width: 100%\">\n  <el-table-column\n    prop=\"date\"\n    label=\"日期\"\n    width=\"180\">\n  </el-table-column>\n  <span slot=\"append\"></span>\n</el-table>\n```\n当没有数据时，看下dom结构和样式表：\n![image.png](./assets/img/1575274043310-20ed81fb-713a-4d9b-9eed-1860b1ea03da.png)\n有数据时，看下dom结构和样式表：\n![image.png](./assets/img/1575273988632-3326e3fc-3f24-48ce-ac11-d9ad5be0763d.png)\n可以发现：\n\n1. 不管有没有数据，`append`插槽都在（废话）。\n1. 观察离`append`最近的祖级可滚动容器 1 ，以及它的样式 3 ，发现有数据且数据撑满了容器后 `overflow-y` 发生了改变，也就是说只有当容器无法显示更多内容时，`Element`将容器的样式设为了`overflow-y: auto;`\n\n如此看来，要寻找一个合适的时机插入`append`才能准确的将`scroll`事件绑定到可滚动容器 1 上面。\n\n## 解决问题\n因此我们必须先手动将容器填满，然后才能将`append`插入进去。且看代码：\n\n```html\n<el-table\n  max-height=\"100\"\n  :data=\"tableData\"\n  style=\"width: 100%\">\n  <el-table-column\n    prop=\"date\"\n    label=\"日期\"\n    width=\"180\">\n  </el-table-column>\n  <span\n    v-if=\"showLoadMore\"\n    slot=\"append\"\n    v-infinite-scroll=\"load\"\n    infinite-scroll-immediate=\"false\"\n  ></span>\n  <span v-if=\"noMore\">没有更多了～</span>\n</el-table>\n\n<script>\n  export default {\n  \tdata() {\n    \treturn {\n      \tinserted: false,\n        tableData: []\n      }\n    },\n    computed: {\n    \tshowLoadMore() {\n      \treturn this.inserted && !this.noMore\n      },\n      noMore() {}\n    },\n    mounted() {\n    \tthis.getData()\n    },\n    method: {\n    \tasync getData() {\n      \tthis.tableData = await action()\n        if (!this.inserted) {\n        \tthis.$nextTick(() => {\n          \tthis.inserted = true\n          })\n        }\n      },\n      load() {\n      \tif (!this.noMore) {\n        \tthis.getData()\n        }\n      }\n    }\n  }\n</script>\n```\n上面的代码，我们通过`v-if`去控制`append`插槽内容的插入时机，首次加载数据完成且`dom`已更新后将`inserted`设为`true`表示插入了，那么此时的内容已撑满容器，因此当 `v-infinite-scroll` 指令在向上寻找可滚动容器的时候立马就找到了`table`内部那个对应的可滚动容器并且将滚动事件绑定在该容器上。\n\n## 总结\n`v-infinite-scroll`有一个寻找 scrollContainer （可滚动容器）的过程（上面的getScrollContainer函数），如果当前元素可滚动（上面的isScroll函数），则取当前元素否则一直向上找直到最顶端。\n注意：该指令是在该元素插入时就会开始寻找可滚动容器，也就是说如果滚动容器的出现是有条件的，那么就要考虑手动控制它何时开始寻找可滚动容器。\n"},{"title":"编写自定义指令，实现动态列表加载","url":"/Roundtables/Question-Bank/vue/v-loadmore.html","content":"### 编写自定义指令，实现动态列表加载\n\n> 编写自定义指令，v-loadmore\n\n----\n#### 一、vue自定义指令，做滚动加载监听（全局指令）\n全局定义自定义组件：\n```js\n// v-loadmore: 用于在element-ui的select下拉框加上滚动到底事件监听\nVue.directive('loadmore', {\n    bind(el, binding) {\n      // 获取element-ui定义好的scroll盒子\n      const SELECTWRAP_DOM = el.querySelector('.el-select-dropdown .el-select-dropdown__wrap');\n    \n      SELECTWRAP_DOM.addEventListener('scroll', function() {\n\n          /*\n           * scrollHeight 获取元素内容高度(只读)\n           * scrollTop 获取或者设置元素的偏移值, 常用于计算滚动条的位置, 当一个元素的容器没有产生垂直方向的滚动条, 那它的scrollTop的值默认为0.\n           * clientHeight 读取元素的可见高度(只读)\n           * 如果元素滚动到底, 下面等式返回true, 没有则返回false:\n           * ele.scrollHeight - ele.scrollTop === ele.clientHeight;\n           */\n          const CONDITION = this.scrollHeight - this.scrollTop <= this.clientHeight;\n\n          CONDITION && binding.value();\n      });\n    }\n})\n\n```\n在组件中：\n```js\n<template>\n    <el-select \n        v-model=\"selectValue\" \n        v-loadmore=\"toLoadMore\">\n        <el-option\n            v-for=\"item in options\"\n            :key=\"item.id\"\n            :label=\"item.accountName\"\n            :value=\"item.id\">\n        </el-option>\n    </el-select>\n</template>\n\nexport default {\n    methods: {\n        toLoadMore() {\n            // 这里可以做你想做的任何事 到底执行\n        }\n    }\n}\n```\n\n#### 二、vue自定义指令，做滚动加载监听（局部指令）\n\n在组件中：\n```js\n<template>\n    <el-select \n        v-model=\"selectValue\" \n        v-loadmore=\"toLoadMore\">\n        <el-option\n            v-for=\"item in options\"\n            :key=\"item.id\"\n            :label=\"item.accountName\"\n            :value=\"item.id\">\n        </el-option>\n    </el-select>\n</template>\n\nexport default {\n    directives: {\n        'loadmore': {\n            bind(el, binding) {\n            // 获取element-ui定义好的scroll盒子\n            const SELECTWRAP_DOM = el.querySelector('.el-select-dropdown .el-select-dropdown__wrap');\n            \n            SELECTWRAP_DOM.addEventListener('scroll', function() {\n\n                /*\n                * scrollHeight 获取元素内容高度(只读)\n                * scrollTop 获取或者设置元素的偏移值, 常用于计算滚动条的位置, 当一个元素的容器没有产生垂直方向的滚动条, 那它的scrollTop的值默认为0.\n                * clientHeight 读取元素的可见高度(只读)\n                * 如果元素滚动到底, 下面等式返回true, 没有则返回false:\n                * ele.scrollHeight - ele.scrollTop === ele.clientHeight;\n                */\n                const CONDITION = this.scrollHeight - this.scrollTop <= this.clientHeight;\n\n                CONDITION && binding.value();\n            });\n            }\n        }\n    }\n    methods: {\n        toLoadMore() {\n            // 这里可以做你想做的任何事 到底执行\n        }\n    }\n}\n```\n"},{"title":"实现可搜索可分片加载的select组件","url":"/Roundtables/Question-Bank/vue/v-search-select.html","content":"# 实现可搜索可分片加载的select组件\n## 封装```Element UI Select```组件和```v-infinite-scroll```指令\n\n源码如下：\n\n```html\n<template>\n  <el-select\n    filterable\n    remote\n    clearable\n    reserve-keyword\n    :value=\"value\"\n    :remote-method=\"remoteMethod\"\n    :loading=\"loading\"\n    v-bind=\"$attrs\"\n    @change=\"val =>$emit('change', val)\"\n  >\n    <slot v-bind:list=\"displayedList\">\n      <el-option\n        v-for=\"item in displayedList\"\n        :key=\"item[valueKey]\"\n        :label=\"item[labelKey]\"\n        :value=\"item[valueKey]\"\n      >\n        <slot name=\"option\" v-bind:item=\"item\"/>\n      </el-option>\n    </slot>\n    <span\n      v-if=\"displayedList.length\"\n      v-infinite-scroll=\"loadMore\"\n      infinite-scroll-delay=\"300\"\n      :infinite-scroll-immediate=\"false\"\n    ></span>\n  </el-select>\n</template>\n\n<script>\nexport default {\n  name: \"SearchSelect\",\n  model: {\n    prop: \"value\",\n    event: \"change\"\n  },\n  props: {\n    value: {\n      validator(value) {\n        return (\n          Array.isArray(value) ||\n          typeof value === \"string\" ||\n          typeof value === \"number\"\n        );\n      }\n    },\n    dataSource: {\n      type: Array\n    },\n    labelKey: {\n      type: String\n    },\n    valueKey: {\n      type: String\n    },\n    chunkSize: {\n      type: Number,\n      default: 100\n    },\n    customSearch: {\n      type: Function,\n      required: false\n    }\n  },\n  data() {\n    return {\n      loading: false,\n      range: [-this.chunkSize, 0],\n      matchedList: [],\n      displayedList: []\n    };\n  },\n  methods: {\n    /** 搜索框搜索逻辑 */\n    async remoteMethod(query) {\n      if (query !== \"\") {\n        if (this.customSearch) {\n          console.log(\"远程搜索中...\");\n          this.loading = true;\n          this.matchedList = await this.customSearch(query);\n          this.loading = false;\n        } else {\n          console.log(\"本地搜索\");\n          this.matchedList = this.dataSource.filter(item => {\n            return (\n              item[this.labelKey].toLowerCase().indexOf(query.toLowerCase()) >\n              -1\n            );\n          });\n        }\n\n        this.range[0] = 0;\n        this.range[1] = this.chunkSize;\n        this.displayedList = this.matchedList.slice(...this.range);\n      } else {\n        this.matchedList = [];\n      }\n    },\n    /** 滚动加载更多参与人 */\n    loadMore() {\n      if (this.range[0] > this.matchedList.length) {\n        console.log(\"no more item found\");\n        return;\n      }\n\n      this.range[0] += this.chunkSize;\n      this.range[1] += this.chunkSize;\n      this.displayedList.push(...this.matchedList.slice(...this.range));\n    }\n  }\n};\n</script>\n```\n\n### 使用方法\n\n<iframe\n  src=\"https://codesandbox.io/embed/vue-template-b3n9o?fontsize=14&hidenavigation=1&theme=dark\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"Vue Template\"\n  allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\"\n  sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"\n></iframe>\n"},{"title":"Vue框架基础","url":"/Roundtables/Question-Bank/vue/vue-base.html","content":"# Vue框架基础\n\n比较熟悉vue的同学都很清楚，vue2.x在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。\n\n## Vue响应式原理\n\n### Vue的响应式系统\n响应式系统简述:\n\n任何一个 Vue Component 都有一个与之对应的 Watcher 实例。\nVue 的 data 上的属性会被添加 getter 和 setter 属性。\n当 Vue Component render 函数被执行的时候，data 上会被 触碰(touch)，即被读，getter 方法会被调用，此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)\ndata 被改动时（主要是用户操作），即被写，setter 方法会被调用，此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新。\n\n\n### Vue2.x响应式数据原理\nvue2.x中如何监测数组变化？  使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。\n\n### Vue3.x响应式数据原理\n怎么解决Proxy只会代理对象的第一层？ Vue3 会 判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。\n监测数组的时候可能触发多次get/set，如何防止触发多次呢？  可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。\n\n### Proxy与Object.defineProperty的优劣对比\n\nProxy的优势如下:\n- Proxy可以直接监听对象而非属性\n- Proxy可以直接监听数组的变化\n- Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的\n- Proxy返回的是一个新对象，可以只操作新的对象达到目的，而Object.defineProperty只能遍历对象属性直接修改\n- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利\n\nObject.defineProperty的优势如下:\n- 兼容性好，支持IE9\n\n## 虚拟Dom比普通Dom性能更好吗？(虚拟DOM优劣势)\n\n传送门：[虚拟Dom比普通Dom性能更好吗？(虚拟DOM优劣势)](../react/react-virtual-dom.html#虚拟dom比普通dom性能更好吗？-虚拟dom优劣势)\n\n::: tip AST是VNode吗\n- AST是指抽象语法树（abstract syntax tree），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。Vue在mount过程中，template会被编译成AST语法树。\n- 然后，经过generate（将AST语法树转化成render function字符串的过程）得到render函数，返回VNode。即 `VNode是由渲染函数得出的真实DOM的抽象`。\n:::\n\n## 既然Vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟DOM进行diff检测差异? 「pull、push」\n\n现代前端框架有两种方式进行「变化侦测」，一种是pull，一种是push。\n### pull\n- `React` 的 setState 和（早期）Angular 的脏检查都是 `pull`：即 系统不知道数据是否已改变，需要进行 pull。\n- 以React为例，用 setState API显式更新，然后React会进行一层层的 VDOM Diff操作找出差异，之后Patch到DOM上。也就是说，React从一开始就不知道到底是哪发生了变化，只是知道 “有变化了”，然后再进行比较暴力的Diff操作查找 “哪发生变化了”。\n\n### push\n- 相比之下 push 在数据变动时会立刻知道哪些数据改变，但这里还有个粒度问题。如果 pull 是完全粗粒度的，那么 push 可以进行更细粒度的更新。push 方式 要做到 粒度掌控，就需要付出 相应内存开销、建立依赖追踪开销的代价。\n- 以`Vue`为例，当 Vue 初始化时，就会对数据data进行依赖收集，一但数据发生变化，响应式系统就会立刻知道 “在哪发生变化了”。而Vue的每一次数据绑定，就需要一个Watcher，如果粒度过细，就会有太多的Watcher，开销太大，但如果粒度过粗，又无法精准侦测变化。\n- 因此，Vue 选择的是中间的 **「混合式：`push + pull`」**：Vue在`组件级别`选择 push方式，每个组件都是 Watcher，一旦某个组件发生变化Vue立刻就能知道；而在组件内部选择 pull方式，使用 VDOM Diff 进行比较。\n\n## Vue为什么没有类似于React中shouldComponentUpdate的生命周期？\n承接上文：\n- 首先，React是以 pull 的方式侦测变化的，因为不能知道到底哪里发生了变化，所以会进行大量 VDOM Diff 差异检测，为了提升性能，就可以使用 SCU（shouldComponentUpdate）来避免对那些肯定不会变化的组件进行Diff检测。\n- 而Vue在组件级是push方式，在push阶段能够自动判断，无需手动控制Diff。在组件内是pull的方式，理论上是可以引入类似于 SCU的钩子来让开发者控制的，但是，通常合理大小的组件不会有过量的Diff 检测，手动优化的价值有限。因此Vue没有引入SCU。\n\n\n## 怎样理解Vue的单向数据流\n\n同：[什么叫做react「单向数据流」？](/Question-Bank/react/react-other-points.html#什么叫做react「单向数据流」？)\n\nprop只能向下传递，子组件不能改变prop（如果试图改变会报错），只能通过$emit派生事件给父组件修改。\n\n有两种常见的试图改变一个 prop 的情形 :\n- prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好**定义一个本地的 data 属性并将这个 prop 用作其初始值**：\n- prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来**定义一个计算属性**。\n\n## Vue2.x组件通信有哪些方式\n\n### 1、父子组件通信\n- 父->子props，子->父 $on、$emit；\n- ref 获取实例的方式调用组件的属性或者方法；\n- 获取父子组件实例 $parent、$children，耦合性太强，不推荐使用；\n- 使用 slot 插槽；\n\n### 2、兄弟组件通信\n- EventBus：通过EventBus（一个空的 Vue 实例作为中央事件中心）进行信息的发布与订阅，实现跨组件通信。（Vue.prototype.$bus = new Vue）\n- Vuex\n### 3、跨级组件通信\n- Vuex：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。“store”是一个容器，包含着应用中大部分的状态 ( state )。**Vuex与单纯的全局对象差别**在于：\n    - Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n    - 改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n- Provide、inject：官方不推荐使用，但是写组件库时很常用。允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深。\n- 通过根实例$root访问。\n- $attrs、$listeners\n    - $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n    - $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件。\n    \n#### 非prop特性\n*非prop特性: 一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性。*\n\n这种特性的意思是：没有被定义为 prop 的特性会`以HTML特性形式`，自动添加到`组件的根元素上`，将已有的**同名特性进行替换**或**与其进行智能合并**：\n- **替换/合并已有的特性**：这里的`以HTML特性形式`传到根元素，是当做dom属性传给根元素，并不是当做组件属性传给根元素的，即如果根组件是个封装组件，而不是原生标签的话，非props属性也只是当做普通dom属性传给根组件，想要当做组件属性传给根组件使用，还是要主动v-bind=\"$attrs\"。\n- **禁用特性继承**：`inheritAttrs: false` 是不影响class与style的，它与 **$attrs** 配合，你就禁用根组件继承，并可以v-bind到非根元素上了。\n\n## nextTick 实现原理是什么？\n在下次 DOM 更新循环结束后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用：\n\n1. nextTick 默认会以 micro-task 的方式执行，优先检测是否支持 `Promise`；\n2. 不支持的话，直接指向 macro-task，优先检测是否支持 `setImmediate`（高版本IE和Etage支持）；\n3. 不支持的话，再去检测是否支持 micro-task 的 `MessageChannel`（因为兼容性，vue2.5开始抛弃了MutationObserver）；\n4. 如果仍不支持，最终降级为 macro-task `setTimeout 0`；\n\n默认的情况，会先以 micro task 方式执行，因为 micro task 可以在一次 tick 中全部执行完毕，在一些有重绘和动画的场景有更好的性能。\n\n但是由于 micro task 优先级较高，在某些情况下，可能会在事件冒泡过程中触发，导致一些问题，所以有些地方会强制使用 macro task（如 v-on）。\n\n**注意**：之所以将 nextTick 的回调函数放入到「数组队列」中一次性执行，而不是直接在 nextTick 中执行回调函数，是为了保证在同一个tick内多次执行了 nextTcik，不会开启多个异步任务，而是把这些异步任务都压成一个同步任务，在下一个tick内执行完毕。\n\n*react 中没有nextTick，可以使用 setTimeout 0秒 代替。*\n\n## Vue的生命周期\n- **beforeCreate**：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。\n- **created**：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，**在这里更改数据不会触发updated函数**。可以做一些初始数据的获取，**在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom**。\n- **beforeMount**：发生在挂载之前，**在这之前template模板已导入渲染函数编译**。而当前阶段**虚拟Dom已经创建完成，即将开始渲染**。在此时也可以对数据进行更改，不会触发updated。\n- **mounted**：在「编译好的模板挂载到页面上」完成后发生，在当前阶段，**真实的Dom挂载完毕**，**数据完成双向绑定**，可以访问到Dom节点，**使用$refs属性对Dom进行操作**。\n- **beforeUpdate**：发生在更新之前，也就是响应式数据发生更新，**虚拟dom重新渲染之前被触发**，**你可以在当前阶段进行更改数据，不会造成重渲染**。\n- **updated**：发生在更新完成之后，当前阶段**组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新**。\n- **beforeDestroy**：发生在实例销毁之前，在当前阶段**实例完全可以被使用**，我们可以在这时进行**善后收尾**工作，比如**清除计时器**。\n- **destroyed**：发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。\n- *activited*：keep-alive 专属，组件被激活时调用。\n- *deactivated*：keep-alive 专属，组件被销毁时调用。\n\n#### this.$refs为什么会是undefined\n父组件可以通过this.$refs.xx.fn调用子组件里的函数，但是有时会出现 fn 未定义的情况，这是为什么呢？\n\n`$refs` 只会在组件`渲染完成之后生效`，并且它们`不是响应式的`。这仅作为一个用于直接操作子组件的“逃生舱”——你**应该避免在模板或计算属性中访问** `$refs`。\n\n**解决办法**：\n1. 如果你在mounted里获取this.$refs，因为dom还未完全加载，所以你是拿不到的，update阶段则是完成了数据更新到 DOM 的阶段(对加载回来的数据进行处理)，此时，就可以使用this.$refs了。\n2、如果写在method中，那么可以使用 this.$nextTick(() => {}) 等页面渲染好再调用，这样就可以了。\n\n\n## Vue中父子组件生命周期执行顺序\n\n- 加载渲染过程\n    - `父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted`\n- 父子组件更新过程（相互有影响时）\n    - `父beforeUpdate->子beforeUpdate->子updated->父updated`\n- 父子组件更新过程（相互无影响）\n    - `自身beforeUpdate -> 自身updated`\n- 销毁过程\n    - `父beforeDestroy->子beforeDestroy->子destroyed->父destroyed`\n\n## 接口请求一般放在哪个生命周期中？\n可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n\n推荐在 `created` 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n- 能更快获取到服务端数据，减少页面 loading 时间；\n- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；\n\n\n## Vue父组件如何监听子组件的生命周期\n可以手动通过 $emit 触发父组件的事件，但更简单的方式可以在父组件引用子组件时通过`@hook`来监听：\n```js\n//  Parent.vue\n<Child @hook:mounted=\"doSomething\" ></Child>\n\ndoSomething() {\n   console.log('父组件监听到 mounted 钩子函数 ...');\n},\n    \n//  Child.vue\nmounted(){\n   console.log('子组件触发 mounted 钩子函数 ...');\n},\n\n// 以上输出顺序为：\n// 子组件触发 mounted 钩子函数 ...\n// 父组件监听到 mounted 钩子函数 ...     \n```  \n`@hook`不仅可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。\n\n\n## Computed 和 Watch\n### Computed\n- 本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。\n- 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。\n### Watch\n- 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。\n- 当我们需要**深度监听对象中的属性**时，可以打开`deep：true`选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听。\n    - watch不但可以监听键路径，还可以监听一个未被定义的计算属性(即定义一个函数来监听)，vm.$watch会返回一个unwatch函数，用来停止触发回调。\n\n## v-if和v-show的区别\n- `v-if` 是真正的条件渲染，会控制真实DOM元素的销毁和重建。\n- `v-show` 的元素`始终会被渲染`，只是简单地切换元素的 CSS 属性 `display`。如果条件不成立，元素`display: none`（在Dom tree中，但因为不在Css tree中，所以也就不在render tree中），右键检查元素的话也是有Dom元素结构的，因为在Dom tree中。\n\n传送门：结合 [display: none与 visibility: hidden]() 一起理解。\n\n## 组件中的data为什么是一个函数？\n一个组件被复用多次的话，也就会创建多个实例。本质上，`这些实例用的都是同一个构造函数`。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。\n\n\n## v-model的原理\nv-model本质就是一个语法糖，可以看成是`value + input`方法的`语法糖`。 可以通过**model属性**的**prop和event**属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。  \n\n## Vue事件绑定原理说一下\n原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。\n\n## Vue模版编译原理（compiler）?\n简单说，Vue complier 是将 template 转化成一个 render 字符串。会经历以下阶段：\n\n1. **parse过程（生成AST树）**：\n    - 首先解析模版，生成`AST语法树`(一种用JavaScript对象的形式来描述整个模板)。使用`大量的正则表达式对模板进行解析`，遇到标签、文本的时候都会执行对应的钩子进行相关处理。\n2. **optimize过程（优化，标记静态节点diff跳过）**：\n    - Vue的数据是响应式的，但`其实模板中并不是所有的数据都是响应式的`。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是`深度遍历AST树`，按照相关条件对树节点进行标记。这些`被标记的节点(静态节点)`我们就可以`跳过对它们的比对`，对运行时的模板起到很大的优化作用。\n3. **generate过程（生成render字符串）**：\n    - 编译的最后一步是`将优化后的AST树转换为可执行的代码，即render函数`（而render函数会返回VNode）。\n\n## Vue双向绑定原理实现\nView 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View（4 个步骤）：\n1. 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。\n2. 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。\n3. 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。\n4. 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。\n![vue双向绑定](./images/vue-bind.png)\n\n## Vue2.x和Vue3.x渲染器的diff算法:\n简单来说，diff算法有以下过程\n\n- 同级比较，再比较子节点\n- 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)\n- 比较都有子节点的情况(核心diff)\n- 递归比较子节点\n\n正常Diff两个树的时间复杂度是`O(n^3)`，但实际情况下我们`很少会进行跨层级的移动DOM`，所以Vue将Diff进行了优化，从`O(n^3) -> O(n)`，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。\nVue2的核心Diff算法采用了`双端比较`的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。\nVue3.x借鉴了 ivi算法和 inferno算法，在创建VNode时就确定其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。该算法中还运用了`动态规划`的思想求解最长递归子序列。\n\n::: details\n比较只会在同层级进行, 不会跨层级比较，复杂度为O(n)。\n如果不值得比较时，新节点直接把老节点整个替换了；如果值得比较会执行patchVnode(oldVnode, vnode)，diff的核心实现主要通过两个方法，patchVnode 与 updateChildren 。\npatchVnode 有两个参数，分别是老节点 oldVnode, 新节点 vnode 。主要分五种比较情况：\n- if (oldVnode === vnode)，他们的引用一致，可以认为没有变化。\n- if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用Node.textContent = vnode.text。\n- if( oldCh && ch && oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用 updateChildren 函数比较子节点，这是diff的核心，后边会讲到。\n- if (ch)，只有新的节点有子节点，调用createEle(vnode)，vnode.el已经引用了老的dom节点，createEle函数会在老dom节点上添加子节点。\n- if (oldCh)，新节点没有子节点，老节点有子节点，直接删除老节点。\nupdateChildren 是关键，这个过程可以概括如下：\n\noldCh 和 newCh 各有两个头尾的变量 StartIdx 和 EndIdx ，它们的2个变量相互比较，一共有4种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。\n:::\n\n## Vue中的key到底有什么用\nkey是为Vue中的vnode唯一标记id，通过这个key，diff操作可以更准确、更快速。\n\n- **准确**: **如果不加key，那么vue会选择复用节点**(Vue的`就地更新策略`)，导致之前节点的状态被保留下来，会产生一系列的bug.\n- **快速**: key的唯一性可以被Map数据结构充分利用，相比于遍历查找的时间复杂度`O(n)`，Map的时间复杂度仅仅为`O(1)`.\n\n## 虚拟Dom以及key属性的作用\n（首先明白：使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点）由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。\n\nVirtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。\n\nVirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。\n\n**「key的作用是尽可能的复用 DOM 元素。」**：新旧 children 中的节点只有顺序是不同的时候，「最佳实践」应该是通过移动元素的位置来达到更新的目的。因此，需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。\n\n## keep-alive\nkeep-alive可以实现`组件缓存`，当组件切换时不会对当前组件进行卸载（切换时不卸载）。\n- 常用的3个属性`include/exclude`，通过字符串或正则表达式匹配，允许组件有条件的进行缓存；`max`，最多允许缓存的组件数目。\n    - include 表示只有名称匹配的组件会被缓存\n    - exclude 表示任何名称匹配的组件都不会被缓存\n    - 其中 exclude 的优先级比 include 高\n    - max 表示允许缓存的组件数目，如果超出，keep-alive 会通过 `LRU(Least Recently Used)`-最近最少使用算法，来丢弃最久未被使用的组件。\n- 两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。\n\n\n## Vue SSR\nSSR也就是服务端渲染，也就是**将Vue在客户端把标签渲染成HTML的工作放在`服务端完成`，然后再把html片段直接返回给客户端**。\n\n- 优点：SSR有着更好的SEO、并且首屏加载速度更快等优点。\n::: details\n- 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n- 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n:::\n- 缺点：开发条件会受到限制、更多的服务器负载。\n::: details\n- 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n- 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n:::\n\n## Vue 中 v-html 会导致什么问题\n在网站上动态渲染任意 HTML，很容易导致 XSS 攻击。所以只能在可信内容上使用 v-html，且永远不能用于用户提交的内容上。\n\n## Vue性能优化\n\n- 编码阶段\n    - 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\n    - 不推荐在同一元素上使用 v-if 和 v-for：当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中（这种场景建议使用 computed，先对数据进行过滤）。\n    - SPA 页面采用keep-alive缓存组件\n    - 在更多的情况下，使用v-if替代v-show\n    - 使用路由懒加载、异步组件\n    - 防抖、节流\n    - 第三方模块按需导入\n    - 优化无限列表性能\n- SEO 优化\n    - 预渲染\n    - 服务端渲染SSR\n- 打包优化\n    - 压缩代码\n    - Tree Shaking/Scope Hoisting\n    - 使用cdn加载第三方模块\n    - 多线程打包happypack\n    - splitChunks抽离公共文件\n    - sourceMap优化\n    - 构建结果输出分析\n- 基础WEB技术优化\n    - 开启 gzip 压缩\n    - 浏览器缓存\n    - CDN 的使用\n    - 使用 Chrome Performance 查找性能瓶颈\n- 用户体验优化\n    - 骨架屏\n    - PWA \n\n\n## Vue3.0 有哪些方面的更新\n\n- （1）监测机制的改变\n- （2）模板\n- （3）对象式的组件声明方式\n- （4）其它方面的更改\n\n## 参考链接\n- [「面试题」20+Vue面试题整理(持续更新)](https://juejin.im/post/5e649e3e5188252c06113021#heading-12)\n- [面试必备的13道可以举一反三的Vue面试题](https://juejin.im/post/5d41eec26fb9a06ae439d29f#heading-1)\n- [30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度](https://juejin.im/post/5d59f2a451882549be53b170）)\n- [深入剖析：Vue核心之虚拟DOM](https://juejin.im/post/5d36cc575188257aea108a74#heading-14)\n- [0 到 1 掌握：Vue 核心之数据双向绑定](https://juejin.im/post/5d421bcf6fb9a06af23853f1)\n- [Vue3为什么选择Proxy做双向绑定？](https://mp.weixin.qq.com/s?__biz=MzI3NjM1OTI3Mw==&mid=2247483695&idx=1&sn=8f4d74b58f4102eced8089bcaac4c443&chksm=eb77f029dc00793f502d4a39819e488d560e6bf7d268f3e987a03d43d71a07a2edab59d8d78f#rd)\n- [2020年大厂面试指南 - Vue篇](https://juejin.im/post/5e4d24cce51d4526f76eb2ba)\n\n"},{"title":"vue-router路由","url":"/Roundtables/Question-Bank/vue/vue-router.html","content":"# vue-router路由\n\n\n\n## vue-router模式\n\n传送门:[前端路由模式](../bom/router.html#前端路由模式)\n\n- hash：使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；\n- history：依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；\n- abstract：支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。\n\n## vue-router中 $route与$router的区别：\n- `$route`为当前router跳转对象，里面可以获取name、path、query、params等；\n- `$router`为VueRouter实例，想要导航到不同URL，则使用$router.push方法，返回上一个history使用$router.go方法。\n\n#### this.$router.push中使用params和使用query有什么不同？\n相同点都是带参数过去，不同点是：\n- params需要在路由设置中添加参数（ path: '/projectAdd/:id'），而query不需要；\n- 跳转后在URL的显示不同，params显示的是（http://localhost:8082/#/projectAdd/6），query显示的是（http://localhost:8082/#/projectAdd?toseId=6）；\n- 接收方式不同，params为this.$route.params，query为this.$route.query。\n- path应与query配套使用，因为提供path时，会忽略params参数；name应与params配套使用。\n\n```js\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n如果提供了 path，则 params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path：\n```js\nconst userId = '123'\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n*注意*：如果跳转的url只是id改变，页面并不会刷新，这是因为路由是相同的，vue认为是同一个页面，从而复用已加载的页面，而不重新加载。解决办法是：通过`router-view`**动态绑定key值**，这样当重新跳转的时候因为key值不同，那么vue在路由切换时都会重新渲染触发钩子了。\n\n## vue-router导航守卫\n\n### 路由拦截（路由元信息与导航守卫）\n**路由拦截**的主要作用是提供`权限控制`，比如有的页面需要登录了才能进入，有些页面不同身份渲染不同。这里主要介绍下典型的应用：登录拦截。\n- 首先在定义路由时添加`路由元信息meta`，设置字段requireAuth的布尔值，用于判断该路由的访问是否需要登录。true则顺利进入路由，false就进入登录页面。\n- 利用`vue-router`提供的`钩子函数router.beforeEach((to, from, next) => { })`对路由设置全局守卫，to是即将进入的路由对象，from是离开的路由对象，next是resolve钩子的函数，是必须被调用的。路由匹配的所有路由记录会暴露为$route对象。通过遍历$route.matched数组来检查记录中的meta字段。\n\n### 导航守卫钩子\n- 全局前置/钩子：beforeEach、beforeResolve、afterEach\n- 路由独享的守卫：beforeEnter\n- 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n完整的导航解析流程见官网：[完整的导航解析流程](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B)\n\n\n"},{"title":"Vuex状态管理","url":"/Roundtables/Question-Bank/vue/vuex.html","content":"# Vuex状态管理\n\n## Vuex原理\n把所有组件的所有数据状态放到统一的内存空间（`state`）中做管理，`state`渲染映射到Vue组件上，组件对于状态的修改只能通过`dispatch Actions`进而`commit Mutations`(或者组件直接`commit Mutations`)的方式，这种将组件的共享状态抽取出组件外部进行管理的方式保证了**数据流的单向性**，进而使状态可以安全的维护。\n\n![Vuex工作原理](./images/vuex.png)\n\n## Vuex组成\n- `State`：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\n- `Getter`：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。\n- `Mutation`：是唯一更改 store 中状态的方法，且必须是同步函数。\n- `Action`：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\n- `Module`：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n\n## dispatch和commit提交mutation的区别\n- `commit => mutations`，用来触发`同步`操作的方法。\n- `dispatch => actions`，用来触发`异步`操作的方法。actions还可以封装多个mutations提交。\n\n## 为什么Vuex中mutation不能执行异步操作\n每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。\n\n如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\n"},{"title":"watch 新旧值一致","url":"/Roundtables/Question-Bank/vue/watch.html","content":"# watch 新旧值一致\n> [Demo](https://codesandbox.io/s/watch-save-value-u1i6y)\n\n## 场景\n```javascript\n<template>\n  <div class=\"watch\">\n    <span>params.name:</span>\n    <input type=\"text\" v-model=\"params.name\">\n  </div>\n</template>\n```\n\n```javascript\ndata() {\n    return {\n      params: {}\n    };\n  },\n  watch: {\n    params(newVal, oldVal) {\n      console.log(\"普通方式oldVal\", oldVal);\n      console.log(\"普通方式newVal\", newVal);\n    }\n  }\n\n```\n如上代码，input输入2，打印结果只打印一次且新旧值相等\n\n![console_2](./images/watch_1.png)\n\n\n## 官方的解释\n> 注意：在变异(不是替换)对象或者数组时，旧值将与新值相等，因为它们的引用指向同一个对象/数组，Vue不会保留变异之前值的副本\n\n## 解决方案\n\n1. 监听到具体项\n\n```javascript\nwatch() {\n    \"params.name\"(newVal, oldVal) {\n      console.log(\"监听到具体项oldVal\", oldVal);\n      console.log(\"监听到具体项newVal\", newVal);\n    }\n}\n```\ninput输入2，再输入3，打印结果如下：\n![console_2](./images/watch_2.png)\n\n\n2. 监听一个计算属性\n```javascript\nwatch() {\n    getParamsName(newVal, oldVal) {\n      console.log(\"监听计算属性oldVal\", oldVal);\n      console.log(\"监听计算属性newVal\", newVal);\n    }\n},\nmethods: {\n    getParamsName() {\n      return this.params.name;\n    }\n}\n```\ninput输入2，再输入3，打印结果如下：\n![console_3](./images/watch_3.png)\n\n\n**或者**你想直接监听一个计算属性，但是**返回整体**，而不是具体项\n```javascript\nwatch() {\n    getParamsName(newVal, oldVal) {\n      console.log(\"监听计算属性oldVal\", oldVal);\n      console.log(\"监听计算属性newVal\", newVal);\n    }\n},\nmethods: {\n    getParamsName() {\n      return JSON.parse(JSON.stringify(this.params));\n    }\n}\n```\ninput输入2，再输入3，打印结果如下：\n![console_4](./images/watch_4.png)\n"},{"title":"关于babel","url":"/Roundtables/Question-Bank/webpack/babel.html","content":"# 关于babel\n\n## 什么是babel\nBabel: The compiler for writing next generation JavaScript。\n- `babel`最开始的名字叫`6to5`，作用是把一些浏览器根本就不识别的代码，转换成浏览器识别的代码。\n- `babel` 对于 `AST` 就相当于 jQuery 对于 DOM, 就是说`babel`给予了我们便捷查询和修改 `AST` 的能力。\n    - 抽象语法树(`AST` -> Abstract Syntax Tree)：将程序用树状结构表示出声明、变量、函数等等。**是不同代码转换过程中的桥梁**。\n    ![AST长什么样](./images/AST.png)\n\n## 3步转换\n为了转换代码，babel做了三件事：\n- `Parser`：解析原有代码转换为AST。**(code => 旧AST)**\n- `Transformer`：利用配置好的`plugins/presets`把`Parser`生成的AST转变为新的AST。**（旧AST => 新AST）**\n- `Generator`：把转换后的新AST生成新的代码。**（旧AST => code）**\n\n![babel 3步转换](./images/babel.png)\n\n#### Parser 解析（步骤一）\n解析步骤接收代码并输出 AST,这其中又包含两个阶段**词法分析**和**语法分析**。词法分析阶段把字符串形式的代码转换为 令牌（tokens）流。语法分析阶段会把一个令牌流转换成 AST 的形式,方便后续操作。\n\n#### Transformer生成（步骤二*重点）\nbabel的最主要工作都集中Transformer上，即在把解析生成的AST经过`plugins/presets`然后去生成新的AST。babel拿到抽象语法树后会使用**babel-traverse**进行递归的**深度优先树状遍历**，并按照特定配置规则完成转换。\n\n#### Generator 生成（步骤三）\n代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会**创建源码映射**（`source maps`）。代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。\n\n"},{"title":"Code Spliting","url":"/Roundtables/Question-Bank/webpack/code-splitting.html","content":"# Code Spliting\n\n## 什么是 code splitting\n\n代码分割（code splitting）是指将项目代码构建打包（bundling）后根据指定规则分割成多个 bundles（输出文件），这些模块文件可以被按需动态加载或者并行加载。最要用来优化代码加载时的资源大小、以及优先级。正确使用代码分割，可以优化提升资源加载效率。\n通过 webpack，一般可以从以下三个方面去配置代码分割：\n\n- 入口文件方式：通过手动指定 webpack 打包入口文件（entry），可以配置多个入口文件，打包不同的代码，然后根据业务需求，实现代码块的加载。\n- 动态引入 lazy-load：通过使用例如 es6 的[ import() ](http://webpack.js.org/api/module-methods/#import-1)、[require.ensure](https://webpack.js.org/api/module-methods#requireensure)、[AMD](https://webpack.js.org/api/module-methods#amd)等方法来指定代码进行构建分割\n- webpack 自动分割：通过[SplitChunksPlugin](https://webpack.js.org/plugins/split-chunks-plugin/)来配置代码构建的自动分割。\n\n## 基本的分割方式\n\n### 防止重复(prevent duplication)\n\n`CommonsChunkPlugin` 已废弃。\n[SplitChunksPlugin](https://www.webpackjs.com/plugins/commons-chunk-plugin/) 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。\n无需安装，简单配置如下，详细配置看文档：\n\n```json\n{\n  \"output\": {\n    // ...\n  },\n  \"optimization\": {\n    \"splitChunks\": {\n      \"chunks\": \"all\"\n    }\n  }\n}\n```\n\n### 动态导入\n\n先移除配置中都`optimization.splitChunks`\n\n```javascript\n// config/webpack.common.js\n{\n    output: {\n        filename: '[name].bundle.js',\n        chunkFilename: '[name].bundle.js',\n        publicPath: '../dist/',\n        path: path.resolve(__dirname, '../dist')\n     },\n}\n配置好了，试试吧：\nfunction getComponent() {\n    return import(/* webpackChunkName: \"lodash\" */ 'lodash')\n        .then(_ => {\n            const element = document.createElement('div');\n            element.innerHTML = _.join(['Hello', 'Webpack', ' ']);\n            return element;\n        })\n        .catch(error => 'An error occurred while loading the component');\n}\n\ngetComponent().then(component => {\n    document.body.appendChild(component);\n});\n```\n\n注意上面的注释`/* webpackChunkName: \"lodash\" */`和前面的配置`chunkFilename: '[name].bundle.js',`, 这里实现了动态导入，语意很明确，我们打包的时候会将 lodash 单独写入一个名为`lodash.chunk.js`的 chunk 文件。\n\n### 懒加载\n\n使用上面的动态加载，我们还可以通过触发了某个事件或交互来加载模块。\n注意当调用 ES6 模块的 import() 方法（引入模块）时，必须指向模块的 .default 值，因为它才是 promise 被处理后返回的实际的 module 对象。\n\n#### 各种框架实现懒加载\n\n- React: [Code Splitting and Lazy Loading](https://reacttraining.com/react-router/web/guides/code-splitting)\n- Vue: [Lazy Load in Vue using Webpack's code splitting](https://alexjoverm.github.io/2017/07/16/Lazy-load-in-Vue-using-Webpack-s-code-splitting/)\n- AngularJS: [AngularJS + Webpack = lazyLoad](https://medium.com/@var_bin/angularjs-webpack-lazyload-bb7977f390dd)\n\n### 预加载\n\n[详细类容](https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules)\n\n> webpack 4.6.0+ adds support for prefetching and preloading.\n\n**LoginButton.js**\n\n```javascript\n//...\nimport(/* webpackPrefetch: true */ \"LoginModal\");\n```\n\nThis will result in `<link rel=\"prefetch\" href=\"login-modal-chunk.js\">` being appended in the head of the page, which will instruct the browser to prefetch in **idle time** the `login-modal-chunk.js` file.\n\n> webpack will add the prefetch hint once the parent chunk has been loaded.\n\nPreload directive has a bunch of differences compared to prefetch:\n\n<details>\n    <summary>预加载的块会和父块并行下载。预取的块会等父块加载完成后。</summary>\n    A preloaded chunk starts loading in parallel to the parent chunk. A prefetched chunk starts after the parent chunk finishes loading.\n</details>\n<details>\n    <summary>预加载的块拥有中等优先级，会立刻下载。预取块会等浏览器空闲时下载。</summary>\n    A preloaded chunk has medium priority and is instantly downloaded. A prefetched chunk is downloaded while the browser is idle.\n</details>\n<details>\n    <summary>父块应该立即请求预加载的块。预取的块可以在将来的任何时候使用。</summary>\n    A preloaded chunk should be instantly requested by the parent chunk. A prefetched chunk can be used anytime in the future.\n</details>\n\n- Browser support is different.\n\n**ChartComponent.js**\n\n```javascript\n//...\nimport(/* webpackPreload: true */ \"ChartingLibrary\");\n```\n\nWhen a page which uses the ChartComponent is requested, the charting-library-chunk is also requested via `<link rel=\"preload\">`. Assuming the page-chunk is smaller and finishes faster, the page will be displayed with a LoadingIndicator, until the already requested charting-library-chunk finishes. This will give a little load time boost since it only needs one round-trip instead of two. Especially in high-latency environments.\n\n> Using webpackPreload incorrectly can actually hurt performance, so be careful when using it.\n\n上面介绍了代码分割的各种方式，适当的分割可以提高加载效率，下面我们来看一下何时需要分割？如何分割？\n\n## 考虑什么情况下开始使用代码分割\n\n- 大项目、代码量庞大\n- 代码首屏利用率低\n- 持久化缓存，分割不经常变动的第三方库\n\n## 优势与劣势\n\n合理并且正确的使用代码分割，可以极大的提升代码庞大项目的资源加载效率：\n\n- 实现按需加载，提高页面代码使用率\n- 大文件分割成多个小文件，并行加载，提高低网速下的资源加载效率\n- 有利用于构建出更适合持久化缓存的打包文件\n\n但是，如果使用不当，也会带来方向负面影响：\n\n- 过多的并行加载，挤占 http 线程，影响速度\n- 影响代码复用，同样的代码块被重复构建进不同的分割后的文件中\n- 非必要的分割，影响代码逻辑更快执行（小文件无需分割、首屏加载即会用到的代码无需分割）\n- 分割后的文件由于重复代码块过大，导致分割后的文件体积庞大，拖慢加载效率\n\n## code splitting 应该是基于路由还是基于组件？\n\n在 SPA 项目中，我们一般都会基于路由组织不同的功能模块代码。所以，但我们考虑对现有代码进行代码分割时，首先要考虑的是基于路由来做代码分割。\n但是这样存在一些弊端：\n\n- 代码分割灵活性差，基于路由，也会受限于路由。网站的路由设计会极大影响代码分割。\n- 代码块复用性差：不同路由页面中用到的相通的代码块会被重复打包进各个路由 bundle 中\n- 某些复杂页面，bundle 后尺寸依然巨大\n\n在 react 项目中，页面都是有大大小小各种组件组合而来。所以基于组件的代码分割，会带来更灵活以及精确的代码分割策略。\n同时，由于路由渲染也是渲染到组件，所以基于组件去做代码分割，也同样适用于基于路由的代码按需加载实现。\n基于组件的代码分割，可以让我们更精确、灵活的去控制要 split 的代码。\n当然，除了以上两种思路，代码分割其实可以有其他的灵活配置方式，例如根据环境变量、根据服务器配置等。\n\n## 优化代码分割与动态加载\n\n- 利用 prefetch、preload 特性提前加载代码\n- 避免对已经很小的文件作继续分割\n- 考虑将公共代码单独分割\n- 避免单次加载产生过多的小文件\n"},{"title":"CSS的痛点","url":"/Roundtables/Question-Bank/work-practices/css-module.html","content":"---\ntitle: 简单易懂的CSS Modules\n---\n\n### CSS的痛点\n\n我们都知道，css入门简单，深入就比较难，样式简单维护难，css痛点有很多\n\n1. css的规则是全局的，任何一个组件的样式规则，都对真个页面有效，很容易出现全局污染（覆盖）问题\n\n2. 为了解决全局污染问题，那就吧class命名写长一点、加一层父级选择器、降低冲突几率，但css命名就混乱了\n\n3. 组件依赖管理不彻底，组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式\n\n\n### CSS Module\n为了解决一上问题，就产生css module, css module会产生局部作用域，它会产生一个独一无二的`class`名字，不会与其他同名选择器重名\n\n#### 启用 css module\n在项目里应用CSS Modules有很多方法，目前比较常用的是使用webpack的[css-loader](https://github.com/webpack-contrib/css-loader#css-modules),此处是与sass一起使用的\n\n```js\nmodule: {\n    rules: [\n      {\n        test: /\\.scss/,\n        exclude: /node_modules/,\n        use: [\n            {\n                loader: 'style-loader'\n            }, {\n                loader: 'css-loader',\n                options: {\n                    modules: true,   // 开启 css module\n                }\n            }, {\n                loader: 'postcss-loader'    // 自动添加css前缀\n            }, {\n                loader: 'sass-loader',\n                options: {\n                    sourceMap: true,\n                    outputStyle: {\n                        expanded: true\n                    }\n                }\n            }\n        ]\n      }\n    ]\n  }\n```\n\n#### 使用css module\n\n编写 scss\n```scss\n.root {\n  .text {\n    width: 200px;\n  }\n}\n```\n使用\n```typescript jsx\nimport styles from './index.scss';\n\n<div className={styles.root}>\n    <div className={styles.text}>test</div>\n</div>\n\n```\n编译之后\n![avatar](./images/WechatIMG939.png)\n可以看出css module为每个class生成了唯一的class类名，它将class转换成对应的全局唯一hash值来形成`局部作用域`。\ncss module默认使用的是`局部作用域`，就相当于给每个 class 名外加了一个 :local 这是默认的，也可以显式使用，\n但是当需要修改第三方组件的class时，就需要使用`全局作用域`来更改类\n\n```scss\n:local(.root) {     // 默认是局部作用域\n  :local(.text){\n    width: 200px;\n  }\n  :global {     // 修改第三方组件（antd）,使用全局作用域，但是他是相对于.root底下的全局作用域，所已完全不必担心污染其他组件\n    .ant-btn {\n      width: 200px;\n    }\n    .ant-input {\n      width: 200px;\n    }\n  }\n}\n```\n![avatar](./images/WechatIMG967.png)\n图上所知，加上global属性，就会在相对应的root底下的`全局作用域`找类名，那么他们在元素上用法的区别就是局部作用域需要使用js式（styls.xxx）;全局作用域的就是直接使用\n\n```typescript jsx\n.root {\n    .text {\n        width: 200px\n    }\n    :global {\n        .text2 {\n             width: 200px\n        }\n    }\n}\n\nimport styles from './index.scss';\n\n<div className={styles.root}>\n    <div className={styles.text}>test</div>\n    <div className='text2'>test2</div>  // 直接使用\n</div>\n\n```\n#### 其他\n*[vue中使用css module](https://vue-loader.vuejs.org/zh/guide/css-modules.html#%E7%94%A8%E6%B3%95)*\n\n### 结语\n无论是一直以来我们认真遵循的命名约定，还是这个新的CSS Modules，目的都是一样的：可维护的css代码。我觉得就CSS Modules基本还是在写css这一点来说，它还是很友好的。\n\n\n"},{"title":"vue css中/deep/用法","url":"/Roundtables/Question-Bank/work-practices/deepcss.html","content":"---\ntitle: vue css中/deep/深度选择\n---\n### vue css中/deep/用法\n\n`/deep/`的意思大概为深入的，深远的（深度选择）。Scoped CSS规范是Web组件产生不污染其他组件，也不被其他组件污\n染的CSS规范。这样在打包的时候会生成一个独一无二hash值，这样父组件的样式就不会影响到子组件了；再用别人或者第三\n方组件是，要是想修改其组件的样式，一般都是提取公共文件，但是存在问题是有时候你修改一处就可能影响到别的地方，这\n个时候就可以需要一种方式，既不影响别的地方，又能修改子组件的样式。\n\n- *加入scoped属性*\n\n![avatar](./images/WechatIMG8282.png)\n![avatar](./images/WechatIMG86.png)\n可以看出，scoped属性会将 template 中的每个元素加入 [data-v-xxxx]的hash值，但如果引用了第三方组件，`默认只会对组件的最外层（div）加入这个 [data-v-xxxx] 属性，但第二层开始就没有效果了`，如上图所示，第一层el-tabs加上了[data-v-xxxx]，底下\n的el-tabs__header就没有了\n\n\n- *这个时候修改样式，未加/deep/*\n\n![avatar](./images/WechatIMG85.png)\n![avatar](./images/noDeep.png)\n编译后的css可以看出，寻找的路径为`.m-transaction-details-wrapper .el-tabs .el-tabs__header[data-v-5419d6af]`\n但是在看html元素上，并没有在`.el-tabs__header`加入[data-v-5419d6af]，所以导致不生效\n\n- *加上/deep/*\n\n![avatar](./images/WechatIMG87.png)\n![avatar](./images/deep.png)\n此时编译后的css寻找路径为`.m-transaction-details-wrapper[data-v-5419d6af] .el-tabs .el-tabs__header`,就可以生\n效了，这类似于css module中的global属性，加上global修改第三方组件才能生效"},{"title":"前端工程化部署deploy","url":"/Roundtables/Question-Bank/work-practices/deploy.html","content":"# 前端工程化部署deploy\n\n> 本文记录了ESOP-FED 项目工程化部署方案，分别涉及 线上部署流程，nginx原理，cdn原理，CI/CD配置...\n\n----\n## 一、前端项目工程化部署流程\n\n1. 提交代码，push 到 git 远程仓库；\n2. 触发 gitlab-ci 的 runners，构建.gitlab-ci.yml中配置的 job；\n3. .gitlab-ci.yml中配置的job，大致会做：从仓库拉取项目代码到nginx服务器，运行 npm run build，运行 npm run cdn；\n4. 使用nginx作为静态服务器，代理静态服务，将前端构建好的静态资源dist文件包，都托管到指定服务目录，通过listen配置好的端口（默认80），即可访问静态服务；\n5. npm run build 会把构建好的代码输出到dist目录中，放到nginx静态资源服务器的指定目录里。为了优化，将大部分的静态资源托管到第三方cdn平台上，而在nginx服务器上只托管dist下的index.html入口文件就好了；\n6. npm run cdn 把静态资源（除入口文件外所有的 js，css，img，font等等）上传到 cdn。每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志；\n7. 通过浏览器，访问网站前端域名，网站通过index.html入口文件的script标签记录的链接，加载app.xxx.js（同步模块代码）、vendor.xxx.js（依赖包代码）、manifest.xxx.js（异步模块清单），当路由切换时动态获取异步模块；\n\n## 二、CI/CD相关知识\nCI/CD系统：持续集成和持续部署是微服务架构下的必要组成部分， `Jenkins`、Github 默认支持的 `Travis` 以及 `GitLab CI` 都是常用的 CI 工具。\nCI/CD持续集成和持续部署 就是指测试和发布环节，如果能够做到自动化，那么就可以大大加快开发迭代的速度。\n\n**GitLab CI 相关术语：**\n\n- Pipeline：流水线。一次 Pipeline 其实相当于一次构建任务。任何提交或者 MR 的合并都可以触发 Pipeline；\n```\n+------------------+           +----------------+\n|                  |  trigger  |                |\n|   Commit / MR    +---------->+    Pipeline    |\n|                  |           |                |\n+------------------+           +----------------+\n```\n- Stage：构建阶段。一次 Pipeline 中可以定义多个 Stages，所有 Stages 会按照顺序运行，只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功，任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败；\n```\n+--------------------------------------------------------+\n|  Pipeline                                              |\n|                                                        |\n|  +-----------+     +------------+      +------------+  |\n|  |  Stage 1  |---->|   Stage 2  |----->|   Stage 3  |  |\n|  +-----------+     +------------+      +------------+  |\n|                                                        |\n+--------------------------------------------------------+\n```\n- Jobs，构建工作。是最小的任务单元，每个job只负责一件事情，要么编译，要么测试等。可以在 Stages 里面定义多个 Jobs，一个Stage中的 Jobs 会并行执行，一个Stage中的 Jobs 都执行成功时，该 Stage 才会成功，任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败；\n```\n+------------------------------------------+\n|  Stage 1                                 |\n|                                          |\n|  +---------+  +---------+  +---------+   |\n|  |  Job 1  |  |  Job 2  |  |  Job 3  |   |\n|  +---------+  +---------+  +---------+   |\n|                                          |\n+------------------------------------------+\n```\n- GitLab Runner，是实际处理 Job 的，每个 Runner 可以单独配置，Runner 支持多种类型的 Job，同一时间单个 runner 只能处理一个 Job；\n- GitLab Multi Runner，是一个 GitLab 的开源项目，用来统一管理 Runner；\n- Executor，每个 Runner 都需要指定一个 Executor，来决定 runner 最终使用哪个执行器进行处理。\n\n**CI/CD流程：**\n一个典型的 Pipeline，一共有 5 个阶段，Build，Test，Release， Staging， Production，每个阶段里都至少有一个 Job，Test 中有两个 Job。GitLab 会从左往右依次把任务给到 Runner 处理，如果中途有一个任务没有处理成功的话，整个 Pipeline 就会退出。这就是持续集成（CI）、持续发布（CD） 的一个流程。\n\n**如何使用 GitLab CI：**\n- Gitlab-CI 是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。\n- GitLab 中提供了两种 Runner 的类型，特定的 Specific Runner（只能供部分项目使用），共享的 Shared Runner（所有 GitLab 中的项目都可以使用）；\n- 比如注册一个 Specific Runner：\n  - 第一步安装 GitLab Mutli Runner，直接采用二进制安装即可。\n  ```\n  # For Debian/Ubuntu\n  sudo apt-get install gitlab-ci-multi-runner\n\n  # For CentOS\n  sudo yum install gitlab-ci-multi-runner\n  ```\n  - 第二步注册Runner，`输入 Gitlab 地址、项目token、runner名称、runner描述、选择执行器类型（shell, docker, docker-ssh, ssh...）等`。注册好了，由于 Multi Runner 支持动态加载配置，所以 Runner 就立即生效了。\n  ```\n  $sudo gitlab-ci-multi-runner register\n  Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci )\n  http://gitlab.###.io/ci\n  Please enter the gitlab-ci token for this runner\n  ########################\n  Please enter the gitlab-ci description for this runner\n  my-runner\n  INFO[0034] fcf5c619 Registering runner... succeeded\n  Please enter the executor: shell, docker, docker-ssh, ssh?\n  shell\n  INFO[0037] Runner registered successfully. Feel free to start it, but if it's\n  running already the config should be automatically reloaded!\n  ```\n  - 最后，在项目根目录中添加 .gitlab-ci.yml 文件（此文件就是定义了Pipeline的执行方式），具体配置[gitlab-ci.yml](https://docs.gitlab.com/ee/ci/yaml/README.html)。gitlab-ci.yml文件配置的script，使用基本的shell脚本命令，[linux Shell教程](https://www.runoob.com/linux/linux-shell.html)。gitlab-ci.yml文件中的变量，如 $CI_PROJECT_ID，$CI_COMMIT_SHA，$CI_COMMIT_REF_NAME 等变量为 GitLab CI 变量，可以在 CI 流程中直接使用这些变量，具体参考 [GitLab CI Variables](https://docs.gitlab.com/ce/ci/variables/)。\n\n**为什么不是 GitLab CI 来运行那些构建任务？**\n- 构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。\n- GitLab CI 最大的作用是`管理各个项目的构建状态`，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 去做。Gitlab-runner 是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的`相互隔离的机器（或虚拟机）`。\n- GitLab Runner 不需要和Gitlab安装在同一台机器上，考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner应该安装到不同的机器上。\n\n**具体到我们的项目：**\n- 我们的项目选用的runner执行器是 shell，比较简单，如果选择 docker的话，需要额外指定镜像。\n- 目前我们主要共享172.30.xx.xx这台广州机房的测试机，其上面部署了tag为\"fed-shell-ci-cd\"的runnner。\n- 目前位于GZ_GZJF_xxxx上的测试服务（fed-shell-ci-cd）和gz_gzjf_xxxx 的线上发布服务（ci-fed-publish）的runner均已注册为Shared Runner，默认对所有项目启用生效。所以不再需要特地关联启用Specific Runner。\n\n## 三、CDN相关知识\n\n**什么是 CDN？**\nCDN（Content Delivery Network）即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。可以简单理解成：`CDN 就是一个能让用户以最快速度访问到相应资源的网盘。`\n\n**使用CDN平台**\n- SPA框架常用webpack来进行打包，最无脑的操作是 将打包后的dist文件整体扔到服务器上，但是用户在访问网站时，从哪个服务器拉取资源非常慢，且还要考做后端缓存。\n- 更科学的方式是将dist打包文件做“动静分离”：借助CDN加速，并且云平台的CDN还自带前端缓存，非常方便。很多平台都有云服务提供，如腾讯云、阿里云...在云平台的控制台开启“对象存储”服务后，开启对应的“加速域名”，此时，针对这个存储桶，就开启了 CDN 加速。“加速域名”就是 CDN 域名。执行npm run build后，打包后的项目文件都放在了/dist/文件下。可以配置webpack，将/dist/static/文件夹直接上传到云平台的对应存储桶的根目录下即可。\n- 具体上传cdn的方式，可以查看项目中的cdn.js文件。通过nodejs的rsync工具，同步文件到CDN上，每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志。\n```\nwebpack打包输出的\noutput: {\n    path: outputPath, // dist目录\n    publicPath: publicPath // 浏览器引用的资源文件公共path路径，即 CDN加速路径\n},\n```\n\n## 四、Nginx静态资源相关知识\n\n在前后端分离端项目里，前端的代码会被打包成为纯静态文件。使用 Nginx的目的就是`让静态文件运行起服务`，由于后端的接口也是分离的，直接请求可能会产生跨域问题，此时就需要Nginx转发代理后端接口。\n- 将前端代码打包后的dist文件放入指定服务目录\n- 将服务目录指定到spa-project/dist目录下即可代理静态服务\n- 配置里开启了gzip压缩，可以很大程度上减小文件体积大小\n- 将404错误页面重定向到index.html，可以解决前端history路由模式由于刷新页面访问不到服务出现404的问题\n- location为代理接口，可以转发代理后端的请求接口域名或者ip，即可解决接口跨域问题\n```\n// 示例\n# For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n\nuser nginx;\nworker_processes auto; #启动进程\nerror_log /var/log/nginx/error.log; #全局错误日志\npid /run/nginx.pid; #PID文件\n\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\n\nevents {\n    worker_connections 1024; #单个后台worker process进程的最大并发链接数 \n}\n\nhttp {\n    gzip on; #开启gzip压缩\n    gzip_min_length 1k; #设置对数据启用压缩的最少字节数\n    gzip_buffers    4 16k;\n    gzip_http_version 1.0;\n    gzip_comp_level 6; #设置数据的压缩等级,等级为1-9，压缩比从小到大\n    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #设置需要压缩的数据格式\n    gzip_vary on;\n\n    #虚拟主机配置\n    server {\n        listen       80;\n        server_name  mark.binlive.cn;\n        root /home/spa-project/dist; #定义服务器的默认网站根目录位置\n        index index.html; #定义index页面\n        error_page    404         /index.html; #将404错误页面重定向到index.html可以解决history模式访问不到页面问题\n        location ^~ /api/{\n            proxy_pass http://127.0.0.1:7000;\n            proxy_send_timeout 1800;\n            proxy_read_timeout 1800;\n            proxy_connect_timeout 1800;\n            client_max_body_size 2048m;\n            proxy_http_version 1.1;  \n            proxy_set_header Upgrade $http_upgrade;  \n            proxy_set_header Connection \"Upgrade\"; \n            proxy_set_header  Host              $http_host;   # required for docker client's sake\n            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client's IP\n            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header  X-Forwarded-Proto $scheme;\n        }\n        location ^~ /auth/{\n            proxy_pass http://127.0.0.1:7000;\n            proxy_send_timeout 1800;\n            proxy_read_timeout 1800;\n            proxy_connect_timeout 1800;\n            client_max_body_size 2048m;\n            proxy_http_version 1.1;  \n            proxy_set_header Upgrade $http_upgrade;  \n            proxy_set_header Connection \"Upgrade\"; \n            proxy_set_header  Host              $http_host;   # required for docker client's sake\n            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client's IP\n            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header  X-Forwarded-Proto $scheme;\n        }\n    }    \n}\n```\n```\nnginx -h // 查看Nginx的帮助\nnginx -v // 查看Nginx的版本\nnginx -t // 测试Nginx的配置\nnginx -T // 测试Nginx的配置，并打印配置信息\nnginx // 启动nginx\nnginx -s reload // 重新加载配置文件，平滑启动nginx\nnginx -s stop // 停止nginx的命令\nps -ef |grep nginx // 查看nginx进程\n```\n\n\n## 参考文章\n\n[GitLab-CI 从安装到差点放弃](https://segmentfault.com/a/1190000007180257)\n\n[用 GitLab CI 进行持续集成](https://segmentfault.com/a/1190000006120164)\n\n[当谈到 GitLab CI 的时候，我们该聊些什么（上篇）](https://xiaozhuanlan.com/topic/3529176084)\n\n[CDN使用心得：加速双刃剑](https://www.cnblogs.com/geyouneihan/p/9741021.html)\n\n[Node.js 实现静态文件增量上传CDN](https://juejin.im/post/5d0c4021f265da1ba431f4d4)\n\n[Nginx部署前后端分离服务以及配置说明](https://juejin.im/post/5b04d775f265da0b807117b1)\n\n[手把手搭建nginx服务器，部署前端代码](https://segmentfault.com/a/1190000017940311?utm_source=tag-newest)\n\n\n"},{"title":"ElementUI Message 二次封装","url":"/Roundtables/Question-Bank/work-practices/eleMessage.html","content":"---\ntitle: ElementUI Message 二次封装\n---\n\n# ElementUI Message 二次封装\n\n> ElementUI 的 Message 消息提示是点击一次弹出一次，这在频繁重复点击按钮时可能会造成不美观的多个相同消息重复提示；另一种场景是，对于每一个得到的请求响应都会弹出对应提示，当token过期需要重新登录，此时页面中多个请求的响应均报“登录过期”，也是重复提示不美观。\n\n> ElementUI 官方api并没有提供给我们可以处理此情况的配置，因此需要对 Message组件 做二次封装来达到要求。\n\n> 网上查阅后发现了两种解决思路：\n- 1、判断页面中 message 的个数；\n- 2、自定义 message 功能；\n\n## 判断页面中message的个数\n\n参考链接：[重复点击按钮或多个请求同时报错时弹出多个message弹框解决方法](https://blog.csdn.net/dongguan_123/article/details/101290164)\n\n```js\n/**重置message，防止重复点击重复弹出message弹框 */\nimport { Message } from 'element-ui'\n\nconst showMessage = Symbol('showMessage') // 为了实现Class的私有属性\n\n/** \n *  重写ElementUI的Message\n *  single默认值true，因为项目需求，默认只弹出一个，可以根据实际需要设置\n */\nclass DoneMessage {\n    [showMessage](type, options, single) {\n        if (single) {\n            if (document.getElementsByClassName('el-message').length === 0) {\n                Message[type](options)\n            }\n        } else {\n            Message[type](options)\n        }\n    }\n    info(options, single = true) {\n        this[showMessage]('info', options, single)\n    }\n    warning(options, single = true) {\n        this[showMessage]('warning', options, single)\n    }\n    error(options, single = true) {\n        this[showMessage]('error', options, single)\n    }\n    success(options, single = true) {\n        this[showMessage]('success', options, single)\n    }\n}\n```\n\n## 自定义message功能\n\n参考链接：[ElementUI之Message功能拓展](https://juejin.im/post/5da74fd26fb9a04dde147504)\n\n\n```js\nimport { Message } from 'element-ui'\n\nconst messageTypes = ['success', 'warning', 'error', 'info']\n\n// 新建构造函数\nfunction ESOPMessage(options) {\n  if (!(this instanceof ESOPMessage)) {\n    return new ESOPMessage(options)\n  }\n  this.init(options)\n}\n\nESOPMessage.queue = [] // 未展示数据的消息队列\n\nESOPMessage.instances = [] // 消息体实例列表\n\n// 配置项\nESOPMessage.config = {\n  max: 0, // 最大显示数\n  isQueue: false, // 是否以队列形式存储为展示消息\n  showNewest: true // 是否后添加的消息覆盖前面的消息\n}\n\n// 配置参数\nESOPMessage.setConfig = function(config = {}) {\n  ESOPMessage.config = { ...ESOPMessage.config, ...config }\n}\n\nESOPMessage.close = Message.close\n\nESOPMessage.closeAll = Message.closeAll\n\n// 各消息类型静态方法\nmessageTypes.forEach(type => {\n  ESOPMessage[type] = options => {\n    let opts = options\n    if (typeof options === 'string') {\n      opts = {\n        message: options\n      }\n    }\n    return new ESOPMessage({ ...opts, type })\n  }\n})\n\n// 初始化\nESOPMessage.prototype.init = function(options) {\n  const { max, isQueue, showNewest } = ESOPMessage.config\n  // 判断如果超出最大消息数时，删除消息\n  if (max > 0 && ESOPMessage.instances.length >= max && showNewest && !isQueue) {\n    this.removeMessages()\n  }\n\n  if (ESOPMessage.instances.length >= max && isQueue) {\n    // 添加队列元素\n    ESOPMessage.queue.push(this.saveToQueue(options))\n  } else if (ESOPMessage.instances.length < max || !max) {\n    this.setMessage(options)\n  }\n}\n\n// 移除消息\nESOPMessage.prototype.removeMessages = function() {\n  const { instances, config: { max } } = ESOPMessage\n\n  ESOPMessage.instances = instances.filter((instance, index) => {\n    if (index < instances.length - max + 1) {\n      instance && instance.close()\n      return false\n    }\n    return true\n  })\n}\n\n// 获取消息实例和添加事件监听\nESOPMessage.prototype.setMessage = function(options) {\n  const instance = Message(options)\n  // 监听消息消失事件，从实例列表移除当前消息实例\n  instance.$watch('visible', val => {\n    ESOPMessage.instances = ESOPMessage.instances.filter(item => item !== instance)\n    if (ESOPMessage.config.isQueue && ESOPMessage.queue.length) {\n      ESOPMessage.queue.shift()()\n    }\n  })\n  ESOPMessage.instances.push(instance)\n}\n\n// 生成队列元素，延迟执行\nESOPMessage.prototype.saveToQueue = function(options) {\n  return () => {\n    this.setMessage(options)\n  }\n}\n\nexport default ESOPMessage\n\n```\n\n\n"},{"title":"团队代码质量：eslint+husky+prettier+lint-staged","url":"/Roundtables/Question-Bank/work-practices/eslintPrettier.html","content":"# 团队代码质量：eslint+husky+prettier+lint-staged\n\n> 本文主要探究，如何约束和保持 `前端团队代码一致性`, 分别介绍 eslint、prettier、husky、lint-staged、commitlint\n\n----\n## 一、团队代码约束工程化流程\n\n1. 待提交的代码 git add 添加到 git暂存区（staged）；\n2. 执行 git commit；\n3. husky（哈士奇）注册在 git hook 中的 commit-msg钩子函数被调用，执行commitlint，强制校验代码提交时的commit msg；\n4. husky（哈士奇）注册在 git hook 中的 pre-commit钩子函数被调用，执行lint-staged；\n5. lint-staged（顾名思义是只对暂存区文件执行lint）取得所有被提交的文件依次执行写好的任务（ESLint 和 Prettier）；\n6. 如果有错误（没通过ESlint检查）则停止任务，同时打印错误信息，等待修复后再执行commit；\n7. 成功commit，可push到远程。\n\n## 二、认识流程中的工具\n\n::: tip\nhusky（哈士奇）的作用：如果没有husky，代码就需要push到origin之后再进行lint扫描，反馈流程过长且本身未通过检查的代码是不应该push到origin仓库中的。最理想的时机应该是在本地执行 git commit 时，触发代码检查，那么就需要用到 git hook。husky 其实就是一个为 git 客户端增加 hook 的工具。将其安装到所在仓库的过程中它会自动在 .git/ 目录下增加相应的钩子实现在 pre-commit 阶段就执行一系列流程保证每一个 commit 的正确性。\n:::\n\n::: tip\ngit的hook 就是git add、git commit等git操作时的回调钩子（可以查看.git文件下的hooks目录，这里存放的是git相关操作的一些脚本例子）。\n:::\n\n::: tip\nlint-staged 就是在 pre-commit 钩子函数中执行的工具。在进行git commit的时候触发到git hook进而执行pre-commit，而pre-commit脚本引用了lint-staged配置表，只对git add到stage区的文件进行配置表中配置的操作（此处我们不仅仅可以利用其调用linters，还可以调用prettier对代码进行格式化，注意应先格式化后lint检查）；\n:::\n\n::: tip\n为什么只对stage区的文件检查？如果是项目中途引入代码检查，那么在有历史代码时，对其他未修改文件都进行检查，一下出现成百上千个错误，那么可能会造成冲突或者一些不可预知的问题，降低项目稳定性；\n:::\n\n::: tip\n具体lint-staged做了三件事情：\n  1. 执行prettier脚本，这是对代码进行格式化的，在下面具体来说；\n  2. 执行eslint --fix操作，进行扫描，若发现工具可修复的问题进行fix；\n  3. 上述两项任务完成后对代码重新add。\n:::\n\n::: tip\nprettier是格式化代码工具：可是eslint已经有格式化功能了，为什么还需要prettier？Prettier 确实和 ESLint 有重叠，但两者侧重点不同：\n  - ESLint 主要工作就是检查代码质量和检查代码风格，并给出提示，虽然 eslint --fix 来修复一些问题（eslint规则中前面带🔧图标的都是可以自动修复的），但它所能提供的格式化功能很有限；\n  - 而 Prettier 没有对代码的质量进行检查的能力，其只会对代码风格按照指定的规范进行统一，避免一个项目中出现多种不同的代码风格。Prettier 被设计为易于与 ESLint 集成，所以你可以轻松在项目中使两者，而无需担心冲突。\n:::\n\n::: tip\ncommitlint的作用：使用commitLint强制校验代码提交时的commit msg格式，约束团队git提交规范，方便历史回顾、帮助他人更好review、查找、追踪代码变动历史等。也需要使用huksy，将commitlint的检查绑定到commit-msg这个hook上。\n  - `<type>[optional scope]: <description>`: type如下\n    ```\n    build: 项目构建打包\n    ci: 项目构建配置的变动\n    docs: 仅仅修改了文档等（不是指文案类的改动，而是指项目文档、代码注释等）\n    fix: 修复bug\n    feat: 增加新功能\n    perf: 优化\n    refactor: 重构(非fix、非feature、非style风格格式化)\n    revert: 代码回滚\n    style: 代码风格变动，例如空格、缩进等（不是指css文件变动）\n    test: 测试用例代码\n    chore: 其他类型的更改（非即以上类型的改动）\n    ```\n:::\n\n\n## 二、具体配置\n\n1. 配置eslint\n\neslint配置文件可以有多种形式（传送门：[eslint官网]()）：\n  ESLint 配置文件优先级：\n  - .eslintrc.js(输出一个配置对象)\n  - .eslintrc.yaml\n  - .eslintrc.yml\n  - .eslintrc.json（ESLint的JSON文件允许JavaScript风格的注释）\n  - .eslintrc（可以是JSON也可以是YAML）\n  - package.json（在package.json里创建一个eslintConfig属性，在那里定义你的配置）\n\n这里我们采用在项目根目录下配置.eslintrc.js及.eslintignore文件。\n\n- 在项目根目录创建一个.eslintignore文件，告诉ESLint去忽略特定的文件和目录\n- .eslintignore文件是一个纯文本文件，其中的每一行都是一个glob模式表明哪些路径应该忽略检测\n```\n/build/\n/config/\n/dist/\n/*.js\n```\n\n.eslintrc.js配置文件：\n```js\n// https://eslint.org/docs/user-guide/configuring\nmodule.exports = {\n  root: true, // 与寻找配置文件规则有关\n  // ESLint默认使用Espree作为其解析器, 同时babel-eslint也是用得最多的解析器\n  parser: 'vue-eslint-parser', // 详见https://eslint.vuejs.org/user-guide/#faq\n  parserOptions: { // TODparser解析代码时的参数\n    parser: 'babel-eslint',\n    sourceType: 'module', // //设置为script(默认)或module（如果你的代码是ECMAScript模块)\n    // 指定要使用的ECMAScript版本，默认值5\n    // ecmaVersion: 5,\n    // 这是个对象，表示你想使用的额外的语言特性,所有选项默认都是false\n    ecmaFeatures: {\n      // 允许在全局作用域下使用return语句\n      // globalReturn: false,\n      // 启用全局strict模式（严格模式）\n      // impliedStrict: false,\n      // 启用JSX\n      jsx: true,\n      // 启用对实验性的objectRest/spreadProperties的支持\n      // experimentalObjectRestSpread: false\n    }\n  },\n  // globals: {\n  //     __: true // 配置自定义全局变量\n  // },\n  // 指定环境，每个环境都有自己预定义的全局变量，可以同时指定多个环境，不矛盾\n  env: {\n    //效果同配置项ecmaVersion一样\n    es6: true,\n    browser: true,\n    node: true,\n    // commonjs: false,\n    // mocha: true,\n    // jquery: true,\n    //如果你想使用来自某个插件的环境时，确保在plugins数组里指定插件名\n    //格式为：插件名/环境名称（插件名不带前缀）\n    // react/node: true\n  },\n  // ESLint支持使用第三方插件\n  // 在使用插件之前，你必须使用npm安装它\n  // 全局安装的ESLint只能使用全局安装的插件\n  // 本地安装的ESLint不仅可以使用本地安装的插件还可以使用全局安装的插件\n  // plugin与extend的区别：extend提供的是eslint现有规则的一系列预设\n  // 而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候\n  // 就可以借用插件来实现了\n  extends: [ // extends属性值可以是一个字符串或字符串数组，数组中每个配置项继承它前面的配置\n    'plugin:vue/recommended',\n    'eslint:recommended',\n    'plugin:prettier/recommended',\n  ],\n  // 插件名称可以省略eslint-plugin-前缀\n  plugins: [\n    'vue'\n  ],\n  // off或0--关闭规则\n  // warn或1--开启规则，警告级别(不会导致程序退出)\n  // error或2--开启规则，错误级别(当被触发的时候，程序会退出)\n  rules: {\n    // 这里如果配置了具体规则，会覆盖.prettierrc文件中的规则\n    // 且单独执行prettier --write命令，这里的配置是读不到的\n    \"prettier/prettier\": [\"error\", {\n      \"singleQuote\": true,\n      \"trailingComma\": \"none\",\n      \"bracketSpacing\": true,\n      \"jsxBracketSameLine\": true,\n      \"endOfLine\": \"crlf\"\n    }],\n    // https://eslint.vuejs.org/rules/\n    // https://eslint.vuejs.org/rules/max-attributes-per-line.html\n    'vue/max-attributes-per-line': [2, {\n      'singleline': 10,\n      'multiline': {\n        'max': 1,\n        'allowFirstLine': false\n      }\n    }],\n    // https://eslint.vuejs.org/rules/singleline-html-element-content-newline.html\n    'vue/singleline-html-element-content-newline': 'off',\n    'vue/multiline-html-element-content-newline':'off',\n    // https://eslint.vuejs.org/rules/name-property-casing.html\n    'vue/name-property-casing': ['error', 'PascalCase'],\n    'vue/no-v-html': 'off',\n    'vue/html-self-closing': 0,\n    // 如果某条规则有额外的选项，你可以使用数组字面量指定它们\n    \"vue/order-in-components\": [\"error\", {\n      \"order\": [\n        \"el\",\n        \"name\",\n        \"parent\",\n        \"functional\",\n        [\"delimiters\", \"comments\"],\n        \"extends\",\n        \"mixins\",\n        \"inheritAttrs\",\n        \"model\",\n        [\"props\", \"propsData\"],\n        \"fetch\",\n        \"asyncData\",\n        \"data\",\n        \"computed\",\n        \"watch\",\n        [\"directives\", \"filters\"],\n        \"LIFECYCLE_HOOKS\",\n        \"methods\",\n        \"head\",\n        [\"template\", \"render\"],\n        \"renderError\",\n        \"components\"\n      ]\n    }],\n    // https://eslint.org/docs/rules/\n    'accessor-pairs': 2,\n    'arrow-spacing': [2, {\n      'before': true,\n      'after': true\n    }],\n    'block-spacing': [2, 'always'],\n    'brace-style': [2, '1tbs', {\n      'allowSingleLine': true\n    }],\n    'camelcase': [0, {\n      'properties': 'always'\n    }],\n    'comma-dangle': [2, 'never'],\n    'comma-spacing': [2, {\n      'before': false,\n      'after': true\n    }],\n    // ......\n  }\n}\n\n```\n\n如果希望在重新编译的时候eslint自动修复代码，需要在webpack配置中加入eslint，并且设置 fix: true ，并且在devserver中开启eslint（[传送门](https://my.oschina.net/u/3970421/blog/2874449)，本方案未采用）。\n\n2. 配置prettier\n\n与eslint的配置方式相似，prettier也可以有多重配置文件，本文也只采用在根目录下配置.prettierrc.js。\n\n.prettierrc.js配置文件： \n```js\nmodule.exports = { \n \"printWidth\": 80, // 每行代码长度（默认80）\n \"tabWidth\": 2, // 每个tab相当于多少个空格（默认2）\n \"useTabs\": false, // 是否使用tab进行缩进（默认false）\n \"singleQuote\": true, // 使用单引号（默认false）\n \"semi\": true, // 声明结尾使用分号(默认true)\n \"trailingComma\": \"all\", // 多行使用拖尾逗号（默认none）\n \"bracketSpacing\": true, // 对象字面量的大括号间使用空格（默认true）\n \"jsxBracketSameLine\": false, // 多行JSX中的>放置在最后一行的结尾，而不是另起一行（默认false）\n \"arrowParens\": \"avoid\" // 只有一个参数的箭头函数的参数是否带圆括号（默认avoid）\n}\n```\n\nprettier有3种使用方式：\n- 在编辑器中安装插件，如vs code中安装 Prettier - Code formatter；\n- 使用脚本，使用了根目录配置文件的，使用命令行 `prettier --write {src,static}/**/*.{js,vue}` 格式化，prettier不但需要在项目里安装，还需要全局安装才能使用prettier命令，否则无效；\n- 作为linter工具的插件使用（`也是本方案采取的方式`）：\n  - 由于需要同时使用prettier和eslint，而prettier的一些规则和eslint的一些规则可能存在冲突，所以需要将eslint的一些可能与prettier发生冲突的代码格式化规则关闭。这里使用eslint-plugin-prettier和eslint-config-prettier。\n\n  - eslint-plugin-prettier可以将prettier的规则设置为eslint的规则，对不符合规则的进行提示。（与eslint-plugin-vue相同）\n\n  - eslint-config-prettier可以关闭eslint可能与prettier发生冲突的代码格式化规则。官方称eslint-plugin-prettier需要与eslint-config-prettier搭配食用才能获得最佳效果。\n  - `npm i -D prettier eslint-plugin-prettier eslint-config-prettier`，在.eslintrc.js文件中添加配置：\n```js\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'plugin:vue/recommended',\n    'plugin:prettier/recommended'\n  ]\n  rules: {\n    \"prettier/prettier\": \"error\"\n  }\n}\n```\n\n3. 配置commitlint\n[传送门](https://segmentfault.com/a/1190000017790694)\n\n还可以结合`commitizen`交互提交工具，在全局安装commitizen，就可以在任意git项目中，都运行`git cz`命令。\n\n```\n$ npm install commitizen cz-conventional-changelog -g\n$ echo '{ \"path\": \"cz-conventional-changelog\" }' > ~/.czrc\n```\n\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint --edit $HUSKY_GIT_PARAMS\"\n    }\n  },\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-conventional\"\n    ],\n    \"rules\": {\n      \"subject-case\": [0],\n      \"scope-case\": [0]\n    }\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"cz-conventional-changelog\"\n    }\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"^7.1.2\",\n    \"@commitlint/config-conventional\": \"^7.1.2\"\n  }\n}\n\n```\n\n4. 配置lint-staged\n\nlint-staged的路径按照glob规则配置，先prettier格式化，再eslint检查，最后重新git add。\n\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"{src,static}/**/*.{js,vue}\": [\n      \"prettier --write\",\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  },\n  \"devDependencies\": {\n    \"eslint\": \"^4.15.0\",\n    \"husky\": \"^1.1.2\",\n    \"lint-staged\": \"^9.5.0\",\n    \"prettier\": \"^1.19.1\",\n  }\n}\n```\n\n5. stylelint\n\n待完成：https://segmentfault.com/a/1190000017335221\n\n\n## 三、 注意几个关键问题！！\n\n::: danger 关键问题\n\n- 我们使用的方案是借用了两个插件来集成eslint与prettier：`eslint-config-prettier 这个是关闭eslint冲突的规则`，`eslint-plugin-prettier是在eslint运行时同步执行prettier`；\n\n- 由于我们使用了 eslint-plugin-prettier 插件来驱动prettier的执行，执行`eslint --fix`会同时执行eslint检查和prettier格式化，因此在`lint-staged`中就不需要先执行一次 `prettier --write` 了。（`The rule is autofixable -- if you run eslint with the --fix flag, your code will be formatted according to prettier style.`）\n\n- 而如果不使用上面提到的两个插件，则必须要在`lint-staged`中就分别执行 `prettier --write` 与`eslint --fix`，由于是分开来执行的，各自需要读取各自的rules，所以要特别注意两者的一致性，否则肯定会报错。\n\n- 在eslintrc.js中配置prettier/prettier的具体option规则时（比如 `\"prettier/prettier\": [\"error\", {\"singleQuote\": true, \"parser\": \"flow\"}]`），这里的option中的rules的优先级比直接在 .prettierrc文件中的规则高，因此eslint驱动prettier执行格式化会以这里的规则为准，所以如果这里配置了就不用重复在.prettierrc文件中配置了。\n\n- 但是 **不推荐在 在eslintrc.js中配置prettier/prettier的具体option规则**，因为编辑器的一些prettier扩展只能读到.prettierrc文件中的配置，而不能读到lint配置文件的prettier配置项，因此推荐的做法是**在.prettierrc文件中配置prettier的规则，eslint-config-prettier插件在用eslint驱动prettier执行时也能读到，编辑器的扩展插件也能读到**（`Note: While it is possible to pass options to Prettier via your ESLint configuration file, it is not recommended because editor extensions such as prettier-atom and prettier-vscode will read .prettierrc, but won't read settings from ESLint, which can lead to an inconsistent experience.`）。\n\n:::\n\n## 四、 完整配置\n\npackage.json\n```json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\",\n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"{src,static}/**/*.{js,vue}\": [\n      // \"prettier --write\", // 由于使用插件eslint-plugin-prettier，不需要重复配置\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  },\n  \"commitlint\": {\n    \"extends\": [\n      \"@commitlint/config-conventional\"\n    ],\n    \"rules\": {\n      \"subject-case\": [\n        0\n      ],\n      \"scope-case\": [\n        0\n      ]\n    }\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"cz-conventional-changelog\"\n    }\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"^7.1.2\",\n    \"@commitlint/config-conventional\": \"^7.1.2\",\n    \"babel-eslint\": \"^8.2.6\",\n    \"cz-conventional-changelog\": \"2.1.0\",\n    \"eslint\": \"^4.15.0\",\n    \"eslint-config-prettier\": \"^6.7.0\",\n    \"eslint-plugin-prettier\": \"^3.1.1\",\n    \"eslint-plugin-vue\": \"^4.0.0\",\n    \"husky\": \"^1.1.2\",\n    \"lint-staged\": \"^9.5.0\",\n    \"prettier\": \"^1.19.1\",\n  }\n}\n```\n\n.prettierrc.js\n```js\nmodule.exports = {\n  \"printWidth\": 120, // 每行代码长度（默认80）\n  \"tabWidth\": 2, // 每个tab相当于多少个空格（默认2）\n  \"useTabs\": false, // 是否使用tab进行缩进（默认false）\n  \"singleQuote\": true, // 使用单引号（默认false）\n  \"semi\": false, // 声明结尾使用分号(默认true)\n  \"trailingComma\": \"none\", // 多行使用拖尾逗号（默认none）\n  \"bracketSpacing\": true, // 对象字面量的大括号间使用空格（默认true）\n  \"jsxBracketSameLine\": true, // 多行JSX中的>放置在最后一行的结尾，而不是另起一行（默认false）\n  \"arrowParens\": \"avoid\", // 只有一个参数的箭头函数的参数是否带圆括号（默认avoid）\n  \"proseWrap\": \"preserve\",\n  \"endOfLine\": \"crlf\"\n}\n```\n\n\neslintrc.js\n```js\nmodule.exports = {\n  root: true,\n  parser: 'vue-eslint-parser', // 详见https://eslint.vuejs.org/user-guide/#faq\n  parserOptions: {\n    parser: 'babel-eslint',\n    sourceType: 'module',\n    ecmaFeatures: {\n      jsx: true\n    }\n  },\n  env: {\n    es6: true,\n    browser: true,\n    node: true\n  },\n  extends: [\n    'eslint:recommended',\n    'plugin:vue/recommended',\n    'plugin:prettier/recommended',\n  ],\n  plugins: [\n    'vue',\n    'prettier'\n  ],\n  rules: {\n    \"prettier/prettier\": \"error\",\n    'vue/max-attributes-per-line': [2, {\n      'singleline': 10,\n      'multiline': {\n        'max': 1,\n        'allowFirstLine': true\n      }\n    }],\n    'vue/singleline-html-element-content-newline': 'off',\n    \"vue/multiline-html-element-content-newline\": 'off',\n    'vue/html-end-tags': 2,\n    'vue/name-property-casing': ['error', 'PascalCase'],\n    'vue/no-v-html': 'off',\n    \"vue/html-closing-bracket-newline\": [0, {\n      \"singleline\": \"never\",\n      \"multiline\": \"never\"\n    }],\n    \"vue/html-closing-bracket-newline\": 0,\n    \"vue/html-self-closing\": [\"error\", {\n      \"html\": {\n        \"void\": \"any\",\n        \"normal\": \"always\",\n        \"component\": \"always\"\n      },\n      \"svg\": \"always\",\n      \"math\": \"always\"\n    }],\n    \"vue/require-default-prop\": 0,\n    \"vue/order-in-components\": [0, {\n      \"order\": [\n        \"el\",\n        \"name\",\n        \"parent\",\n        \"functional\",\n        [\"delimiters\", \"comments\"],\n        \"extends\",\n        \"mixins\",\n        \"inheritAttrs\",\n        \"model\",\n        [\"props\", \"propsData\"],\n        \"fetch\",\n        \"asyncData\",\n        \"data\",\n        \"computed\",\n        \"watch\",\n        [\"directives\", \"filters\"],\n        \"LIFECYCLE_HOOKS\",\n        \"methods\",\n        \"head\",\n        [\"template\", \"render\"],\n        \"renderError\",\n        \"components\"\n      ]\n    }],\n    'accessor-pairs': 2,\n    'arrow-spacing': [2, {\n      'before': true,\n      'after': true\n    }],\n    'block-spacing': [2, 'always'],\n    'brace-style': [2, '1tbs', {\n      'allowSingleLine': true\n    }],\n    'camelcase': [0, {\n      'properties': 'always'\n    }],\n    'comma-dangle': [2, 'never'],\n    'comma-spacing': [2, {\n      'before': false,\n      'after': true\n    }],\n    'comma-style': [2, 'last'],\n    'constructor-super': 2,\n    'curly': [2, 'multi-line'],\n    'dot-location': [2, 'property'],\n    'eol-last': 2,\n    'eqeqeq': ['error', 'always', {'null': 'ignore'}],\n    'generator-star-spacing': [2, {\n      'before': true,\n      'after': true\n    }],\n    'handle-callback-err': [2, '^(err|error)$'],\n    'jsx-quotes': [2, 'prefer-single'],\n    'key-spacing': [2, {\n      'beforeColon': false,\n      'afterColon': true\n    }],\n    'keyword-spacing': [2, {\n      'before': true,\n      'after': true\n    }],\n    'new-cap': [2, {\n      'newIsCap': true,\n      'capIsNew': false\n    }],\n    'new-parens': 2,\n    'no-array-constructor': 2,\n    'no-caller': 2,\n    'no-console': 'off',\n    'no-class-assign': 2,\n    'no-cond-assign': 2,\n    'no-const-assign': 2,\n    'no-control-regex': 0,\n    'no-delete-var': 2,\n    'no-dupe-args': 2,\n    'no-dupe-class-members': 2,\n    'no-dupe-keys': 2,\n    'no-duplicate-case': 2,\n    'no-empty-character-class': 2,\n    'no-empty-pattern': 2,\n    'no-eval': 2,\n    'no-ex-assign': 2,\n    'no-extend-native': 2,\n    'no-extra-bind': 2,\n    'no-extra-boolean-cast': 2,\n    'no-extra-parens': [2, 'functions'],\n    'no-fallthrough': 2,\n    'no-floating-decimal': 2,\n    'no-func-assign': 2,\n    'no-implied-eval': 2,\n    'no-inner-declarations': [2, 'functions'],\n    'no-invalid-regexp': 2,\n    'no-irregular-whitespace': 2,\n    'no-iterator': 2,\n    'no-label-var': 2,\n    'no-labels': [2, {\n      'allowLoop': false,\n      'allowSwitch': false\n    }],\n    'no-lone-blocks': 2,\n    'no-mixed-spaces-and-tabs': 2,\n    'no-multi-spaces': 2,\n    'no-multi-str': 2,\n    'no-multiple-empty-lines': [2, {\n      'max': 1\n    }],\n    'no-native-reassign': 2,\n    'no-negated-in-lhs': 2,\n    'no-new-object': 2,\n    'no-new-require': 2,\n    'no-new-symbol': 2,\n    'no-new-wrappers': 2,\n    'no-obj-calls': 2,\n    'no-octal': 2,\n    'no-octal-escape': 2,\n    'no-path-concat': 2,\n    'no-proto': 2,\n    'no-redeclare': 2,\n    'no-regex-spaces': 2,\n    'no-return-assign': [2, 'except-parens'],\n    'no-self-assign': 2,\n    'no-self-compare': 2,\n    'no-sequences': 2,\n    'no-shadow-restricted-names': 2,\n    'no-spaced-func': 2,\n    'no-sparse-arrays': 2,\n    'no-this-before-super': 2,\n    'no-throw-literal': 2,\n    'no-trailing-spaces': 2,\n    'no-undef': 2,\n    'no-undef-init': 2,\n    'no-unexpected-multiline': 2,\n    'no-unmodified-loop-condition': 2,\n    'no-unneeded-ternary': [2, {\n      'defaultAssignment': false\n    }],\n    'no-unreachable': 2,\n    'no-unsafe-finally': 2,\n    'no-unused-vars': [2, {\n      'vars': 'all',\n      'args': 'none'\n    }],\n    'no-useless-call': 2,\n    'no-useless-computed-key': 2,\n    'no-useless-constructor': 2,\n    'no-useless-escape': 0,\n    'no-whitespace-before-property': 2,\n    'no-with': 2,\n    'one-var': [2, {\n      'initialized': 'never'\n    }],\n    'operator-linebreak': [2, 'after', {\n      'overrides': {\n        '?': 'before',\n        ':': 'before'\n      }\n    }],\n    'padded-blocks': [2, 'never'],\n    'quotes': [2, 'single', {\n      'avoidEscape': true,\n      'allowTemplateLiterals': true\n    }],\n    // 'indent': [2, 2, {\n    //   'SwitchCase': 1\n    // }],\n    // 'semi': [2, 'never'],\n    indent: 0, // process by prettier\n    semi: 0, // process by prettier\n    'semi-spacing': [2, {\n      'before': false,\n      'after': true\n    }],\n    'space-before-blocks': [2, 'always'],\n    'space-before-function-paren': [2, 'never'],\n    'space-in-parens': [2, 'never'],\n    'space-infix-ops': 2,\n    'space-unary-ops': [2, {\n      'words': true,\n      'nonwords': false\n    }],\n    'spaced-comment': [2, 'always', {\n      'markers': ['global', 'globals', 'eslint', 'eslint-disable', '*package', '!', ',']\n    }],\n    'template-curly-spacing': [2, 'never'],\n    'use-isnan': 2,\n    'valid-typeof': 2,\n    'wrap-iife': [2, 'any'],\n    'yield-star-spacing': [2, 'both'],\n    'yoda': [2, 'never'],\n    'prefer-const': 2,\n    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,\n    'object-curly-spacing': [2, 'always'],\n    'array-bracket-spacing': [2, 'never']\n  }\n}\n```\n\n.eslintignore\n```\n/build/\n/config/\n/dist/\n/*.js\n```\n\n\n\n\n"},{"title":"前端多语言方案实现总结","url":"/Roundtables/Question-Bank/work-practices/i18n.html","content":"# 前端多语言方案实现总结\n\n## 回顾\n对于国际化的实现现在已经有很多成熟的方案了，不论是Vue、React或者其他框架，甚至nodejs。\n最近在做一个Vue项目的国际化，此前也调研过各种实现方案，发现它们基本都采用了Vue-i18n作为基本的工具。然后我们之前已经有一套完善的使用i18n-scanner实现国际化的方案，我们来回顾一下（部分代码）：\n\n```typescript\n/** i18n */\ninterface ILangConfig {\n    [key: string]: {\n        cn?: string;\n        tw?: string;\n        en?: string;\n    };\n}\n\ntype LangReturn<T> = { [P in keyof T]: string };\n\ntype DefaultLang = typeof zh_CN;\n\ninterface I18n extends DefaultLang {\n    <T extends ILangConfig>(config: T): LangReturn<T>;\n    language: string;\n    printf: typeof printf;\n    __: typeof __;\n}\n\ni18n.__ = window.__ = __;\n\n// @ts-ignore\nif (pkg.locals) {\n    globalTranslation = require(`locals/${language}.json`);\n}\n\n/**\n * @description\n * 语言包匹配\n */\nexport function __(text: string): string {\n    return globalTranslation[text] || text;\n}\n```\n通过接口可以看出该`i18n`是一个函数，该函数可以接收一个`config`（语言包）参数然后返回一个带有对应当前语言的翻译文案；该函数有一个`language`属性代表当前语言；`__`则是收集与翻译字符串文案的关键；\n```typescript\n/**\n * @description\n * 扫描源代码文件，匹配需要翻译的文案，并输出excel文件待翻译\n */\nfunction scanner() {\n    const i18nParser = new Parser({\n        lngs: pkg.locals,\n        nsSeparator: false,\n        keySeparator: false,\n        pluralSeparator: false,\n        contextSeparator: false\n    });\n\n    fs.ensureDirSync(path.join(paths.locals, 'xlsx'));\n\n    glob.sync(paths.appSrc + '/**/*.{js,jsx,ts,tsx}').forEach(file => {\n        const content = fs.readFileSync(file);\n\n        i18nParser.parseFuncFromString(content, { list: ['__', 'i18n.__', 'window.__'] }, key => {\n            if (key) {\n                i18nParser.set(key, key);\n            }\n        });\n    });\n\n    const i18nJson = i18nParser.get();\n\n    Object.keys(i18nJson).forEach(key => {\n        const jsonDestination = path.join(paths.locals, key + '.json');\n        const excelDestination = path.join(paths.locals, 'xlsx', key + '.xlsx');\n\n        const translation = i18nJson[key].translation;\n        const existConfig = fs.existsSync(jsonDestination) ? JSON.parse(fs.readFileSync(jsonDestination)) : {};\n        const newConfig = lodash.pickBy(existConfig, (value, key) => key in translation);\n\n        lodash.each(translation, (value, key) => {\n            if (!(key in newConfig)) {\n                newConfig[key] = value;\n            }\n        });\n\n        fs.outputFile(path.join(paths.locals, key + '.json'), JSON.stringify(newConfig, '\\n', 2));\n\n        convertJson2Excel(newConfig, key, path.join(excelDestination));\n\n        spinner.succeed('输出 ' + chalk.bold(chalk.green(key)) + ' 到 ' + chalk.cyan(excelDestination));\n    });\n\n    console.log();\n    spinner.warn(chalk.yellow('你可以将生成的excel文件进行翻译后，放回原处。然后运行：'));\n    console.log(chalk.green('   npm run i18n-read'));\n}\n```\n上面采用[i18next-scanner](https://github.com/i18next/i18next-scanner)实现，上面的函数实现了扫描指定后缀名文件中使用`__`函数包裹的文案（16行-19行）。\n最终导出了`json`文件和`Excel`。当然还有一个`read`函数可以读取`Excel`然后写入`json`文件中然后就完成了翻译。\n## 总结回顾\n上面是我们对于`react` 多语言的实现方式。\n下面说说它的特点：\n\n1. 需要手动提取文案（手动使用`__`函数包裹要翻译的文案）。\n1. 使用i18next-scanner扫描对应文件提取汇总文案。\n1. 切换语言需要强刷页面。\n## 对比\n对于本次vue的实现方案的调研中发现：很多都是用一个有意义的英文键名还有一定的层次结构去组织文案。可以对比一下上面react的方案：\n\n1. 之前react方案下的语言包：\n```jsx\n// zh\n{\n  \"标题\": \"标题\"\n}\n// en\n{\n  \"标题\": \"title\"\n}\n\n// 使用\n<div>{{ __('标题') }}</div>\n```\n\n2. 大部分vue-i18n道友的语言包：\n```jsx\n// zh\n{\n\t\"home\": {\n  \t\"title\": \"标题\"\n  }\n}\n// en\n{\n\t\"home\": {\n  \t\"title\": \"title\"\n  }\n}\n\n// 使用\n<div>{{ $t('home.title') }}</div>\n```\n\n- 对比可以发现方案1只有一层结构，方案2会出现多层。\n- 使用时呢明显方案1会更清晰明了。\n- 文案提取方式：方案1使用nodejs的能力自动一键提取，方案2则需要手动维护一个json文件或者js文件，还要去考虑它的组织、层级等。\n- 方案1需要强刷页面，方案2则可无刷新翻译（依赖vue响应式数据的能力）。\n\n## 方案3\n现在我们想使用方案1提供的便捷但又想使用方案2带来的无刷新体验。那就需要综合两者实行方案3。\n方案3：vue-i18n + i18next-scanner\n第一步：我们要将vue-i18n插件安装到我们项目到vue上：\n\n```javascript\nimport Vue from 'vue'\nimport VueI18n from 'vue-i18n'\n\nVue.use(VueI18n)\n```\n第二步：实例化vuei8n：\n```javascript\nimport EN_US from './lang/en_US.json'\nimport ZH_CN from './lang/zh_CN.json'\n\nconst esop = getTokenObj()\n// 读取用户本地保存的语言配置\nconst locale = esop ? esop.lang : 'zh-CN'\nconst i18n = new VueI18n({\n  locale,\n  messages: {\n    'en-US': EN_US,\n    'zh-CN': ZH_CN\n  }\n})\n```\n第三步：将翻译方法绑定到全局和Vue原型链上：\n```javascript\nconst t = i18n.t.bind(i18n)\n// 只翻译不扫描，__.$t(_scan('你是{name}'), { name: '小虎' })\nt.$t = t\nVue.prototype.__ = window.__ = t\n// 只扫描不翻译\nwindow._scan = v => v\n\ndocument.documentElement.lang = locale\ndocument.documentElement.classList.add(locale)\n```\n上面不同方法的使用场景：\n所有的`__`包裹的文案都将被匹配扫描。\n模版中：\n\n- 普通文案：__('文案')\n- 带插值：`this.$t(_scan('你是{name}'), { name: '小虎' })`（要放到计算属性里）；当然也可以直接插入模版，像这样：`$t(__.$t('你是{name}'), { name: '小虎' })`\n\njs函数中：\n\n- 普通文案：__('文案')\n- 带插值：`__.$t(_scan('你是{name}'), { name: '小虎' })`\n\njs字面量中：\n\n- 普通文案：_scan('文案')\n\n第四步：使用`i18next-scanner`：\n```javascript\n/**\n * @description\n * 扫描源代码文件，匹配需要翻译的文案\n */\nfunction scanner() {\n  const i18nParser = new Parser({\n    lngs: pkg.locals,\n    nsSeparator: false,\n    keySeparator: false,\n    pluralSeparator: false,\n    contextSeparator: false\n  })\n\n  glob.sync(paths.appSrc + '/**/*.{vue,js,jsx,ts,tsx}').forEach(file => {\n    const content = fs.readFileSync(file)\n\n    i18nParser.parseFuncFromString(\n      content,\n      { list: ['__', 'window.__', 'window._scan', '_scan'] },\n      key => {\n        if (key) {\n          i18nParser.set(key, key)\n        }\n      }\n    )\n  })\n\n  const i18nJson = i18nParser.get()\n\n  Object.keys(i18nJson).forEach(key => {\n    const jsonDestination = path.join(paths.i18nLang, key + '.json')\n\n    const translation = i18nJson[key].translation\n    const existConfig = fs.existsSync(jsonDestination)\n      ? JSON.parse(fs.readFileSync(jsonDestination))\n      : {}\n    const newConfig = lodash.pickBy(\n      existConfig,\n      (value, key) => key in translation\n    )\n\n    lodash.each(translation, (value, key) => {\n      if (!(key in newConfig)) {\n        newConfig[key] = value\n      }\n    })\n\n    fs.outputFile(\n      path.join(paths.i18nLang, key + '.json'),\n      JSON.stringify(newConfig, '\\n', 2)\n    )\n  })\n}\n```\n第五步：编写npm script\n```json\n{\n\t\"script\": {\n  \t\"scan\": \"node scripts/i18n.js\"\n  }\n}\n```\n然后执行npm run scan即可扫描提取文案。\n"},{"title":"Mobx 使用踩坑记录","url":"/Roundtables/Question-Bank/work-practices/mobx-cases.html","content":"---\n{\n  \"title\": \"Mobx 使用踩坑记录\",\n}\n---\n\n# Mobx 使用踩坑记录\n\n::: tip\n本文主要记录 Mobx 使用过程中所趟过的坑...\n:::\n\n## Mobx 数据更新，组件不渲染问题\n\n::: warning\n- Q：为啥store里@observable 标识的变量改变了，就是不走render?\n- A：当 observer 需要组合其它装饰器或高阶组件时，请确保 observer 是最深处(第一个应用)的装饰器，否则它可能什么都不做。\n:::\n\n装饰器语法是比export时用高阶组件的写法离组件近的，因此如下这种写法会导致render不执行：\n```js\n@withToast\nclass AccountSet extends Component<RouteComponentProps> {\n    // ...\n}\n\nexport default observer(AccountSet);\n```\n正确方式是：\n```js{1,2}\n@withToast\n@observer\nclass AccountSet extends Component<RouteComponentProps> {\n    // ...\n}\n\nexport default AccountSet;\n```\n或者（更好的做法）\n```js{5}\nclass AccountSet extends Component<RouteComponentProps> {\n    // ...\n}\n\nexport default withToast(observer(AccountSet));\n```\n\n## Mobx observer问题描述\n``` js\n@observable userBankCard = {};\n初始化监听一个userbankCard空对象；\n\n@action\nupdateEmployeeBankCard(obj) {\n    this.userBankCard = Object.assign(this.userBankCard, obj);\n}\n\n业务功能里对userBankCard属性进行操作之后，但是业务组件 并没有监听到userBankCard属性的变化\n```\n### mobx Observable对象\n通过`Observable` 可以将一个普通对象的所有属性拷贝至一个克隆对象并将克隆对象转变成可观察的 (普通对象是指不是使用构造函数创建出来的对象，而是以 Object 作为其原型，或者根本没有原型。)\n\n> 注意⚠️\n[MobX 4 及以下版本] 当通过 observable 传递对象时，只有在把对象转变 observable 时存在的属性才会是可观察的。 稍后添加到对象的属性不会变为可观察的，除非使用 set 或 extendObservable。<br />\n\n官网上面提供的方式并没有奏效，无论是通过set还是extendObservable 增加监听对象里面的属性没有触发组件的重新渲染。也没找到没有生效的原因。。。。。\n\n### 最终解决方式\n``` js\n@action\nupdateEmployeeBankCard(obj) {\n    this.userBankCard = Object.assign({}, this.userBankCard, obj);\n}\n```\n通过Object.assign，给监听对象**重新分配一个新对象**（`新的栈内存地址会促使重新执行监听初始化`）方式，注意和文章开头部分写法的微小区别。\n\n关于这一块，vue也有相似的问题处理：传送门[vue中数据劫持的明显缺点（两点）](../MVVM/mvvm-base.html#_4-vue中数据劫持的明显缺点（两点）：)\n"},{"title":"如何保证产品质量","url":"/Roundtables/Question-Bank/work-practices/product-quality.html","content":"---\ntitle: 如何保证产品质量\ntags: [错误监控, 代码质量]\ncategories: work-practices\n---\n\n# 如何保证产品质量\n\n## 错误监控\n\n### 前端错误的分类\n- 即时运行错误：代码错误\n- 资源加载错误\n\n### 错误的捕获方式\n\n#### 即时运行错误的捕获方式：\n- try..catch..\n- window.onerror\n#### 资源加载错误的捕获方式：\n- object.onerror\t比如img.onerror\n- performance.getEntries()：用2需要的去除1中已经加载到的资源就是加载失败的资源\n    1. performance.getEntries().forEach(item=>{console.log(item.name)}) 遍历出来页面中所有加载到的资源；\n    2. document.getElementsByTagName('img') 拿到所有需要的某种需要的资源\n- Error事件捕获\n    ![](./images/error-catch-1.png)\n    - true代表事件捕获，通过一个script标签加载一个不存在的文件，即可捕获该事件错误\n    ![](./images/error-catch-2.png)\n    - 如果是false，也就是事件冒泡，只报错但获取不到该错误\n    ![](./images/error-catch-3.png)\n \n\n#### 延伸：跨域的js运行错误可以捕获吗，错误提示是什么，应该怎么处理?\n![](./images/error-catch-4.png)\n\n可以捕获，但是只能知道script error，但无法拿到行号列号，处理方法是：\n1. 在客户端script标签增加crossorigin属性；\n2. 在服务端设置js资源响应头Access-Control-Allow-Origin: *\n\n就可以拿到具体的跨域的js运行错误了。\n\n### 错误上报的常用方法与原理\n1. 采用Ajax通信的方式上报(但实际中没人用这种方式)；\n2. 利用Image对象上报(实际应用中的错误上报方式。利用这种方式非常简单，比ajax简单，且无需第三方的库)；\n```html\n<script type=\"text/javascript\">\n    // 通过赋值图片src确定错误上报地址\n    (new Image()).src = \"https://baidu.com/testjk?r=tksjk\";\n</script>\n```\n![](./images/error-catch-5.png)\n\n\n\n"},{"title":"打开一个新标签页的方式","url":"/Roundtables/Question-Bank/work-practices/windowInject.html","content":"---\ntitle: 异步请求中打开新窗口拦截问题\n---\n\n## 打开一个新标签页的方式\n\n- 通过a标签 ```<a href='' target=\"_blank\">```\n- window.open() 方式\n\n在一个异步请求中，使用这两种方式打开新页面会触发浏览器的拦截机制，要打开的页面会被拦截掉；然而在非异步的方式打开新页面不会受到影响；\n举个大概例子：\n``` js\nredirectNewPage = async() {\n\tawait http.get();\n\twindow.open('http://www.baidu.com')\n }\n}\n```\n这种异步方式，如果浏览器打开了拦截，页面会被拦截掉\n\n## 解决方式\n这里针对window.open方式打开新页面的解决方式，但是方法不是很完美\n``` js\nredirectNewPage = async() {\n\tconst newPage = window.open(); 在发起请求前先打开一个新窗口\n\tawait http.get();\n\t<!-- window.open('http://www.baidu.com') -->\n\tnewPage.location.href = 'http://www.baidu.com'\n }\n}\n\n```\n\n[这里有针对各个浏览器的总结](https://juejin.im/post/5bdee507e51d4567953e6cdd)\n\n\n\n"},{"title":"Wanted","url":"/Roundtables/Wanted/index.html","content":"---\n{\n  \"title\": \"Wanted 计划\",\n}\n---\n\n# Wanted\n\n### 备选方向\n> [掘金](https://juejin.im/post/5cdd2ba16fb9a031ef63dd43#heading-2)\n\n+ [✔️PWA(Progressive Web Apps)](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)\n  熟悉整个流程\n- [WebAssembly](https://developer.mozilla.org/zh-CN/docs/WebAssembly) 初步了解第四个Web语言WebAssembly\n+ [GraphQL](https://graphql.org/) 熟悉了解这个新的api模式\n- [CSS-in-JS]() 熟悉了解两个最大的相关库[styled-components](https://www.styled-components.com/)、[emotion](https://github.com/emotion-js/emotion)\n+ [Flutter](https://flutterchina.club/) 了解入门这个架构，写一个简单demo\n- [Webpack 4](https://www.webpackjs.com/concepts/) 熟悉4.x版本的新变动 Webpack5也即将发布\n+ ~~[Prettier 代码风格统一](https://prettier.io/)~~ 简单的工具 暂不入选\n- [babel 7](https://babeljs.io/blog/2018/08/27/7.0.0) 熟悉7.x版本的新变动\n+ [Rollup](https://www.rollupjs.com/guide/big-list-of-options/#watch-options) 了解Rollup和webpack的优缺点，使用Rollup发布一个简单的插件\n- [ES2019、ES2020](https://juejin.im/post/5ca2e1935188254416288eb2#heading-32) 回顾ES新特性，着重8以及以后\n"},{"title":"Progressive Web Apps","url":"/Roundtables/Wanted/pwa.html","content":"# Progressive Web Apps\n\n> [渐进式 Web 应用（PWA）](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)\n\n> [什么是 PWA(lavas)](https://lavas.baidu.com/pwa/engage-retain-users/add-to-home-screen/introduction))\n\n## Service Worker\n\n> [service worker浏览器支持](https://jakearchibald.github.io/isserviceworkerready/)\n\n> [register-service-worker 尤大的插件](https://github.com/yyx990803/register-service-worker)\n\n依赖\n  + Service Worker要求HTTPS 的环境，当然一般浏览器允许调试 Service Worker 的时候 host 为 localhost 或者 127.0.0.1 也是 ok 的。\n\n    **注意：** 当地启动地址为172.0...这类的自然也无法获取到Service Worker\n\n  - Service Worker 的缓存机制是依赖 [Cache API](https://developer.mozilla.org/zh-CN/docs/Web/API/Cache) 实现的\n\n  + 依赖 HTML5 fetch API 和 Promise\n\n**注册Service Worker**\n\n  > [为什么用load监听](https://developers.google.com/web/fundamentals/primers/service-workers/registration)\n\n  ```javascript\n  if ('serviceWorker' in navigator) {\n    window.addEventListener('load', function () {\n        navigator.serviceWorker.register('/sw.js', {scope: '/'})\n            .then(function (registration) {\n\n                // 注册成功\n                console.log('ServiceWorker registration successful with scope: ', registration.scope);\n            })\n            .catch(function (err) {\n\n                // 注册失败:(\n                console.log('ServiceWorker registration failed: ', err);\n            });\n    });\n  }\n  ```\n\n**安装Service worker**\n\n  ```javascript\n    // 监听 service worker 的 install 事件\n    this.addEventListener('install', function (event) {\n        // 如果监听到了 service worker 已经安装成功的话，就会调用 event.waitUntil 回调函数\n        event.waitUntil(\n            // 安装成功后操作 CacheStorage 缓存，使用之前需要先通过 caches.open() 打开对应缓存空间。\n            caches.open('my-test-cache-v1').then(function (cache) {\n                // 通过 cache 缓存对象的 addAll 方法添加 precache 缓存\n                return cache.addAll([\n                    '/',\n                    '/index.html',\n                    '/main.css',\n                    '/main.js',\n                    '/image.jpg'\n                ]);\n            })\n        );\n    });\n  ```\n\n**响应请求**\n\n  > clone的缘故是因为response读取即流失，如果不克隆赋值得到的就会是undefind\n\n  ```javascript\n  this.addEventListener('fetch', function (event) {\n    event.respondWith(\n        caches.match(event.request).then(function (response) {\n            // 来来来，代理可以搞一些代理的事情\n\n            // 如果 Service Worker 有自己的返回，就直接返回，减少一次 http 请求\n            if (response) {\n                return response;\n            }\n\n            // 如果 service worker 没有返回，那就得直接请求真实远程服务\n            var request = event.request.clone(); // 把原始请求拷过来\n            return fetch(request).then(function (httpRes) {\n\n                // http请求的返回已被抓到，可以处置了。\n\n                // 请求失败了，直接返回失败的结果就好了。。\n                if (!httpRes || httpRes.status !== 200) {\n                    return httpRes;\n                }\n\n                // 请求成功的话，将请求缓存起来。\n                var responseClone = httpRes.clone();\n                caches.open('my-test-cache-v1').then(function (cache) {\n                    cache.put(event.request, responseClone);\n                });\n\n                return httpRes;\n            });\n        })\n    );\n  });\n  ```\n**版本更新**\n  1. 可以在 install 事件中执行 self.skipWaiting() 方法跳过 waiting 状态，直接进入 activate 阶段。接着在 activate 事件发生时，通过执行 self.clients.claim() 方法，更新所有客户端上的 Service Worker。\n\n  ```javascript\n    // 安装阶段跳过等待，直接进入 active\n    self.addEventListener('install', function (event) {\n        event.waitUntil(self.skipWaiting());\n    });\n\n    self.addEventListener('activate', function (event) {\n        event.waitUntil(\n            Promise.all([\n\n                // 更新客户端\n                self.clients.claim(),\n\n                // 清理旧版本\n                caches.keys().then(function (cacheList) {\n                    return Promise.all(\n                        cacheList.map(function (cacheName) {\n                            if (cacheName !== 'my-test-cache-v1') {\n                                return caches.delete(cacheName);\n                            }\n                        })\n                    );\n                })\n            ])\n        );\n    });\n  ```\n  2. 借助 Registration.update() 手动更新。\n\n  ```javascript\n    var version = '1.0.1';\n\n    navigator.serviceWorker.register('/sw.js').then(function (reg) {\n        if (localStorage.getItem('sw_version') !== version) {\n            reg.update().then(function () {\n                localStorage.setItem('sw_version', version)\n            });\n        }\n    });\n  ```\n  3. 24小时没有更新，当Update触发时会强制更新。\n\n\n**Server Worker的生命周期**\n\n  + ***安装(installing)*** ：这个状态发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。\n\n    install 事件回调中有两个方法：\n\n    event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\n\n    self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。\n\n  - ***安装后( installed )*** ：Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。\n\n  + ***激活( activating )*** ：在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。\n\n    activate 回调中有两个方法：\n\n    event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\n\n    self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。\n\n  - ***激活后( activated )*** ：在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)。\n\n  + ***废弃状态 ( redundant )*** ：这个状态表示一个 Service Worker 的生命周期结束。\n\n  这里特别说明一下，进入废弃 (redundant) 状态的原因可能为install失败或者activating失败\n\n\n---\n\n## Web App Manifest\n\n>manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。可以安装到设备的主屏幕的网络应用程序，而不需要用户通过应用商店，伴随着其他功能, 比如离线可用和接收推送通知。\n\n>ios中暂时不支持？\n\n+ 页面引入\n\n```javascript\n  // 旧的后缀\n  <link rel=\"manifest\" href=\"/manifest.json\">\n  // 新的后缀\n  <link rel=\"manifest\" href=\"/your.webmanifest\">\n```\n\n- [webmanifest文件配置](https://developer.mozilla.org/zh-CN/docs/Web/Manifest)\n\n+ 初始屏幕\n\n  在Chrome 47及更高版本中，从主屏幕启动的Web应用程序将显示启动画面。 这个启动画面是使用Web应用程序清单中的属性自动生成的，具体来说就是：name，background_color以及icons 中距设备最近128dpi的图标。\n\n---\n\n## 架构\n\n[App Shell 模型](https://developers.google.cn/web/fundamentals/architecture/app-shell)\n"},{"title":"WebAssembly","url":"/Roundtables/Wanted/webAssembly.html","content":" # WebAssembly\n"}]
(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{699:function(v,t,l){"use strict";l.r(t);var _=l(14),n=Object(_.a)({},(function(){var v=this,t=v.$createElement,l=v._self._c||t;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"算法"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),l("h2",{attrs:{id:"复杂度"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[v._v("#")]),v._v(" 复杂度")]),v._v(" "),l("ul",[l("li",[v._v("数组，单循环遍历：O(n)时间复杂度\n"),l("ul",[l("li",[v._v("如果只用到i，是常数级空间复杂度O(1)")]),v._v(" "),l("li",[v._v("如果用到额外空间，比如一个对象当做字典保存数据，空间复杂度就是O(n)")])])]),v._v(" "),l("li",[v._v("数组，双循环遍历：O(n^2)时间复杂度，用到i、j，是常数级空间复杂度O(1)")]),v._v(" "),l("li",[v._v("从数组里，找到第1000个元素，时间复杂度是O(1)，相当于字典直接查")]),v._v(" "),l("li",[v._v("从数组里，找到值为1000的索引，时间复杂度是O(n)，需要遍历")]),v._v(" "),l("li",[v._v("从对象中，找到key为a的值，时间复杂度是O(1)，相当于字典直接查")]),v._v(" "),l("li",[v._v("数组，新增和删除数据的时间复杂度是多少？O(n)\n"),l("ul",[l("li",[v._v("先要位移，再增删：[1,2,3,4] => [1,2,,3,4] => [1,2,3,4,5]")])])]),v._v(" "),l("li",[v._v("链表，新增和删除数据的时间复杂度是多少？O(1)\n"),l("ul",[l("li",[v._v("只需要先断链，直接增加：1-2-3-4 => 1-2 3-4 => 1-2-5-3-4")])])]),v._v(" "),l("li",[v._v("链表，查找元素，复杂度是O(n)\n"),l("ul",[l("li",[v._v("需要遍历")])])])]),v._v(" "),l("p",[v._v("react的fiber架构，就是存储的虚拟dom，从树变成了链表\nvue内部的keep-alive，缓存算法LRU，也是用的链表\n链表+数组，组成了其他所有的数据结构")]),v._v(" "),l("p",[v._v("回溯：不停地试探。放一下，尝试一个结果，再撤销，走下一步。")])])}),[],!1,null,null,null);t.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{768:function(e,t,n){"use strict";n.r(t);var a=n(14),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"前端工程化部署deploy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化部署deploy"}},[e._v("#")]),e._v(" 前端工程化部署deploy")]),e._v(" "),n("blockquote",[n("p",[e._v("本文记录了ESOP-FED 项目工程化部署方案，分别涉及 线上部署流程，nginx原理，cdn原理，CI/CD配置...")])]),e._v(" "),n("hr"),e._v(" "),n("h2",{attrs:{id:"一、前端项目工程化部署流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、前端项目工程化部署流程"}},[e._v("#")]),e._v(" 一、前端项目工程化部署流程")]),e._v(" "),n("ol",[n("li",[e._v("提交代码，push 到 git 远程仓库；")]),e._v(" "),n("li",[e._v("触发 gitlab-ci 的 runners，构建.gitlab-ci.yml中配置的 job；")]),e._v(" "),n("li",[e._v(".gitlab-ci.yml中配置的job，大致会做：从仓库拉取项目代码到nginx服务器，运行 npm run build，运行 npm run cdn；")]),e._v(" "),n("li",[e._v("使用nginx作为静态服务器，代理静态服务，将前端构建好的静态资源dist文件包，都托管到指定服务目录，通过listen配置好的端口（默认80），即可访问静态服务；")]),e._v(" "),n("li",[e._v("npm run build 会把构建好的代码输出到dist目录中，放到nginx静态资源服务器的指定目录里。为了优化，将大部分的静态资源托管到第三方cdn平台上，而在nginx服务器上只托管dist下的index.html入口文件就好了；")]),e._v(" "),n("li",[e._v("npm run cdn 把静态资源（除入口文件外所有的 js，css，img，font等等）上传到 cdn。每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志；")]),e._v(" "),n("li",[e._v("通过浏览器，访问网站前端域名，网站通过index.html入口文件的script标签记录的链接，加载app.xxx.js（同步模块代码）、vendor.xxx.js（依赖包代码）、manifest.xxx.js（指引文件），当路由切换时动态获取异步模块；")])]),e._v(" "),n("h2",{attrs:{id:"二、ci-cd相关知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、ci-cd相关知识"}},[e._v("#")]),e._v(" 二、CI/CD相关知识")]),e._v(" "),n("p",[e._v("CI/CD系统：持续集成和持续部署是微服务架构下的必要组成部分， "),n("code",[e._v("Jenkins")]),e._v("、Github 默认支持的 "),n("code",[e._v("Travis")]),e._v(" 以及 "),n("code",[e._v("GitLab CI")]),e._v(" 都是常用的 CI 工具。\nCI/CD持续集成和持续部署 就是指测试和发布环节，如果能够做到自动化，那么就可以大大加快开发迭代的速度。")]),e._v(" "),n("h3",{attrs:{id:"gitlab-ci-相关术语"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gitlab-ci-相关术语"}},[e._v("#")]),e._v(" GitLab CI 相关术语")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("Pipeline")]),e._v("：流水线。一次 Pipeline 其实相当于一次构建任务。任何提交或者 MR 的合并都可以触发 Pipeline；")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("+------------------+           +----------------+\n|                  |  trigger  |                |\n|   Commit / MR    +----------\x3e+    Pipeline    |\n|                  |           |                |\n+------------------+           +----------------+\n")])])]),n("ul",[n("li",[n("code",[e._v("Stage")]),e._v("：构建阶段。一次 Pipeline 中可以定义多个 Stages，所有 Stages 会按照顺序运行，只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功，任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败；")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("+--------------------------------------------------------+\n|  Pipeline                                              |\n|                                                        |\n|  +-----------+     +------------+      +------------+  |\n|  |  Stage 1  |----\x3e|   Stage 2  |-----\x3e|   Stage 3  |  |\n|  +-----------+     +------------+      +------------+  |\n|                                                        |\n+--------------------------------------------------------+\n")])])]),n("ul",[n("li",[n("code",[e._v("Jobs")]),e._v("，构建工作。是最小的任务单元，每个job只负责一件事情，要么编译，要么测试等。可以在 Stages 里面定义多个 Jobs，一个Stage中的 Jobs 会并行执行，一个Stage中的 Jobs 都执行成功时，该 Stage 才会成功，任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败；")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("+------------------------------------------+\n|  Stage 1                                 |\n|                                          |\n|  +---------+  +---------+  +---------+   |\n|  |  Job 1  |  |  Job 2  |  |  Job 3  |   |\n|  +---------+  +---------+  +---------+   |\n|                                          |\n+------------------------------------------+\n")])])]),n("ul",[n("li",[n("code",[e._v("GitLab Runner")]),e._v("，是实际处理 Job 的，每个 Runner 可以单独配置，Runner 支持多种类型的 Job，同一时间单个 runner 只能处理一个 Job；")]),e._v(" "),n("li",[n("code",[e._v("GitLab Multi Runner")]),e._v("，是一个 GitLab 的开源项目，用来统一管理 Runner；")]),e._v(" "),n("li",[n("code",[e._v("Executor")]),e._v("，每个 Runner 都需要指定一个 Executor，来决定 runner 最终使用哪个执行器进行处理。")])]),e._v(" "),n("h3",{attrs:{id:"ci-cd流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ci-cd流程"}},[e._v("#")]),e._v(" CI/CD流程")]),e._v(" "),n("p",[e._v("一个典型的 Pipeline，一共有 5 个阶段，Build，Test，Release， Staging， Production，每个阶段里都至少有一个 Job，Test 中有两个 Job。")]),e._v(" "),n("p",[e._v("GitLab 会从左往右依次把任务给到 Runner 处理，如果中途有一个任务没有处理成功的话，整个 Pipeline 就会退出。这就是持续集成（CI）、持续发布（CD） 的一个流程。")]),e._v(" "),n("h3",{attrs:{id:"如何使用-gitlab-ci"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-gitlab-ci"}},[e._v("#")]),e._v(" 如何使用 GitLab CI")]),e._v(" "),n("ul",[n("li",[e._v("Gitlab-CI 是GitLab Continuous Integration（"),n("code",[e._v("Gitlab持续集成")]),e._v("）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI,并且对所有项目默认开启。只要在项目仓库的根目录添加."),n("code",[e._v("gitlab-ci.yml文件")]),e._v("，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。")]),e._v(" "),n("li",[e._v("GitLab 中提供了两种 "),n("code",[e._v("Runner")]),e._v(" 的类型，"),n("code",[e._v("特定的 Specific Runner（只能供部分项目使用）")]),e._v("，"),n("code",[e._v("共享的 Shared Runner（所有 GitLab 中的项目都可以使用）")]),e._v("；")]),e._v(" "),n("li",[e._v("比如注册一个 Specific Runner：\n"),n("ul",[n("li",[e._v("第一步安装 GitLab Mutli Runner，直接采用二进制安装即可。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("# For Debian/Ubuntu\nsudo apt-get install gitlab-ci-multi-runner\n\n# For CentOS\nsudo yum install gitlab-ci-multi-runner\n")])])]),n("ul",[n("li",[e._v("第二步注册Runner，"),n("code",[e._v("输入 Gitlab 地址、项目token、runner名称、runner描述、选择执行器类型（shell, docker, docker-ssh, ssh...）等")]),e._v("。注册好了，由于 Multi Runner 支持动态加载配置，所以 Runner 就立即生效了。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("$sudo gitlab-ci-multi-runner register\nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci )\nhttp://gitlab.###.io/ci\nPlease enter the gitlab-ci token for this runner\n########################\nPlease enter the gitlab-ci description for this runner\nmy-runner\nINFO[0034] fcf5c619 Registering runner... succeeded\nPlease enter the executor: shell, docker, docker-ssh, ssh?\nshell\nINFO[0037] Runner registered successfully. Feel free to start it, but if it's\nrunning already the config should be automatically reloaded!\n")])])]),n("ul",[n("li",[e._v("最后，在项目根目录中添加 .gitlab-ci.yml 文件（此文件就是定义了Pipeline的执行方式），具体配置"),n("a",{attrs:{href:"https://docs.gitlab.com/ee/ci/yaml/README.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("gitlab-ci.yml"),n("OutboundLink")],1),e._v("。gitlab-ci.yml文件配置的script，使用基本的shell脚本命令，"),n("a",{attrs:{href:"https://www.runoob.com/linux/linux-shell.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("linux Shell教程"),n("OutboundLink")],1),e._v("。gitlab-ci.yml文件中的变量，如 $CI_PROJECT_ID，$CI_COMMIT_SHA，$CI_COMMIT_REF_NAME 等变量为 GitLab CI 变量，可以在 CI 流程中直接使用这些变量，具体参考 "),n("a",{attrs:{href:"https://docs.gitlab.com/ce/ci/variables/",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitLab CI Variables"),n("OutboundLink")],1),e._v("。")])])])]),e._v(" "),n("h3",{attrs:{id:"为什么不是-gitlab-ci-来运行那些构建任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是-gitlab-ci-来运行那些构建任务"}},[e._v("#")]),e._v(" 为什么不是 GitLab CI 来运行那些构建任务？")]),e._v(" "),n("ul",[n("li",[e._v("构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。")]),e._v(" "),n("li",[e._v("GitLab CI 最大的作用是"),n("code",[e._v("管理各个项目的构建状态")]),e._v("，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 去做。Gitlab-runner 是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的"),n("code",[e._v("相互隔离的机器（或虚拟机）")]),e._v("。")]),e._v(" "),n("li",[e._v("GitLab Runner 不需要和Gitlab安装在同一台机器上，考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner应该安装到不同的机器上。")])]),e._v(" "),n("h3",{attrs:{id:"具体到我们的项目"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#具体到我们的项目"}},[e._v("#")]),e._v(" 具体到我们的项目：")]),e._v(" "),n("ul",[n("li",[e._v("我们的项目选用的runner执行器是 shell，比较简单，如果选择 docker的话，需要额外指定镜像。")]),e._v(" "),n("li",[e._v('目前我们主要共享172.30.xx.xx这台广州机房的测试机，其上面部署了tag为"fed-shell-ci-cd"的runnner。')]),e._v(" "),n("li",[e._v("目前位于GZ_GZJF_xxxx上的测试服务（fed-shell-ci-cd）和gz_gzjf_xxxx 的线上发布服务（ci-fed-publish）的runner均已注册为Shared Runner，默认对所有项目启用生效。所以不再需要特地关联启用Specific Runner。")])]),e._v(" "),n("h2",{attrs:{id:"三、cdn相关知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、cdn相关知识"}},[e._v("#")]),e._v(" 三、CDN相关知识")]),e._v(" "),n("h3",{attrs:{id:"什么是-cdn"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-cdn"}},[e._v("#")]),e._v(" 什么是 CDN？")]),e._v(" "),n("p",[e._v("CDN（Content Delivery Network）即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。可以简单理解成："),n("code",[e._v("CDN 就是一个能让用户以最快速度访问到相应资源的网盘。")])]),e._v(" "),n("h3",{attrs:{id:"使用cdn平台"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用cdn平台"}},[e._v("#")]),e._v(" 使用CDN平台")]),e._v(" "),n("ul",[n("li",[e._v("SPA框架常用webpack来进行打包，最无脑的操作是 将打包后的dist文件整体扔到服务器上，但是用户在访问网站时，从哪个服务器拉取资源非常慢，且还要考做后端缓存。")]),e._v(" "),n("li",[e._v("更科学的方式是"),n("code",[e._v("将dist打包文件做“动静分离”")]),e._v("：借助CDN加速，并且云平台的CDN还自带前端缓存，非常方便。很多平台都有云服务提供，如腾讯云、阿里云...在云平台的控制台开启“对象存储”服务后，开启对应的“加速域名”，此时，针对这个存储桶，就开启了 CDN 加速。“加速域名”就是 CDN 域名。执行npm run build后，打包后的项目文件都放在了/dist/文件下。可以配置webpack，将/dist/static/文件夹直接上传到云平台的对应存储桶的根目录下即可。")]),e._v(" "),n("li",[e._v("具体上传cdn的方式，可以查看项目中的cdn.js文件。通过nodejs的rsync工具，同步文件到CDN上，每次上传都会在项目根目录下生成静态资源清单文件（static.config.json），以输出比较本次构建与之前构建的静态资源文件列表日志。")])]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// webpack打包输出的")]),e._v("\noutput"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    path"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" outputPath"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// dist目录")]),e._v("\n    publicPath"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" publicPath "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 浏览器引用的资源文件公共path路径，即 CDN加速路径")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n")])])]),n("h2",{attrs:{id:"四、nginx静态资源相关知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、nginx静态资源相关知识"}},[e._v("#")]),e._v(" 四、Nginx静态资源相关知识")]),e._v(" "),n("p",[e._v("在前后端分离端项目里，前端的代码会被打包成为纯静态文件。使用 Nginx的目的就是"),n("code",[e._v("让静态文件运行起服务")]),e._v("，由于后端的接口也是分离的，直接请求可能会产生跨域问题，此时就需要Nginx转发代理后端接口。")]),e._v(" "),n("ul",[n("li",[e._v("将前端代码打包后的dist文件放入指定服务目录")]),e._v(" "),n("li",[e._v("将服务目录指定到spa-project/dist目录下即可代理静态服务")]),e._v(" "),n("li",[e._v("配置里开启了gzip压缩，可以很大程度上减小文件体积大小")]),e._v(" "),n("li",[e._v("将404错误页面重定向到index.html，可以解决前端history路由模式由于刷新页面访问不到服务出现404的问题")]),e._v(" "),n("li",[e._v("location为代理接口，可以转发代理后端的请求接口域名或者ip，即可解决接口跨域问题")])]),e._v(" "),n("div",{staticClass:"language-s extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 示例\n# For more information on configuration, see:\n#   * Official English Documentation: http://nginx.org/en/docs/\n\nuser nginx;\nworker_processes auto; #启动进程\nerror_log /var/log/nginx/error.log; #全局错误日志\npid /run/nginx.pid; #PID文件\n\n# Load dynamic modules. See /usr/share/nginx/README.dynamic.\ninclude /usr/share/nginx/modules/*.conf;\n\nevents {\n    worker_connections 1024; #单个后台worker process进程的最大并发链接数 \n}\n\nhttp {\n    gzip on; #开启gzip压缩\n    gzip_min_length 1k; #设置对数据启用压缩的最少字节数\n    gzip_buffers    4 16k;\n    gzip_http_version 1.0;\n    gzip_comp_level 6; #设置数据的压缩等级,等级为1-9，压缩比从小到大\n    gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #设置需要压缩的数据格式\n    gzip_vary on;\n\n    #虚拟主机配置\n    server {\n        listen       80;\n        server_name  mark.binlive.cn;\n        root /home/spa-project/dist; #定义服务器的默认网站根目录位置\n        index index.html; #定义index页面\n        error_page    404         /index.html; #将404错误页面重定向到index.html可以解决history模式访问不到页面问题\n        location ^~ /api/{\n            proxy_pass http://127.0.0.1:7000;\n            proxy_send_timeout 1800;\n            proxy_read_timeout 1800;\n            proxy_connect_timeout 1800;\n            client_max_body_size 2048m;\n            proxy_http_version 1.1;  \n            proxy_set_header Upgrade $http_upgrade;  \n            proxy_set_header Connection \"Upgrade\"; \n            proxy_set_header  Host              $http_host;   # required for docker client's sake\n            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client's IP\n            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header  X-Forwarded-Proto $scheme;\n        }\n        location ^~ /auth/{\n            proxy_pass http://127.0.0.1:7000;\n            proxy_send_timeout 1800;\n            proxy_read_timeout 1800;\n            proxy_connect_timeout 1800;\n            client_max_body_size 2048m;\n            proxy_http_version 1.1;  \n            proxy_set_header Upgrade $http_upgrade;  \n            proxy_set_header Connection \"Upgrade\"; \n            proxy_set_header  Host              $http_host;   # required for docker client's sake\n            proxy_set_header  X-Real-IP         $remote_addr; # pass on real client's IP\n            proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;\n            proxy_set_header  X-Forwarded-Proto $scheme;\n        }\n    }    \n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("nginx -h // 查看Nginx的帮助\nnginx -v // 查看Nginx的版本\nnginx -t // 测试Nginx的配置\nnginx -T // 测试Nginx的配置，并打印配置信息\nnginx // 启动nginx\nnginx -s reload // 重新加载配置文件，平滑启动nginx\nnginx -s stop // 停止nginx的命令\nps -ef |grep nginx // 查看nginx进程\n")])])]),n("h2",{attrs:{id:"参考文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000007180257",target:"_blank",rel:"noopener noreferrer"}},[e._v("GitLab-CI 从安装到差点放弃"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000006120164",target:"_blank",rel:"noopener noreferrer"}},[e._v("用 GitLab CI 进行持续集成"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://xiaozhuanlan.com/topic/3529176084",target:"_blank",rel:"noopener noreferrer"}},[e._v("当谈到 GitLab CI 的时候，我们该聊些什么（上篇）"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/geyouneihan/p/9741021.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("CDN使用心得：加速双刃剑"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5d0c4021f265da1ba431f4d4",target:"_blank",rel:"noopener noreferrer"}},[e._v("Node.js 实现静态文件增量上传CDN"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5b04d775f265da0b807117b1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nginx部署前后端分离服务以及配置说明"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://segmentfault.com/a/1190000017940311?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[e._v("手把手搭建nginx服务器，部署前端代码"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);
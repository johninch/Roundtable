(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{548:function(t,s,a){t.exports=a.p+"assets/img/nodejs-event-loop.2028f983.png"},862:function(t,s,a){"use strict";a.r(s);var e=a(14),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"nodejs-基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-基础"}},[t._v("#")]),t._v(" nodejs 基础")]),t._v(" "),e("h2",{attrs:{id:"nodejs-饭店故事"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-饭店故事"}},[t._v("#")]),t._v(" nodejs 饭店故事")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513044&idx=1&sn=9b8526e9d641b970ee5ddac02dae3c57&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("nodejs 饭店故事 - Node.js : 我只需要一个店小二"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("从计算机视角看「nodejs 饭店故事」：")]),t._v(" "),e("ul",[e("li",[t._v("店小二：线程")]),t._v(" "),e("li",[t._v("顾客：http 请求")]),t._v(" "),e("li",[t._v("第一类工作(迎客，找座，下单)：在服务器端的代码，能够快速执行")]),t._v(" "),e("li",[t._v("后厨做菜，客人吃饭：耗时的 I/O 操作")]),t._v(" "),e("li",[t._v("后厨大喊一声：上菜，这是一个长时间的 I/O 操作完成后所发出的事件")]),t._v(" "),e("li",[t._v("客人说：结账，另外一个长时间的 I/O 操作完成后所发出的事件")]),t._v(" "),e("li",[t._v("第二类工作(上菜，结账，送客)：同样是能快速执行的代码，但是他们需要等待那些耗时的 I/O 操作完成才能开始，确切的来说，收到了系统发出的事件以后才开始执行。在 Node.js 中实际上是在回调函数中来执行的")])]),t._v(" "),e("ol",[e("li",[t._v("下面是 Node.js 服务模式的伪代码：")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("迎客")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("找座")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("下单")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("后厨处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"做菜完成事件"')]),t._v("，"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("上菜处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("客人吃饭")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"吃饭完成事件"')]),t._v("，"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("结账处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("送客")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("Node.js 使用的 JavaScript 作为服务器端的编程语言，这种回调的方式对于 javascript 程序员来说，是非常自然的事情，同时从代码的角度来讲，也显得非常清晰。")]),t._v(" "),e("p",[t._v("另外 Node.js 使用 Chrome 的 V8 引擎来执行 javascript，效率非常高。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("需要引起注意的是，不能写成如下这样：")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("迎客")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("找座")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("下单")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("后厨处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"做菜完成事件"')]),t._v("，"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("上菜处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("；\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("客人吃饭")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"吃饭完成事件"')]),t._v("，"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("结账处理")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("送客")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v('因为 Node.js 执行"后厨处理()"函数时，只是安插了一个匿名的回调函数在那里，并不会等待（非阻塞 I/O），反而马上 会执行“客人吃饭()"函数，所以上述的写法会引起逻辑上的错误：'),e("strong",[t._v("还没上菜就开始吃饭了")]),t._v("！")]),t._v(" "),e("p",[t._v("所以写惯了”顺序阻塞 I/O“的我们需要改变一下思维方式，进入到"),e("code",[t._v("事件驱动的世界")]),t._v("中来。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("如果某个操作例如“上菜处理” 是个"),e("strong",[t._v("CPU 密集型的计算任务")]),t._v("，Node.js 那个唯一的线程就会忙于执行这个计算任务而被阻塞住，就无法响应其他的请求了，带来的后果很严重，整个服务器都无法响应了！这个时候，需要考虑把这样的代码进行异步处理，也变成 node.js 所擅长的事件驱动的方式。")])]),t._v(" "),e("h2",{attrs:{id:"什么是-nodejs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-nodejs"}},[t._v("#")]),t._v(" 什么是 nodejs")]),t._v(" "),e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),e("ul",[e("li",[t._v("Node.js 是一个运行时，可以类比于浏览器，只不过运行在服务端；")]),t._v(" "),e("li",[t._v("这个运行时的方言是 ES，之所以不是 JS，是因为不包含 Window、BOM、DOM 等 web API，而是增加了 Stream、global、Buffer、net 等等 nodejs API；")]),t._v(" "),e("li",[t._v("Node.js 是靠 Chrome V8 引擎运行 ES 的（V8 只实现了 ECMAScript 的数据类型、对象和方法）。")])]),t._v(" "),e("p",[t._v("对应到 Java 我们可以理解 Node.js 是 JDK，装上就能在服务端跑 JavaScript 代码了。")]),t._v(" "),e("p",[t._v("接下来介绍 Node 最核心的两个特性："),e("code",[t._v("事件驱动")]),t._v("、"),e("code",[t._v("非阻塞 I/O")]),t._v("：")]),t._v(" "),e("h3",{attrs:{id:"非阻塞-i-o"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞-i-o"}},[t._v("#")]),t._v(" 非阻塞 I/O")]),t._v(" "),e("p",[t._v("来理解几个概念：")]),t._v(" "),e("ul",[e("li",[t._v("阻塞 IO(blocking I/O)")]),t._v(" "),e("li",[t._v("非阻塞 IO(non-blocking I/O)")]),t._v(" "),e("li",[t._v("同步 IO(synchronous I/O)")]),t._v(" "),e("li",[t._v("异步 IO(synchronous I/O)")])]),t._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[t._v("这里肯定有人想问，异步 I/O 和非阻塞 I/O 不是一回事吗？？")]),t._v(" "),e("p",[t._v("异步 I/O 和非阻塞 I/O"),e("code",[t._v("根本不是同一回事")]),t._v("，曾经笔者一直天真的以为非阻塞 I/O 就是异步 I/O T_T(直到看见朴灵大神的深入浅出 Node.js)。")])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("响水壶的栗子 🌰")]),t._v(" "),e("p",[t._v("老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。")]),t._v(" "),e("ul",[e("li",[t._v("1、老张把水壶放到火上，立等水开。（"),e("code",[t._v("同步阻塞")]),t._v("）老张觉得自己有点傻")]),t._v(" "),e("li",[t._v("2、老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（"),e("code",[t._v("同步非阻塞")]),t._v("）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。")]),t._v(" "),e("li",[t._v("3、老张把响水壶放到火上，立等水开。（"),e("code",[t._v("异步阻塞")]),t._v("）老张觉得这样傻等意义不大")]),t._v(" "),e("li",[t._v("4、老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（"),e("code",[t._v("异步非阻塞")]),t._v("）老张觉得自己聪明了。")])]),t._v(" "),e("p",[t._v("所谓"),e("code",[t._v("同步异步")]),t._v("，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况 2 中），造成老张效率的低下。")]),t._v(" "),e("p",[t._v("所谓"),e("code",[t._v("阻塞非阻塞")]),t._v("，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况 1 和情况 3 中老张就是阻塞的，媳妇喊他都不知道。虽然 3 中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。")])]),t._v(" "),e("h3",{attrs:{id:"事件驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[t._v("#")]),t._v(" 事件驱动")]),t._v(" "),e("p",[t._v("进程如何获知异步 I/O 调用完成，触发回调函数呢？这就要靠 Event Loop 实现，也就是事件驱动。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(548),alt:"nodejs-event-loop"}})]),t._v(" "),e("p",[t._v("请求 - 响应模型：")]),t._v(" "),e("ol",[e("li",[t._v("在 "),e("code",[t._v("Node.js 中所有操作称之为**事件**")]),t._v("，客户端的请求也是事件，所有事件维护在图中最左侧的"),e("code",[t._v("事件队列")]),t._v("中；")]),t._v(" "),e("li",[t._v("Node.js 主线程也就是图中间的循环就是 "),e("code",[t._v("Event Loop")]),t._v("，主要作用是轮询事件队列中是否存在事件\n"),e("ol",[e("li",[t._v("有非阻塞事件，按照先进先出原则依次调用处理")]),t._v(" "),e("li",[t._v("有阻塞事件（"),e("em",[t._v("如果在 Event Loop 中包含同步的 CPU 密集操作，就会阻塞主线程")]),t._v("），交给图中最右侧的 "),e("code",[t._v("内部 C++ 线程池")]),t._v("处理，线程池处理完成后把结果通过 Event Loop 返回给事件队列")]),t._v(" "),e("li",[t._v("进行下一次循环")])])]),t._v(" "),e("li",[t._v("一个请求所有事件都被处理，把响应结果发给客户端，完成一次请求")])]),t._v(" "),e("h2",{attrs:{id:"node-js-性能真的高吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js-性能真的高吗"}},[t._v("#")]),t._v(" Node.js 性能真的高吗？")]),t._v(" "),e("h3",{attrs:{id:"结论"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[t._v("#")]),t._v(" 结论")]),t._v(" "),e("p",[t._v("先说结论："),e("strong",[t._v("nodejs 在 Web 场景性能高，在其他场景性能确实不高，甚至低下。")])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("常识")]),t._v(" "),e("ul",[e("li",[t._v("CPU 运算远远快于 I/O 操作")]),t._v(" "),e("li",[t._v("Web 是典型的 I/O 密集场景")]),t._v(" "),e("li",[t._v("JavaScript 是单线程，但 JavaScript 的 runtime Node.js 并不是，负责 Event Loop 的 libuv 用 C 和 C++ 编写")])])]),t._v(" "),e("p",[t._v("谈论性能，主要是讨论"),e("code",[t._v("高并发场景")]),t._v("。而很多语言是依赖"),e("code",[t._v("多线程")]),t._v("来解决高并发场景的。但这种方式性能并不好，主要有两点：")]),t._v(" "),e("ol",[e("li",[t._v("一个线程处理一条用户请求，处理完成了释放线程，在阻塞 I/O 模型下， I/O 期间该用户线程所占用的 CPU 资源（虽然十分微量，大部分交给了 DMA）什么都不做，等待 I/O，然后响应用户；等待就造成了 CPU 浪费。")]),t._v(" "),e("li",[t._v("开启多个进程/线程，CPU 切换 Context 的时间也十分可观；")])]),t._v(" "),e("p",[t._v("类比到上面提到的厨师（I/O）和服务员（CPU），其实就是相当于给每个厨师都配一个服务员，服务员下完单，厨师（I/O）做菜，服务员（CPU）就开始等。不同于现实世界厨师比服务员的薪资更高，数字世界中 CPU 是比 I/O 更宝贵的资源，所以上面的方式虽然能处理高并发场景，但还是造成了 CPU 浪费。")]),t._v(" "),e("p",[t._v("而 "),e("code",[t._v("Node.js 在高并发、I/O 密集场景性能高，也就是 Web 场景性能高")]),t._v("，主要也是解决了上面多线程方式的问题，没必要一个厨师配一个服务员，整个饭店说不定一个服务员就够了，剩下的钱可以随便做其它事情。")]),t._v(" "),e("p",[t._v("用户请求来了，CPU 的部分做完不用等待 I/O，交给底层（C++线程池）完成，然后可以接着处理下一个请求了，快就快在")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("非阻塞 I/O")])]),t._v(" "),e("li",[e("code",[t._v("Web 场景 I/O 密集")])]),t._v(" "),e("li",[e("code",[t._v("没多线程 Context 切换开销，多出来的开销是维护 EventLoop")])])]),t._v(" "),e("h3",{attrs:{id:"补充两点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#补充两点"}},[t._v("#")]),t._v(" 补充两点")]),t._v(" "),e("ul",[e("li",[t._v("其实 Node.js 在 I/O 密集的 Web 场景相对于使用"),e("strong",[t._v("多进程模型语言")]),t._v("有性能优势，这个优势不是来源于语言，而是"),e("code",[t._v("操作系统实现")]),t._v("，Java 按照这种模型实现性能一样很高；")]),t._v(" "),e("li",[t._v("得益于 V8 的优化和 C/C++ 拓展，Node.js 执行 CPU 密集任务性能并不差，但如果长时间进行 CPU 运算会阻塞后续 I/O 任务发起，用 Java 实现非阻塞模型也会遇到一样问题。")])]),t._v(" "),e("h2",{attrs:{id:"基础大纲"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础大纲"}},[t._v("#")]),t._v(" 基础大纲")]),t._v(" "),e("p",[t._v("参考链接："),e("a",{attrs:{href:"https://www.yuque.com/sunluyong/node/readme",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么 2020 还要学 Node.js"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("由于参考文章里已经写的非常好，为了加强掌握只列大纲：")]),t._v(" "),e("h3",{attrs:{id:"nodejs-系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-系统"}},[t._v("#")]),t._v(" nodejs 系统")]),t._v(" "),e("ul",[e("li",[t._v("模块系统\n"),e("ul",[e("li",[t._v("使用 module.exports 对象导出模块对外接口")]),t._v(" "),e("li",[t._v("使用 require 引入其它模块\n"),e("ul",[e("li",[t._v("模块类型\n"),e("ul",[e("li",[t._v("模块名")]),t._v(" "),e("li",[t._v("文件路径")])])]),t._v(" "),e("li",[t._v("单次加载 & 循环依赖")])])]),t._v(" "),e("li",[t._v("Node.js 每个文件都是一个模块，模块内的变量都是局部变量，不会污染全局变量，在执行模块代码之前，Node.js 会使用一个如下的函数封装器将模块封装")]),t._v(" "),e("li",[t._v("在 Node.js 中使用 ES Module\n"),e("ul",[e("li",[t._v("v12 之前：babel 构建")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('.babelrc\n{\n  "presets": [\n    ["@babel/preset-env", {\n      "targets": {\n        "node": "8.9.0",\n        "esmodules": true\n      }\n    }]\n  ]\n}\n')])])]),e("ul",[e("li",[t._v("v12 之后：原生支持 ES Module。这样 Node.js 会把 js 文件都当做 ES Module 来处理\n"),e("ul",[e("li",[e("ol",[e("li",[t._v("开启 --experimental-modules")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v('模块名修改为 .mjs （强烈不推荐使用）或者 package.json 中设置 "type": module')])])])])])])])])]),t._v(" "),e("li",[t._v("调试")]),t._v(" "),e("li",[t._v("npm & package.json\n"),e("ul",[e("li",[t._v("npm")]),t._v(" "),e("li",[t._v("yarn")]),t._v(" "),e("li",[t._v("package.json\n"),e("ul",[e("li",[t._v("name")]),t._v(" "),e("li",[t._v("version")]),t._v(" "),e("li",[t._v("dependencies & devDependencies")]),t._v(" "),e("li",[t._v("peerDependencies")]),t._v(" "),e("li",[t._v("repository")]),t._v(" "),e("li",[t._v("main")])])])])])]),t._v(" "),e("h3",{attrs:{id:"基础-api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础-api"}},[t._v("#")]),t._v(" 基础 API")]),t._v(" "),e("ul",[e("li",[t._v("Path\n"),e("ul",[e("li",[t._v("Windows 与 POSIX 对比")]),t._v(" "),e("li",[t._v("path.parse() 方法用来解析文件路径，返回 对应的元信息对象")]),t._v(" "),e("li",[t._v("path.format() 方法从对象返回路径字符串，是 path.parse 的反操作")]),t._v(" "),e("li",[t._v("path.normalize() 方法规范化给定的 path，解析 .. 和 .")]),t._v(" "),e("li",[t._v("path.join() 使用操作系统规定的分隔符将参数中的 path 片段连接，并且规范化")]),t._v(" "),e("li",[t._v("path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径")]),t._v(" "),e("li",[t._v("path.resolve() 方法将路径或路径片段的序列解析为绝对路径")]),t._v(" "),e("li",[t._v("path.basename: 返回 path 最后一部分")]),t._v(" "),e("li",[t._v("path.delimiter: 返回操作系统路径界定符，Windows 返回 ; POSIX 返回 :")]),t._v(" "),e("li",[t._v("path.dirname: 返回文件目录名")]),t._v(" "),e("li",[t._v("path.extname: 返回路径的拓展名（jquery.min.js 拓展名是 .js）")]),t._v(" "),e("li",[t._v("path.isAbsolute 检测路径是否是绝对路径")]),t._v(" "),e("li",[t._v("path.sep: 返回路径分隔符，Windows 返回 \\ POSIX 返回 /")])])]),t._v(" "),e("li",[t._v("事件\n"),e("ul",[e("li",[t._v("Node.js 大部分异步操作使用事件驱动，所有可以触发事件的对象都继承了 EventEmitter 类")]),t._v(" "),e("li",[t._v("事件监听\n"),e("ul",[e("li",[t._v("on：EventEmitter 实例会维护一个 listener 数组，每次 listener 默认会被添加到数组尾部")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" emitter "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EventEmitter")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nemitter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ul",[e("li",[t._v("prependListener：添加到 listener 数组头部")]),t._v(" "),e("li",[t._v("once：添加一次")])])]),t._v(" "),e("li",[t._v("事件触发\n"),e("ul",[e("li",[t._v("emitter.emit(eventName[, ...args])")]),t._v(" "),e("li",[t._v("this 指向\n"),e("ul",[e("li",[t._v("this 关键词会被指向 listener 所绑定的 EventEmitter 实例")]),t._v(" "),e("li",[t._v("箭头函数作为监听器时，this 关键词不会指向 EventEmitter 实例")])])]),t._v(" "),e("li",[t._v("异步调用\n"),e("ul",[e("li",[t._v("setImmediate()")]),t._v(" "),e("li",[t._v("process.nextTick()")])])])])]),t._v(" "),e("li",[t._v("事件卸载\n"),e("ul",[e("li",[t._v("off/removeListener")]),t._v(" "),e("li",[t._v("removeAllListeners")])])])])]),t._v(" "),e("li",[t._v("process\n"),e("ul",[e("li",[t._v("process 对象是一个全局变量，是一个 EventEmitter 实例，提供了当前 Node.js 进程的信息和操作方法")]),t._v(" "),e("li",[t._v("系统信息：process 对象提供了属性用于返回关键系统信息，常用的有\n"),e("ul",[e("li",[t._v("title：进程名称，默认值 node，程序可以修改，可以让错误日志更清晰")]),t._v(" "),e("li",[t._v("pid：当前进程 pid")]),t._v(" "),e("li",[t._v("ppid：当前进程的父进程 pid")]),t._v(" "),e("li",[t._v("platform：运行进程的操作系统（aix、drawin、freebsd、linux、openbsd、sunos、win32）")]),t._v(" "),e("li",[t._v("version：Node.js 版本")]),t._v(" "),e("li",[t._v("env：当前 Shell 的所有环境变量")])])]),t._v(" "),e("li",[t._v("Node.js 和标准输入、输出设备交互对象也通过 process 对象提供\n"),e("ul",[e("li",[t._v("stdin & stdout")]),t._v(" "),e("li",[t._v("process.stdin.pipe(process.stdout)")])])]),t._v(" "),e("li",[t._v("执行信息\n"),e("ul",[e("li",[t._v("process.execPath：返回执行当前脚本的 Node 二进制文件的绝对路径")]),t._v(" "),e("li",[t._v("process.argv：返回一个数组，内容是执行脚本时的参数，但数组前两个固定")]),t._v(" "),e("li",[t._v("process.execArgv")])])]),t._v(" "),e("li",[t._v("常用操作方法\n"),e("ul",[e("li",[t._v("process.chdir()：切换工作目录到指定目录")]),t._v(" "),e("li",[t._v("process.cwd()：返回运行当前脚本的工作目录的路径，也就是执行 node 命令时候的目录")]),t._v(" "),e("li",[t._v("process.exit()：退出当前进程")]),t._v(" "),e("li",[t._v("process.memoryUsage()：返回 Node.js 进程的内存使用情况")])])]),t._v(" "),e("li",[t._v("进程事件\n"),e("ul",[e("li",[t._v("exit")]),t._v(" "),e("li",[t._v("uncaughtException")]),t._v(" "),e("li",[t._v("beforeExit")]),t._v(" "),e("li",[t._v("message")]),t._v(" "),e("li",[t._v("process.nextTick(callback)：方法将 callback 添加到下一个时间点的队列执行")])])])])]),t._v(" "),e("li",[t._v("定时器\n"),e("ul",[e("li",[t._v("API\n"),e("ul",[e("li",[t._v("setTimeout")]),t._v(" "),e("li",[t._v("setInterval")]),t._v(" "),e("li",[t._v("setImmediate （nodejs 独有）")]),t._v(" "),e("li",[t._v("process.nextTick （nodejs 独有）")])])]),t._v(" "),e("li",[t._v("event loop\n"),e("ul",[e("li",[e("ol",[e("li",[t._v("timers：执行 "),e("code",[t._v("setTimeout、setInterval")]),t._v(" 回调")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("pending callbacks：执行 I/O（文件、网络等） 回调")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"3"}},[e("li",[t._v("idle, prepare：仅供系统内部调用")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"4"}},[e("li",[t._v("poll：获取新的 I/O 事件，执行相关回调，在适当条件下把阻塞 node")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"5"}},[e("li",[t._v("check："),e("code",[t._v("setImmediate")]),t._v(" 回调在此阶段执行")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"6"}},[e("li",[t._v("close callbacks：执行 socket 等的 close 事件回调")])])]),t._v(" "),e("li",[t._v("日常开发中绝大部分异步任务都是在 timers、poll、check 阶段处理的")]),t._v(" "),e("li",[t._v("为什么 Promise.then 比 setTimeout 早一些\n"),e("ul",[e("li",[t._v("在 Node.js 环境下 microTask 会在每个阶段完成之间调用，也就是每个阶段执行最后都会执行一下 microTask 队列")])])]),t._v(" "),e("li",[t._v("setImmediate VS process.nextTick")])])])])])]),t._v(" "),e("h3",{attrs:{id:"文件操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件操作"}},[t._v("#")]),t._v(" 文件操作")]),t._v(" "),e("ul",[e("li",[t._v("API 风格\n"),e("ul",[e("li",[t._v("异步方法\n"),e("ul",[e("li",[t._v("callback")]),t._v(" "),e("li",[t._v("fs promise API")]),t._v(" "),e("li",[t._v("promisify")])])]),t._v(" "),e("li",[t._v("同步方法\n"),e("ul",[e("li",[t._v("fs 为大部分方法提供了一个同步版本，命名规则是方法名称后面添加 Sync")])])])])]),t._v(" "),e("li",[t._v("文件读取\n"),e("ul",[e("li",[t._v("fs.readFile")]),t._v(" "),e("li",[t._v("fs.open")]),t._v(" "),e("li",[t._v("fs.read")]),t._v(" "),e("li",[t._v("fs.close")]),t._v(" "),e("li",[t._v("fs.createReadStream")])])]),t._v(" "),e("li",[t._v("文件写入\n"),e("ul",[e("li",[t._v("fs.writeFile")]),t._v(" "),e("li",[t._v("fs.write")]),t._v(" "),e("li",[t._v("fs.appendFile")]),t._v(" "),e("li",[t._v("fs.createWriteStream")])])]),t._v(" "),e("li",[t._v("文件夹操作\n"),e("ul",[e("li",[t._v("fs.Dir")]),t._v(" "),e("li",[t._v("fs.Dirent")]),t._v(" "),e("li",[t._v("fs.opendir")]),t._v(" "),e("li",[t._v("fs.readdir")]),t._v(" "),e("li",[t._v("fs.mkdir")]),t._v(" "),e("li",[t._v("fs.rmdir")])])]),t._v(" "),e("li",[t._v("监视文件变化\n"),e("ul",[e("li",[t._v("fs.FSWatcher")]),t._v(" "),e("li",[t._v("fs.watch：监听操作系统提供的事件，而且可以监视目录变化，更高效")]),t._v(" "),e("li",[t._v("fs.watchFile：使用轮训方式检测文件变化")]),t._v(" "),e("li",[t._v("fs.unwatchFile")]),t._v(" "),e("li",[t._v("社区的优秀方案\n"),e("ul",[e("li",[t._v("chokidar")]),t._v(" "),e("li",[t._v("node-watch")])])])])]),t._v(" "),e("li",[t._v("其他常用 API\n"),e("ul",[e("li",[t._v("fs.existsSync：判断路径是否存在\n"),e("ul",[e("li",[t._v("异步版本 fs.exists(path, callback) 已经被废弃")]),t._v(" "),e("li",[t._v("最佳实践：不推荐在对文件操作前使用 fs.exists() 检查文件是否存在，应该直接对文件进行操作，如果文件不存在则处理引发的错误")])])]),t._v(" "),e("li",[t._v("fs.access：测试用户文件(夹)权限")]),t._v(" "),e("li",[t._v("fs.copyFile：复制文件")]),t._v(" "),e("li",[t._v("fs.rename：文件重命名")]),t._v(" "),e("li",[t._v("fs.unlink：删除文件")]),t._v(" "),e("li",[t._v("fs.chmod：修改文件模式")])])])]),t._v(" "),e("h3",{attrs:{id:"buffer-和-stream"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#buffer-和-stream"}},[t._v("#")]),t._v(" Buffer 和 Stream")]),t._v(" "),e("ul",[e("li",[t._v("Buffer\n"),e("ul",[e("li",[t._v("bit 与 Byte\n"),e("ul",[e("li",[t._v("比特，位，1 bit 就是 1 位，64 位操作系统 CPU 一次能处理 2^64 位的数据； - Byte，字节，计量存储或者传输流量的单位，硬盘容量、网速；一个英文字符是一个字节，也就是我们说的 1B，中文字符通常是两个字节（Node.js 中使用三个字节）； - 1 byte = 8 bit - Buffer 处理的是字节。")])])]),t._v(" "),e("li",[t._v("特点\n"),e("ul",[e("li",[t._v("Buffer 类的实例类似于 0 到 255 之间的整型数组。")]),t._v(" "),e("li",[t._v("Buffer 是一个 JavaScript 和 C++ 结合的模块，对象内存不经 V8 分配，而是由 C++ 申请、JavaScript 分配。")]),t._v(" "),e("li",[t._v("大小在创建时确定，不能调整。")]),t._v(" "),e("li",[t._v("Buffer 对象被内置到全局变量中，无需 require 引入。")])])]),t._v(" "),e("li",[t._v("实例化 Buffer\n"),e("ul",[e("li",[t._v("Buffer.from")]),t._v(" "),e("li",[t._v("Buffer.alloc(size [, fill [, encoding]])")]),t._v(" "),e("li",[t._v("Buffer.allocUnsafe（避免使用）")]),t._v(" "),e("li",[t._v("Buffer.allocUnsafeSlow（避免使用）")])])]),t._v(" "),e("li",[t._v("操作 buffer\n"),e("ul",[e("li",[t._v("Buffer 和 string 转换")]),t._v(" "),e("li",[t._v("Buffer 拼接")]),t._v(" "),e("li",[t._v("StringDecoder 避免中文乱码")]),t._v(" "),e("li",[t._v("Buffer.isBuffer")]),t._v(" "),e("li",[t._v("Buffer.isEncoding")]),t._v(" "),e("li",[t._v("buf.length")]),t._v(" "),e("li",[t._v("buf.indexOf")]),t._v(" "),e("li",[t._v("buf.copy")])])]),t._v(" "),e("li",[t._v("Buffer 支持编码\n• ascii\n• utf8\n• utf16le\n• base64\n• binary\n• hex")])])]),t._v(" "),e("li",[t._v("Stream\n"),e("ul",[e("li",[t._v("流：是对输入输出设备的抽象，是一组有序的、有起点和终点的字节数据传输手段；")]),t._v(" "),e("li",[t._v("类型：\n"),e("ul",[e("li",[t._v("设备流向程序：readable 可读流")]),t._v(" "),e("li",[t._v("程序流向设备：writable 可写流")]),t._v(" "),e("li",[t._v("双向流动：duplex、transform 双工流")])])]),t._v(" "),e("li",[t._v("流的操作被封装到 Stream 模块。")]),t._v(" "),e("li",[t._v("而 Unix 的哲学是：一切皆文件：普通文件（txt、jpg、mp4）、设备文件（stdin、stdout）、网络文件（http、net）。Node.js 中对文件的处理多数使用流来完成。")])])])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fs "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"fs"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" rs "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createReadStream")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./package.json"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ws "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("createWriteStream")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./package-lower.json"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nrs"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("pipe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lowercase"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("pipe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("ul",[e("li",[t._v("为什么应该使用 stream？\n"),e("ul",[e("li",[t._v("如果直接操作文件，比如电影这种大文件：\n"),e("ul",[e("li",[t._v("电影文件需要读完之后才能返回给客户，等待时间超长")]),t._v(" "),e("li",[t._v("电影文件需要一次放入内存中，内存吃不消会被打崩")])])]),t._v(" "),e("li",[t._v("使用 stream 操作文件，用户体验得到优化，同时对内存的开销明显下降")])])]),t._v(" "),e("li",[t._v("可读流\n"),e("ul",[e("li",[t._v("可读流：是生产数据用来供程序消费的流。常见的数据生产方式有读取磁盘文件、读取网络请求内容等")]),t._v(" "),e("li",[t._v("process.stdin.pipe(process.stdout);控制台 process.stdin 也是一个可读流")]),t._v(" "),e("li",[t._v("自定义可读流")]),t._v(" "),e("li",[t._v("如何停下来\n"),e("ul",[e("li",[t._v("向缓冲区 push 一个 null")])])])])]),t._v(" "),e("li",[t._v("为什么是 setTimeout 而不是 setInterval\n"),e("ul",[e("li",[t._v("流的两种工作方式\n"),e("ul",[e("li",[e("ol",[e("li",[e("code",[t._v("流动模式")]),t._v("：数据由底层系统读出，并尽可能快地提供给应用程序")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[e("code",[t._v("暂停模式")]),t._v("：必须显式地调用 read() 方法来读取若干数据块")])])])])]),t._v(" "),e("li",[t._v("流在默认状态下是处于暂停模式的，也就是需要程序显式的调用 read() 方法。通过 pipe() 方法可以自动切换成流动模式，这样 read() 方法会自动被反复调用，直到数据读取完毕。")]),t._v(" "),e("li",[t._v("所以每次 read() 方法里面只需要读取一次数据即可，用 setTimeout 而不是 setInterval。")])])]),t._v(" "),e("li",[e("code",[t._v("流动模式和暂停模式切换")]),t._v("：\n"),e("ul",[e("li",[t._v("流从默认的暂停模式切换到流动模式可以使用以下几种方式：\n"),e("ol",[e("li",[t._v("通过"),e("code",[t._v("添加 data 事件监听器")]),t._v("来启动数据监听")]),t._v(" "),e("li",[t._v("调用 "),e("code",[t._v("resume()")]),t._v(" 方法启动数据流")]),t._v(" "),e("li",[t._v("调用 "),e("code",[t._v("pipe()")]),t._v(" 方法将数据转接到另一个可写流")])])]),t._v(" "),e("li",[t._v("从流动模式切换为暂停模式又两种方法：\n"),e("ol",[e("li",[t._v("在流没有 pipe() 时，调用 "),e("code",[t._v("pause()")]),t._v(" 方法可以将流暂停")]),t._v(" "),e("li",[t._v("pipe() 时，移除所有 data 事件的监听，再调用 "),e("code",[t._v("unpipe()")]),t._v(" 方法")])])])])]),t._v(" "),e("li",[t._v("驱动数据流动的两个机制：\n"),e("ul",[e("li",[e("strong",[t._v("流动模式对应的 "),e("code",[t._v("data 事件")])])]),t._v(" "),e("li",[e("strong",[t._v("暂停模式对应的 "),e("code",[t._v("read() 方法")])])]),t._v(" "),e("li",[t._v("数据会不会漏掉？")])])]),t._v(" "),e("li",[t._v("可写流\n"),e("ul",[e("li",[t._v("write() 方法有三个参数\n"),e("ul",[e("li",[t._v("chunk {String| Buffer}，表示要写入的数据")]),t._v(" "),e("li",[t._v("encoding 当写入的数据是字符串的时候可以设置编码")]),t._v(" "),e("li",[t._v("callback 数据被写入之后的回调函数")])])]),t._v(" "),e("li",[t._v("自定义可写流")]),t._v(" "),e("li",[t._v("实例化可写流 options\n"),e("ul",[e("li",[t._v("objectMode")]),t._v(" "),e("li",[t._v("highWaterMark")]),t._v(" "),e("li",[t._v("decodeStrings")])])]),t._v(" "),e("li",[t._v("事件\n"),e("ul",[e("li",[t._v("pipe")]),t._v(" "),e("li",[t._v("unpipe")]),t._v(" "),e("li",[t._v("drain")]),t._v(" "),e("li",[t._v("finish")])])]),t._v(" "),e("li",[t._v("back pressure\n"),e("ul",[e("li",[t._v("一般数据读取的速度会远远快于写入的速度，那么 pipe() 方法是怎么做到供需平衡的呢？\n"),e("ul",[e("li",[t._v("可读流有流动和暂停两种模式，可以通过 pause() 和 resume() 方法切换")]),t._v(" "),e("li",[t._v("可写流的 write() 方法会返回是否能处理当前的数据，每次可以处理多少是 highWatermark 决定的")]),t._v(" "),e("li",[t._v("当可写流处理完了积压数据会触发 drain 事件")])])])])])])]),t._v(" "),e("li",[t._v("双工流\n"),e("ul",[e("li",[t._v("同时实现了 Readable 和 Writable 的流。即可以作为上游生产数据，又可以作为下游消费数据。")]),t._v(" "),e("li",[t._v("在 NodeJS 中双工流常用的有两种\n"),e("ul",[e("li",[e("ol",[e("li",[t._v("Duplex")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("Transform")])])]),t._v(" "),e("li",[t._v("重要的区别：Duplex 虽然同时具备可读流和可写流，但两者是相对独立的；Transform 的可读流的数据会经过一定的处理过程自动进入可写流")])])]),t._v(" "),e("li",[t._v("through2：through2 模块可以方便封装一个 Transform 流")]),t._v(" "),e("li",[t._v("pipeline：链式调用 pipe() 方法，在管道内传输多个流")])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{565:function(t,e){t.exports="data:image/png;base64,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"},566:function(t,e,a){t.exports=a.p+"assets/img/requestIdleCallback.b4e50e4a.png"},567:function(t,e,a){t.exports=a.p+"assets/img/Fiber-Reconcilation.c26ad9b8.png"},879:function(t,e,a){"use strict";a.r(e);var s=a(14),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react-fiber"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" React Fiber")]),t._v(" "),s("h2",{attrs:{id:"fiber-解决什么问题-主线程阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-解决什么问题-主线程阻塞"}},[t._v("#")]),t._v(" Fiber 解决什么问题（主线程阻塞）")]),t._v(" "),s("p",[t._v("VDOM 在操作真正的 DOM 之前，先通过 VDOM 前后对比得出需要更新的部分，再去操作真实的 DOM，减少了浏览器多次操作 DOM 的成本。这一过程，官方起名 "),s("code",[t._v("reconciliation")]),t._v("，可翻译为"),s("code",[t._v("协调算法")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("在 react@15 ，reconciler（stack reconcilation）采用自顶向下递归，更新整个子树。如果组件树不大不会有问题，但是当组件树越来越大，"),s("code",[t._v("递归遍历的成本就越高，持续占用主线程")]),t._v("。")]),t._v(" "),s("li",[t._v("JS 引擎线程、GUI 引擎线程（页面布局和页面绘制）都是运行在浏览器的主渲染进程当中的，而浏览器的渲染进程在同一时间只能做一件事，所以 JS 引擎线程、GUI 引擎线程 之间是互斥的。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。")]),t._v(" "),s("li",[t._v("React 的 stack reconcilation 是"),s("strong",[t._v("CPU 密集型的操作")]),t._v("，"),s("strong",[t._v("并且整个过程是一气呵成的，不能被打断")]),t._v("，在此期间，React 会霸占着浏览器资源，导致两个问题：\n"),s("ol",[s("li",[t._v("一则会导致用户触发的事件得不到响应；")]),t._v(" "),s("li",[t._v("二则会导致掉帧，用户可以感知到这些卡顿（页面元素很多时，整个过程占用的时机就可能超过 16ms (1000ms / 60)，就容易出现掉帧的现象）。")])])])]),t._v(" "),s("p",[s("img",{attrs:{src:a(565),alt:"Stack-Reconcilation"}})]),t._v(" "),s("p",[t._v("体验一下："),s("a",{attrs:{href:"https://claudiopro.github.io/react-fiber-vs-stack-demo/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fiber vs Stack Demo"),s("OutboundLink")],1)]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("前端框架可从 3 个方向 解决「主线程阻塞」问题")]),t._v(" "),s("p",[t._v("对于 '前端框架' 来说，解决这种问题有三个方向:")]),t._v(" "),s("ol",[s("li",[t._v("优化每个任务，让它有多快就多快。挤压 CPU 运算量；")]),t._v(" "),s("li",[t._v("快速响应用户，让用户觉得够快，不能阻塞用户的交互；")]),t._v(" "),s("li",[t._v("尝试 Worker 多线程；")])]),t._v(" "),s("p",[s("em",[t._v("对于 Worker 多线程渲染方案也有人尝试，但要保证状态和视图的一致性相当麻烦。")])]),t._v(" "),s("h4",{attrs:{id:"vue-选择了-1️⃣"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-选择了-1️⃣"}},[t._v("#")]),t._v(" Vue 选择了 1️⃣")]),t._v(" "),s("p",[t._v("因为对于 Vue 来说，使用模板让它有了很多优化的空间，配合响应式机制可以让 Vue 精确地进行节点更新（尤雨溪：如果我们可以"),s("strong",[t._v("把"),s("code",[t._v("更新做得足够快")]),t._v("的话，理论上就不需要时间分片了")]),t._v("）；")]),t._v(" "),s("h4",{attrs:{id:"react-选择了-2️⃣"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-选择了-2️⃣"}},[t._v("#")]),t._v(" React 选择了 2️⃣")]),t._v(" "),s("p",[t._v("为了给用户制造一种应用很快的'假象'，不能让一个程序长期霸占着资源. 你可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的'进程'，我们需要"),s("strong",[t._v("通过某些调度策略"),s("code",[t._v("合理地分配CPU资源")])]),t._v("，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。")])]),t._v(" "),s("h2",{attrs:{id:"fiber-工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-工作原理"}},[t._v("#")]),t._v(" Fiber 工作原理")]),t._v(" "),s("p",[s("strong",[t._v("解决基本思路")]),t._v("：具体解决主线程长时间被 JS 运算占用这一问题，是将运算切割为多个步骤，分批完成。也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染。等浏览器忙完之后，再继续之前未完成的任务。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("可中断/恢复的 Fiber")]),t._v(" "),s("p",[t._v("React@15 使用的是 "),s("strong",[t._v("JS 引擎自身的函数调用栈")]),t._v("，它会一直执行到"),s("strong",[t._v("栈空")]),t._v("为止。")]),t._v(" "),s("p",[t._v("React@16 的 Fiber 实现了"),s("strong",[t._v("自己的组件调用栈")]),t._v("，它以"),s("strong",[t._v("链表")]),t._v("的形式遍历组件树，让自己的 Reconcilation 过程变成"),s("strong",[t._v("可中断")]),t._v("的，可以灵活的暂停、继续和丢弃执行的任务。"),s("strong",[t._v("适时地让出 CPU 执行权")]),t._v("，可以让浏览器及时地响应用户的交互，并且，给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。")])]),t._v(" "),s("p",[t._v("浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:")]),t._v(" "),s("ol",[s("li",[t._v("处理用户输入事件")]),t._v(" "),s("li",[t._v("Javascript 执行")]),t._v(" "),s("li",[t._v("调用 rAF （requestAnimationFrame）")]),t._v(" "),s("li",[t._v("布局 Layout")]),t._v(" "),s("li",[t._v("绘制 Paint\n如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 "),s("code",[t._v("requestIdleCallback")]),t._v(" 的回调。例如")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(566),alt:""}})]),t._v(" "),s("p",[t._v("但是在浏览器繁忙的时候，可能不会有盈余时间，这时候"),s("code",[t._v("requestIdleCallback")]),t._v("回调可能就不会被执行。 为了避免饿死，可以通过"),s("code",[t._v("requestIdleCallback")]),t._v("的第二个参数指定一个超时时间。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("requestIdleCallback")]),t._v(" "),s("p",[s("strong",[t._v("requestIdleCallback")]),t._v(" 的意思是让浏览器在'有空'的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。")])]),t._v(" "),s("h2",{attrs:{id:"fiber-到底是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-到底是什么"}},[t._v("#")]),t._v(" Fiber 到底是什么")]),t._v(" "),s("p",[t._v("知道 Fiber 为什么而生，且知道其原理思路后，再回头来看，Fiber 到底是什么。")]),t._v(" "),s("h3",{attrs:{id:"是一种流程控制-协程调度-scheduling"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#是一种流程控制-协程调度-scheduling"}},[t._v("#")]),t._v(" 是一种流程控制：协程调度 Scheduling")]),t._v(" "),s("p",[t._v("Fiber 也称「协程」，"),s("strong",[s("code",[t._v("协程")]),t._v("只是一种"),s("code",[t._v("控制流程的让出机制")])]),t._v("。协程和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程）。React Fiber 的思想和协程的概念是契合的: React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。")]),t._v(" "),s("p",[t._v("由于浏览器任务不具备中断/恢复的条件，且没有抢占机制，因此，只能"),s("strong",[t._v("采用类似协程这样控制权让出")]),t._v("的 "),s("code",[t._v("合作式调度(Cooperative Scheduling)")]),t._v("，每次只做一个很小的任务，做完后能够“喘口气儿”，回到主线程看下有没有什么更高优先级的任务需要处理，如果有则先处理更高优先级的任务，没有则继续执行。")]),t._v(" "),s("h4",{attrs:{id:"怎么确定有高优先任务要处理-即什么时候让出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么确定有高优先任务要处理-即什么时候让出"}},[t._v("#")]),t._v(" 怎么确定有高优先任务要处理，即什么时候让出？")]),t._v(" "),s("p",[t._v("在目前浏览器中是"),s("code",[t._v("没法判断")]),t._v("当前是否有更高优先级的任务等待被执行。")]),t._v(" "),s("p",[t._v("所以，可以通过"),s("code",[t._v("超时检查的机制")]),t._v("来让出控制权。")]),t._v(" "),s("p",[t._v("解决办法是: React 预定了 5 个优先级（低优先级的可以慢慢等待, 高优先级的任务应该率先被执行），不同优先级对应不同的运行时长，然后在合适的检查点检测是否超时，如果超时就停止执行，将控制权交还给浏览器。")]),t._v(" "),s("p",[s("em",[t._v("React 那为什么不使用 Generator？")]),t._v(" React 尝试过用 Generator 实现，后来发现很麻烦，就放弃了。")]),t._v(" "),s("h3",{attrs:{id:"是一个执行单元-时间分片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#是一个执行单元-时间分片"}},[t._v("#")]),t._v(" 是一个执行单元：时间分片")]),t._v(" "),s("p",[t._v("Fiber 的另外一种解读是「纤维」: 这是"),s("strong",[t._v("一种数据结构或者说"),s("code",[t._v("执行单元")])]),t._v("。")]),t._v(" "),s("p",[t._v("React 没有使用 Generator 这些语言/语法层面的协程让出机制，而是"),s("code",[t._v("实现了自己的调度让出机制")]),t._v("。这个机制就是基于 Fiber 这个执行单元的：React 会从更新队列(updateQueue)中弹出更新任务来执行，每次执行完一个 执行单元, 就会检查现在还剩多少时间，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，将控制权让出去，等下一次有执行权时再恢复。")]),t._v(" "),s("h2",{attrs:{id:"react-对-fiber-的改造"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-对-fiber-的改造"}},[t._v("#")]),t._v(" React 对 Fiber 的改造")]),t._v(" "),s("p",[t._v("「功能改造」首先需要先从「数据结构」下手：")]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("Fiber 结构（新增属性）： 结构信息、副作用、替身")]),t._v(" "),s("div",{staticClass:"language-ts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ts"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fiber")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n\t * ⚛️ 节点的类型信息\n\t */")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件")]),t._v("\n\ttag"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" WorkTag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n\t * ⚛️ 节点的状态\n\t */")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点实例(状态)：")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        对于类组件来说，这里保存类组件的实例")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//        对于函数组件说，这里为空，因为函数组件没有实例")]),t._v("\n\tstateNode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新的、待处理的props")]),t._v("\n\tpendingProps"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染的props")]),t._v("\n\tmemoizedProps"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The props used to create the output.")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染的组件状态")]),t._v("\n\tmemoizedState"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n\t * ⚛️ 结构信息\n\t */")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tchild"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\tsibling"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子节点的唯一键, 即我们渲染列表传入的key属性")]),t._v("\n\tkey"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n\t * ⚛️ 副作用\n\t */")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前节点的副作用类型，例如节点更新、删除、移动")]),t._v("\n\teffectTag"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SideEffectTag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来")]),t._v("\n\tnextEffect"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n\t * ⚛️ 替身\n\t * 指向旧树中的节点\n\t */")]),t._v("\n\talternate"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("p",[t._v("Fiber 包含的属性可以划分为 5 个部分:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("节点类型信息")]),t._v("：tag 表示节点的分类、type 保存具体的类型值，如 div、MyComp；")]),t._v(" "),s("li",[s("strong",[t._v("节点的状态")]),t._v("：节点的组件实例、props、state 等，它们将影响组件的输出；")]),t._v(" "),s("li",[t._v("🎉"),s("strong",[t._v("结构信息(新增)")]),t._v("：新增的 "),s("code",[t._v("上下文信息")]),t._v("，Fiber 依次通过 return、child 及 sibling 的顺序对 ReactElement 做处理，将之前简单的树结构，变成了"),s("code",[t._v("链表的形式")]),t._v("，维护了更多的节点关系。")]),t._v(" "),s("li",[t._v("🎉"),s("strong",[t._v("副作用(新增)")]),t._v("：新增的，在 Reconciliation 过程中发现的 "),s("code",[t._v("副作用(变更需求)")]),t._v("就保存在节点的 effectTag 中(想象为打上一个标记)。也使用了链表结构，在遍历过程中 React 会将所有有"),s("code",[t._v("副作用")]),t._v("的节点都通过 nextEffect 连接起来，从而"),s("code",[t._v("收集本次渲染的所有节点副作用")]),t._v("。")]),t._v(" "),s("li",[t._v("🎉"),s("strong",[t._v("替身(新增)")]),t._v("：新增的"),s("code",[t._v("WIP树")]),t._v("，React 在 Reconciliation 过程中会构建一颗新的树(官方称为 workInProgress tree，"),s("code",[t._v("WIP树")]),t._v(")，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的"),s("code",[t._v("旧树")]),t._v("，React 就是一边和旧树比对，一边构建"),s("code",[t._v("WIP树")]),t._v("的。 alternate 指向旧树的同等节点。")])]),t._v(" "),s("p",[t._v("有了上述数据结构的变更，React 是通过如下几方面来优化的：")]),t._v(" "),s("h3",{attrs:{id:"_1、增加上下文信息-拆分工作单元"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、增加上下文信息-拆分工作单元"}},[t._v("#")]),t._v(" 1、增加上下文信息，拆分工作单元")]),t._v(" "),s("p",[t._v("React@15，Reconcilation 是同步的、递归执行的。称它为 "),s("strong",[t._v("Stack Reconcilation")]),t._v("，是基于函数「调用栈」的 Reconcilation 算法。栈挺好的，代码量少，递归容易理解, 也非常适合树这种嵌套数据结构的处理。只不过这种依赖于"),s("strong",[t._v("调用栈的方式")]),s("code",[t._v("不能随意中断、也很难被恢复, 不利于异步处理")]),t._v("。这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始, 恢复到之前的调用栈。")]),t._v(" "),s("p",[t._v("因此，React 为了模拟函数调用栈, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" type Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber 类型信息")]),t._v("\n\ttype"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ⚛️ 链表结构")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父节点，或者render该节点的组件")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向第一个子节点")]),t._v("\n\tchild"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向下一个兄弟节点")]),t._v("\n\tsibling"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("Fiber 和调用栈帧一样, "),s("strong",[t._v("保存了节点处理的上下文信息")]),t._v("，因为是手动实现的，所以更为可控，我们可以"),s("strong",[t._v("保存在内存中，随时中断和恢复")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2、将渲染拆分为两个阶段-fiber-reconcilation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、将渲染拆分为两个阶段-fiber-reconcilation"}},[t._v("#")]),t._v(" 2、将渲染拆分为两个阶段（Fiber Reconcilation）")]),t._v(" "),s("p",[t._v("在 React@15 中 "),s("code",[t._v("Stack Reconcilation")]),t._v(" 是同步递归的，一边 Diff（即 Reconciliation，两者可视为同一个东西）一边提交。而在 React@16 中，每次渲染有两个阶段："),s("strong",[t._v("Reconciliation(协调阶段)")]),t._v(" 和 "),s("strong",[t._v("Commit(提交阶段)")]),t._v("，被称之为 "),s("code",[t._v("Fiber Reconcilation")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("协调阶段 Reconciliation")]),t._v(": 可以认为是 Diff 阶段，这个阶段"),s("code",[t._v("可以被中断(interruptible)")]),t._v("，这个阶段会找出所有节点变更，例如节点新增、删除、属性变更等等，这些变更，React 称之为"),s("strong",[t._v("副作用(Effects)")]),t._v("。以下生命周期钩子会在协调阶段被调用：\n"),s("ul",[s("li",[t._v("constructor")]),t._v(" "),s("li",[t._v("componentWillMount 废弃")]),t._v(" "),s("li",[t._v("componentWillReceiveProps 废弃")]),t._v(" "),s("li",[t._v("static getDerivedStateFromProps")]),t._v(" "),s("li",[t._v("shouldComponentUpdate")]),t._v(" "),s("li",[t._v("componentWillUpdate 废弃")]),t._v(" "),s("li",[t._v("render")])])]),t._v(" "),s("li",[s("strong",[t._v("提交阶段 Commit")]),t._v(": 将上一个阶段计算出来的需要处理的**副作用(Effects)**一次性执行了。这个阶段必须"),s("code",[t._v("同步执行，不能被打断(not interruptible)")]),t._v(". 这些生命周期钩子在提交阶段被执行:\n"),s("ul",[s("li",[t._v("getSnapshotBeforeUpdate()：严格来说，这个是在进入 commit 阶段前调用")]),t._v(" "),s("li",[t._v("componentDidMount")]),t._v(" "),s("li",[t._v("componentDidUpdate")]),t._v(" "),s("li",[t._v("componentWillUnmount")])])])]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("React 为什么 废弃 可能包含副作用的生命周期方法")]),t._v(" "),s("p",[t._v("在协调阶段如果时间片用完，React 就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。")]),t._v(" "),s("p",[t._v("需要注意的是："),s("strong",[t._v("因为协调阶段可能被中断、恢复，甚至重做，⚠️React 协调阶段的生命周期钩子可能会被调用多次!")]),t._v(", 例如 componentWillMount 可能会被调用两次。")]),t._v(" "),s("p",[s("em",[t._v("因此建议 协调阶段的生命周期钩子不要包含副作用。React@16 索性就废弃了这部分可能包含副作用的生命周期方法，例如 componentWillMount、componentWillUpdate.")])])]),t._v(" "),s("h3",{attrs:{id:"_3、双缓存-wip-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、双缓存-wip-树"}},[t._v("#")]),t._v(" 3、双缓存（WIP 树）")]),t._v(" "),s("p",[t._v("React 中 "),s("code",[t._v("WIP树")]),t._v("（workInProgress tree 工作进度树）就是一个"),s("code",[t._v("缓存")]),t._v("。React 在 Reconciliation 过程中会一边和"),s("code",[t._v("旧树")]),t._v("比较，一边构建一颗新的"),s("code",[t._v("WIP树")]),t._v("，可以认为是一颗表示当前工作进度的树，Diff 完毕后，"),s("strong",[t._v("一次性提交给浏览器")]),t._v("进行渲染。")]),t._v(" "),s("p",[t._v("这样做可以"),s("strong",[t._v("减少内存分配和垃圾回收")]),t._v("。WIP 的节点不完全是新的，比如某颗子树不需要变动，React 会克隆复用旧树中的子树。双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。")]),t._v(" "),s("h3",{attrs:{id:"_4、副作用收集和提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、副作用收集和提交"}},[t._v("#")]),t._v(" 4、副作用收集和提交")]),t._v(" "),s("p",[t._v("收集本次渲染的所有副作用节点，即 将所有打了 EffectTag 标记的节点串联起来，最后将副作用提交（commit）。")]),t._v(" "),s("h2",{attrs:{id:"并发模式-concurrent-mode"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发模式-concurrent-mode"}},[t._v("#")]),t._v(" 并发模式（Concurrent Mode）")]),t._v(" "),s("p",[t._v("图中的波形是浏览器的调用栈执行曲线，React 在开启 "),s("code",[t._v("Concurrent Mode")]),t._v(" 之后就不会挖大坑了，而是一小坑一坑的挖，挖一下休息一下，有紧急任务就优先去做。\n"),s("img",{attrs:{src:a(567),alt:"Fiber-Reconcilation"}})]),t._v(" "),s("h3",{attrs:{id:"并发模式的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发模式的优点"}},[t._v("#")]),t._v(" 并发模式的优点")]),t._v(" "),s("p",[t._v("开启 "),s("code",[t._v("Concurrent Mode")]),t._v(" 后，我们可以得到以下好处:")]),t._v(" "),s("ul",[s("li",[t._v("快速响应用户操作和输入，提升用户交互体验")]),t._v(" "),s("li",[t._v("让动画更加流畅，通过调度，可以让应用保持高帧率")]),t._v(" "),s("li",[t._v("利用好 I/O 操作空闲期或者 CPU 空闲期，进行一些预渲染。比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到 CPU 空闲时才去渲染这部分内容。这和浏览器的 preload 等预加载技术差不多。")]),t._v(" "),s("li",[t._v("用 Suspense 降低加载状态(load state)的优先级，减少闪屏。比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。")])]),t._v(" "),s("p",[t._v("但是它肯定不是完美的，因为浏览器无法实现抢占式调度，无法阻止开发者做傻事的。")]),t._v(" "),s("h3",{attrs:{id:"为什么-react16-没有感觉变快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-react16-没有感觉变快"}},[t._v("#")]),t._v(" 为什么 React16 没有感觉变快")]),t._v(" "),s("p",[t._v("React@16 还是同步渲染的，因为"),s("strong",[t._v("没有开启并发模式")]),t._v("。想要真正体会到 React Fiber 重构的效果（异步渲染），可能要等到 v17。v16 只是一个过渡版本，也就是说，现在的 React 还是同步渲染的，一直在跳票，Fiber 的 Concurrent 并发模式 没开启，渲染还是同步的。而没有开启 Concurrent 模式的 React@16，除了数据结构不同外，和 React@15 没什么区别。")]),t._v(" "),s("h2",{attrs:{id:"参考链接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.im/post/5dadc6045188255a270a0f85",target:"_blank",rel:"noopener noreferrer"}},[t._v("这可能是最通俗的 React Fiber(时间分片) 打开方式"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000018250127?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Fiber 原理介绍"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.youtube.com/watch?v=ByBPyMBTzM0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Concurrent Rendering in React"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);
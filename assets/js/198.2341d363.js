(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{749:function(v,_,l){"use strict";l.r(_);var i=l(14),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("ul",[l("li",[v._v("哈希表\n"),l("ul",[l("li",[l("code",[v._v("E 1. 两数之和")])])])]),v._v(" "),l("li",[v._v("相加\n"),l("ul",[l("li",[l("code",[v._v("M 2. 两数相加")])]),v._v(" "),l("li",[l("code",[v._v("M 445. 两数相加 II")])]),v._v(" "),l("li",[l("code",[v._v("E 415. 字符串相加（处理加法精度）")])])])]),v._v(" "),l("li",[v._v("相乘\n"),l("ul",[l("li",[l("code",[v._v("M 43. 字符串相乘（大数相乘）")])])])]),v._v(" "),l("li",[v._v("回溯与递归\n"),l("ul",[l("li",[l("code",[v._v("M 46. 全排列")])]),v._v(" "),l("li",[l("code",[v._v("M 22. 括号生成")])]),v._v(" "),l("li",[l("code",[v._v("M 93. 复原IP地址")])]),v._v(" "),l("li",[l("code",[v._v("E 汉诺塔问题")])])])]),v._v(" "),l("li",[v._v("组合运算\n"),l("ul",[l("li",[l("code",[v._v("求组合：从n个数组中各选一个元素，有多少种组合")])]),v._v(" "),l("li",[l("code",[v._v("M 17. 电话号码的字母组合")])])])]),v._v(" "),l("li",[v._v("滑动窗口\n"),l("ul",[l("li",[l("code",[v._v("M 3. 无重复字符的最长子串")])])])]),v._v(" "),l("li",[v._v("双指针\n"),l("ul",[l("li",[l("code",[v._v("E 9. 回文数")])]),v._v(" "),l("li",[l("code",[v._v("M 15. 三数之和")])]),v._v(" "),l("li",[l("code",[v._v("M 11. 盛最多水的容器")])]),v._v(" "),l("li",[l("code",[v._v("H 42. 接雨水")])])])]),v._v(" "),l("li",[v._v("二分查找\n"),l("ul",[l("li",[l("code",[v._v("M 33. 搜索旋转排序数组")])]),v._v(" "),l("li",[l("code",[v._v("M 240. 搜索二维矩阵 II")])])])]),v._v(" "),l("li",[v._v("贪心\n"),l("ul",[l("li",[l("code",[v._v("E 121. 买卖股票的最佳时机（一笔交易）")])]),v._v(" "),l("li",[l("code",[v._v("E 122. 买卖股票的最佳时机 II（多笔交易）")])]),v._v(" "),l("li",[l("code",[v._v("E 455. 分发饼干")])])])]),v._v(" "),l("li",[v._v("动态规划\n"),l("ul",[l("li",[l("code",[v._v("M 120. 三角形最小路径和")])]),v._v(" "),l("li",[l("code",[v._v("M 221. 最大正方形")])]),v._v(" "),l("li",[l("code",[v._v("E 62. 不同路径")])]),v._v(" "),l("li",[l("code",[v._v("M 63. 不同路径 II")])]),v._v(" "),l("li",[l("code",[v._v("M 70. 爬楼梯")])]),v._v(" "),l("li",[v._v("🌰"),l("code",[v._v("M 5. 最长回文子串")])]),v._v(" "),l("li",[l("code",[v._v("M 1143. 最长公共子序列")])]),v._v(" "),l("li",[l("code",[v._v("E 198. 打家劫舍")])]),v._v(" "),l("li",[v._v("🌰"),l("code",[v._v("M 322. 零钱兑换（dp[i] = Math.min(dp[i - coin] + 1, dp[i - coin] + 1, ...)）")])]),v._v(" "),l("li",[l("code",[v._v("M 300. 最长上升子序列（dp[i] = Math.max(dp[i], dp[j] + 1)）")])])])]),v._v(" "),l("li",[v._v("深度优先遍历\n"),l("ul",[l("li",[l("code",[v._v("M 200. 岛屿数量")])]),v._v(" "),l("li",[l("code",[v._v("M 695. 岛屿的最大面积")])])])]),v._v(" "),l("li",[v._v("二叉树\n"),l("ul",[l("li",[l("code",[v._v("M 102. 二叉树的层序遍历")])]),v._v(" "),l("li",[l("code",[v._v("M 199. 二叉树的右视图")])]),v._v(" "),l("li",[l("code",[v._v("M 103. 二叉树的锯齿形层次遍历")])]),v._v(" "),l("li",[l("code",[v._v("M 958. 二叉树的完全性检验（index !== ++count）")])]),v._v(" "),l("li",[l("code",[v._v("二叉树的前序遍历")])]),v._v(" "),l("li",[l("code",[v._v("二叉树的中序遍历")])]),v._v(" "),l("li",[l("code",[v._v("二叉搜索树的第k个节点（BST的中序遍历是升序）")])]),v._v(" "),l("li",[l("code",[v._v("二叉树的后序遍历")])]),v._v(" "),l("li",[l("code",[v._v("M 105. 从前序与中序遍历序列构造二叉树")])]),v._v(" "),l("li",[l("code",[v._v("求二叉树的后序遍历")])]),v._v(" "),l("li",[l("code",[v._v("E 统计节点个数")])]),v._v(" "),l("li",[l("code",[v._v("E 111. 二叉树的最小深度（左或右子树为空的话是构不成子树的）")])]),v._v(" "),l("li",[l("code",[v._v("E 104. 二叉树的最大深度")])]),v._v(" "),l("li",[l("code",[v._v("E 543. 二叉树的直径（利用最大深度）")])]),v._v(" "),l("li",[l("code",[v._v("E 110. 平衡二叉树")])]),v._v(" "),l("li",[l("code",[v._v("M 236. 二叉树的最近公共祖先")])]),v._v(" "),l("li",[l("code",[v._v("E 112. 路径总和")])]),v._v(" "),l("li",[l("code",[v._v("判断树相同")])]),v._v(" "),l("li",[l("code",[v._v("E 101. 对称二叉树")])]),v._v(" "),l("li",[l("code",[v._v("求二叉树的镜像")])])])]),v._v(" "),l("li",[v._v("链表\n"),l("ul",[l("li",[l("code",[v._v("E 160. 相交链表")])]),v._v(" "),l("li",[l("code",[v._v("E 141. 环形链表")])]),v._v(" "),l("li",[l("code",[v._v("链表中环的入口结点")])]),v._v(" "),l("li",[l("code",[v._v("M 19. 删除链表的倒数第N个节点")])]),v._v(" "),l("li",[l("code",[v._v("E 21. 合并两个有序链表")])]),v._v(" "),l("li",[l("code",[v._v("E 206. 反转链表")])]),v._v(" "),l("li",[l("code",[v._v("M 92. 反转链表 II（---tmpHead tmpHead.next---prev cur---）")])]),v._v(" "),l("li",[l("code",[v._v("M 143. 重排链表")])]),v._v(" "),l("li",[l("code",[v._v("M 24. 两两交换链表中的节点（四指针）")])])])]),v._v(" "),l("li",[v._v("字符串\n"),l("ul",[l("li",[l("code",[v._v("E 14. 最长公共前缀")])]),v._v(" "),l("li",[l("code",[v._v("E 696. 计数二进制子串")])]),v._v(" "),l("li",[l("code",[v._v("E 557. 反转字符串中的单词 III")])])])]),v._v(" "),l("li",[v._v("数组\n"),l("ul",[l("li",[l("code",[v._v("E 53. 最大子序和")])]),v._v(" "),l("li",[l("code",[v._v("E 674. 最长连续递增序列")])]),v._v(" "),l("li",[l("code",[v._v("E 26. 删除排序数组中的重复项（返回移除后数组的新长度）")])]),v._v(" "),l("li",[l("code",[v._v("M 442. 数组中重复的数据（不用空间，原地哈希）")])]),v._v(" "),l("li",[l("code",[v._v("H 41. 缺失的第一个正数")])]),v._v(" "),l("li",[l("code",[v._v("E 605. 种花问题")])]),v._v(" "),l("li",[l("code",[v._v("M 56. 合并区间")])]),v._v(" "),l("li",[l("code",[v._v("M 670. 最大交换")])]),v._v(" "),l("li",[l("code",[v._v("E 扑克牌中的顺子")])]),v._v(" "),l("li",[l("code",[v._v("E 169. 多数元素")])])])]),v._v(" "),l("li",[v._v("栈\n"),l("ul",[l("li",[l("code",[v._v("E 20. 有效的括号")])])])]),v._v(" "),l("li",[v._v("正则\n"),l("ul",[l("li",[l("code",[v._v("E 459. 重复的子字符串")])])])]),v._v(" "),l("li",[v._v("TopK问题\n"),l("ul",[l("li",[l("code",[v._v("E 414. 第三大的数")])])])]),v._v(" "),l("li",[v._v("设计\n"),l("ul",[l("li",[l("code",[v._v("M 146. LRU缓存机制")])])])])]),v._v(" "),l("p",[v._v("未补全")]),v._v(" "),l("ul",[l("li",[l("code",[v._v("生成二叉搜索树")])]),v._v(" "),l("li",[l("code",[v._v("二叉搜索树的后序遍历")])]),v._v(" "),l("li",[l("code",[v._v("从尾到头打印链表")])]),v._v(" "),l("li",[l("code",[v._v("设计循环队列")])]),v._v(" "),l("li",[l("code",[v._v("M 71. 简化路径")]),v._v(" "),l("ul",[l("li",[v._v("遇到正常的字母时，推入 stack 中")]),v._v(" "),l("li",[v._v("遇到 .. 时，stack 弹出最近一个路径")]),v._v(" "),l("li",[v._v("遇到 . 或者为空时，不修改当前 stack。")]),v._v(" "),l("li",[v._v("最后返回 '/' + stack.join('/') 为新的路径")])])]),v._v(" "),l("li",[l("code",[v._v("M 6. Z 字形变换")])]),v._v(" "),l("li",[l("code",[v._v("E 437. 路径总和 III")]),v._v(" "),l("ul",[l("li",[v._v("此题不需要从根节点到叶子节点，但必须是向下遍历求和，返回路径数")])])]),v._v(" "),l("li",[l("code",[v._v("H 25. K 个一组翻转链表")]),l("em",[v._v("（没掌握）")])]),v._v(" "),l("li",[l("code",[v._v("E 7. 整数反转")]),v._v(" "),l("ul",[l("li",[v._v("取余数，最后判断正负号及是否越界")])])]),v._v(" "),l("li",[l("code",[v._v("排序链表")])]),v._v(" "),l("li",[l("code",[v._v("M 98. 验证二叉搜索树")]),v._v(" "),l("ul",[l("li",[v._v("传递上下界")])])]),v._v(" "),l("li",[l("code",[v._v("E 88. 合并两个有序数组")]),v._v(" "),l("ul",[l("li",[v._v("这个题主要是要注意在nums1上做改动，不用返回任何值")])])]),v._v(" "),l("li",[l("code",[v._v("M 8. 字符串转换整数 (atoi)")])])])])}),[],!1,null,null,null);_.default=e.exports}}]);